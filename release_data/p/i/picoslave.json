{
    "1.2.0": {
        "info": {
            "author": "Janos Kutscherauer",
            "author_email": "janoskut@gmail.com",
            "bugtrack_url": null,
            "classifiers": [],
            "description_content_type": "text/markdown",
            "docs_url": null,
            "download_url": "",
            "downloads": {
                "last_day": -1,
                "last_month": -1,
                "last_week": -1
            },
            "home_page": "https://gitlab.com/janoskut/picoslave",
            "keywords": "python,Raspberry Pi Pico,I2C,testing,mock",
            "license": "MIT",
            "maintainer": "",
            "maintainer_email": "",
            "name": "picoslave",
            "package_url": "https://pypi.org/project/picoslave/",
            "platform": "Linux",
            "project_url": "https://pypi.org/project/picoslave/",
            "project_urls": {
                "Homepage": "https://gitlab.com/janoskut/picoslave"
            },
            "release_url": "https://pypi.org/project/picoslave/1.2.0/",
            "requires_dist": [
                "pyusb (>=1.2)"
            ],
            "requires_python": ">=3.7",
            "summary": "PicoSlave is a dual I2C slave simulator for hardware integration testing",
            "version": "1.2.0",
            "yanked": false,
            "yanked_reason": null
        },
        "last_serial": 15300622,
        "urls": [
            {
                "comment_text": "",
                "digests": {
                    "md5": "21583a1b283af7f2dbe185c1fc404fff",
                    "sha256": "d6705214fe9c2dda9328cda8f1da625f581f97584a3794f993e17cdd37c7ff0d"
                },
                "downloads": -1,
                "filename": "picoslave-1.2.0-py3-none-any.whl",
                "has_sig": false,
                "md5_digest": "21583a1b283af7f2dbe185c1fc404fff",
                "packagetype": "bdist_wheel",
                "python_version": "py3",
                "requires_python": ">=3.7",
                "size": 17900,
                "upload_time": "2022-04-02T15:25:07",
                "upload_time_iso_8601": "2022-04-02T15:25:07.278268Z",
                "url": "https://files.pythonhosted.org/packages/ba/5a/5fcdde27cdc9d0f69c8a169759ad45a1c6a558defcb578751152a110b00a/picoslave-1.2.0-py3-none-any.whl",
                "yanked": false,
                "yanked_reason": null
            },
            {
                "comment_text": "",
                "digests": {
                    "md5": "498c402827ab89b524d0772e4f8edb47",
                    "sha256": "5b942627049a59e68a85382edb8fc2059c7e58d835077d9f0347a4ecc36b776c"
                },
                "downloads": -1,
                "filename": "picoslave-1.2.0.tar.gz",
                "has_sig": false,
                "md5_digest": "498c402827ab89b524d0772e4f8edb47",
                "packagetype": "sdist",
                "python_version": "source",
                "requires_python": ">=3.7",
                "size": 22594,
                "upload_time": "2022-04-02T15:25:08",
                "upload_time_iso_8601": "2022-04-02T15:25:08.957619Z",
                "url": "https://files.pythonhosted.org/packages/1b/65/de01907915ba50d0223c7754e10441cc34a9ebdb521379e572496c859837/picoslave-1.2.0.tar.gz",
                "yanked": false,
                "yanked_reason": null
            }
        ],
        "vulnerabilities": []
    },
    "2.0.0.dev1": {
        "info": {
            "author": "Janos Kutscherauer",
            "author_email": "janoskut@gmail.com",
            "bugtrack_url": null,
            "classifiers": [],
            "description_content_type": "text/markdown",
            "docs_url": null,
            "download_url": "",
            "downloads": {
                "last_day": -1,
                "last_month": -1,
                "last_week": -1
            },
            "home_page": "https://gitlab.com/janoskut/picoslave",
            "keywords": "python,Raspberry Pi Pico,I2C,testing,mock",
            "license": "MIT",
            "maintainer": "",
            "maintainer_email": "",
            "name": "picoslave",
            "package_url": "https://pypi.org/project/picoslave/",
            "platform": "Linux",
            "project_url": "https://pypi.org/project/picoslave/",
            "project_urls": {
                "Homepage": "https://gitlab.com/janoskut/picoslave"
            },
            "release_url": "https://pypi.org/project/picoslave/2.0.0.dev1/",
            "requires_dist": [
                "pyusb (>=1.2)"
            ],
            "requires_python": ">=3.7",
            "summary": "PicoSlave is a dual I2C slave simulator for hardware integration testing",
            "version": "2.0.0.dev1",
            "yanked": false,
            "yanked_reason": null
        },
        "last_serial": 15300622,
        "urls": [
            {
                "comment_text": "",
                "digests": {
                    "md5": "78a580c6665a0c2197760c056fc9804e",
                    "sha256": "83fe2fc0805658f79c887c5b81f63d9bb4845db9f6dd12bdd6ec30c28de9efff"
                },
                "downloads": -1,
                "filename": "picoslave-2.0.0.dev1-py3-none-any.whl",
                "has_sig": false,
                "md5_digest": "78a580c6665a0c2197760c056fc9804e",
                "packagetype": "bdist_wheel",
                "python_version": "py3",
                "requires_python": ">=3.7",
                "size": 19484,
                "upload_time": "2022-06-01T12:58:11",
                "upload_time_iso_8601": "2022-06-01T12:58:11.644748Z",
                "url": "https://files.pythonhosted.org/packages/de/94/6782d51d1ddb3b40a20a1ffdd04eb91e186d2134cc9495044ad3629ee9a9/picoslave-2.0.0.dev1-py3-none-any.whl",
                "yanked": false,
                "yanked_reason": null
            },
            {
                "comment_text": "",
                "digests": {
                    "md5": "6ef10143213cb217a96e22f23d920a90",
                    "sha256": "ec9657c5402d692f329588d8c4566201a1e27e27db9fc40709c0952854d0e70c"
                },
                "downloads": -1,
                "filename": "picoslave-2.0.0.dev1.tar.gz",
                "has_sig": false,
                "md5_digest": "6ef10143213cb217a96e22f23d920a90",
                "packagetype": "sdist",
                "python_version": "source",
                "requires_python": ">=3.7",
                "size": 24757,
                "upload_time": "2022-06-01T12:58:12",
                "upload_time_iso_8601": "2022-06-01T12:58:12.953179Z",
                "url": "https://files.pythonhosted.org/packages/2b/11/29052c1101216539ab12a815bae520456a38e6b8faf22a888a9be1a98f9e/picoslave-2.0.0.dev1.tar.gz",
                "yanked": false,
                "yanked_reason": null
            }
        ],
        "vulnerabilities": []
    },
    "2.0.0.dev2": {
        "info": {
            "author": "Janos Kutscherauer",
            "author_email": "janoskut@gmail.com",
            "bugtrack_url": null,
            "classifiers": [],
            "description": "# PicoSlave\n\n[![pypi](https://img.shields.io/pypi/v/picoslave.svg?maxAge=3600)](https://pypi.org/project/picoslave/)\n[![latest release](https://gitlab.com/janoskut/picoslave/-/badges/release.svg)](https://gitlab.com/janoskut/picoslave/-/releases/permalink/latest)\n[![pipeline status](https://gitlab.com/janoskut/picoslave/badges/develop/pipeline.svg)](https://gitlab.com/janoskut/picoslave/pipelines/develop/latest)\n[![coverage](https://gitlab.com/janoskut/picoslave/badges/develop/coverage.svg?job=report:pytest&key_text=pytest-coverage&key_width=100)](https://gitlab.com/janoskut/picoslave/-/jobs/artifacts/develop/file/htmlcov/index.html?job=report:pytest)\n[![coverage](https://gitlab.com/janoskut/picoslave/badges/develop/coverage.svg?job=report:behave&key_text=behave-coverage&key_width=100)](https://gitlab.com/janoskut/picoslave/-/jobs/artifacts/develop/file/htmlcov/index.html?job=report:behave)\n[![license](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)\n\nPicoSlave is a USB controllable I2C slave device that features two independent I2C devices. Each I2C slave works on 256-bytes register spaces, which can be read and modified via a simple USB interface.\n\nPicoSlave is run on the [Raspberry Pi Pico](https://www.raspberrypi.org/documentation/microcontrollers/raspberry-pi-pico.html) board on the [RP2040](https://www.raspberrypi.com/documentation/microcontrollers/rp2040.html#welcome-to-rp2040) ARM Cortex-M0+ microcontroller. The two I2C interfaces of the board can be used independently or wired together to operate on the same I2C bus.\n\n## Features\n\n- linear register space:\n  - configurable for different word sizes (1, 2, 4)\n  - read/write accessible from I2C and from USB\n- statistics function to count I2C read/write register accesses\n- blocker mode to simulate SDA- or SCL-stuck condition\n\n## Overview\n\n```text\n                     \u2553\u2509\u2509\u2509\u2509\u2509\u2556\n                     \u2551     \u2551\n               \u256d\u2500\u2500\u2500\u2500\u2500\u2551 USB \u2551\u2500\u2500\u2500\u2500\u2500\u256e\n          (TX) \u2525  1  \u2559\u2509\u2509\u2509\u2509\u2509\u255c  40 \u251d\n          (RX) \u2525  2 \u2554\u2557        39 \u251d\n               \u2525  3 \u255a\u255dLED     38 \u251d\n               \u2525  4           37 \u251d\n               \u2525  5 \u2554\u2550\u2550\u2557      36 \u251d\n         \u250c SDA \u2525  6 \u2551BS\u2551      35 \u251d\n    I2C0 \u2534 SCL \u2525  7 \u255a\u2550\u2550\u255d      34 \u251d\n           GND \u2525  8           33 \u251d\n         \u250c SDA \u2525  9 \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513 32 \u251d\n    I2C1 \u2534 SCL \u2525 10 \u2503       \u2503 31 \u251d\n               \u2525 11 \u2503RP2040 \u2503 30 \u251d\n               \u2525 12 \u2503       \u2503 29 \u251d\n               \u2525 13 \u2517\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u251b 28 \u251d\n               \u2525 14           27 \u251d\n               \u2525 15           26 \u251d\n               \u2525 16           25 \u251d\n               \u2525 17           24 \u251d\n               \u2525 18           23 \u251d\n               \u2525 19           22 \u251d\n               \u2525 20   DEBUG   21 \u251d\n               \u2570\u2500\u2500\u2500\u2500\u2500\u2530\u2500\u2500\u2530\u2500\u2500\u2530\u2500\u2500\u2500\u2500\u2500\u256f\n                     S  G  S\n                     W  N  W\n                     C  D  D\n                     L     I\n                     K     O\n```\n\n## Dependencies\n\n### Python\n\n- [`pyusb`](https://pypi.org/project/pyusb/)\n\n## References\n\nThe following sources are used in this project:\n\n- I2C slave based on [vmilea/pico_i2c_slave](https://github.com/vmilea/pico_i2c_slave)\n- [rxi/log.c](https://github.com/rxi/log.c) is used as a submodule for logging\n- Using [TinyUSB](https://github.com/hathach/tinyusb)\n\n## Installation\n\n### Program the Raspberry Pi Pico\n\nTo program the firmware onto the PicoSlave, follow these steps:\n\n- obtain the latest PicoSlave firmware build:\n  [stable](https://gitlab.com/janoskut/picoslave/-/jobs/artifacts/main/file/build/picoslave.uf2?job=build)\n  ([download](https://gitlab.com/janoskut/picoslave/-/jobs/artifacts/main/raw/build/picoslave.uf2?job=build))\n  | [develop](https://gitlab.com/janoskut/picoslave/-/jobs/2315262150/artifacts/file/build/picoslave.uf2)\n  ([download](https://gitlab.com/janoskut/picoslave/-/jobs/artifacts/develop/raw/build/picoslave.uf2?job=build))\n- disconnect the Raspberry Pi Pico from USB\n- while holding the `BOOTSEL` button of the board, connect USB to the PC\n  - the Raspberry Pi Pico should load as a mass storage device to the system\n- copy the `picoslave.uf2` firmware file to the mass storage device\n  - when copying is done, the Raspberry Pi Pico should reboot as `PicoSlave`\n\n### Configure the PicoSlave USB device\n\nTo grant userspace access to the PicoSlave USB device, the `udev` rules must be added to the system. Make sure that the user is part of the `plugdev` user group (default for Ubuntu and Raspberry Pi OS):\n\n```sh\nsudo cp ./contrib/99-picoslave.rules /etc/udev/rules.d/\nsudo udevadm control --reload\nsudo udevadm trigger --attr-match=subsystem=usb\n```\n\nAlternatively, the install script `./util/install.sh` can be executed (it will ask for sudo privileges).\n\nWhen installing `picoslave` as a pip package, the `picoslave-install` script is added to the path and can be used to install the udev rules as well.\n\n### Python `picoslave` package installation\n\nPicoSlave comes as a python package (`picoslave`) which can be installed via `pip`. The package contains a library for operating on PicoSlave devices as well as a CLI for manual operation. The package can be installed from source only, currently\n\n```sh\npython -m pip install git+https://gitlab.com/janoskut/picoslave.git\n```\n\n## Usage\n\nThe PicoSlave allows the following operations to configure the two I2C interfaces slaves operations. All functions are available via the CLI as well as the Python library/package, or via the vendor specific USB interface.\n\n| Operation | Args         | Description |\n|-----------|--------------|-------------|\n| `config`  |              | Configure the I2C interface for slave operation (or other functions) on the specified I2C slave address on the specified memory. The I2C memory is configured as a 2-dimensional array of length `size` and width `width`. Note that an interface that is not yet configured can still already be memory-programmed (`read`/`write`/`clear`). |\n|           | `iface`      | The I2C interface (0 or 1). |\n|           | `function`   | `0x00`: Reset the interface for no operation and release the IO.<br>`0x01..0x7F`: I2C slave function. The 7-bit I2C slave address to operate on.<br>`0xF1`: Blocker function to hold the `SCL` and/or `SDA` signal low to `GND`. |\n| `read`    | | Read data from the I2C memory. When reading/writing data from/to the I2C memory, the memory is seen as a 1-dimensional array without respect to word widths and the result is a linear Byte array. Word interpretation has to be done by the API user. |\n|           | `iface`      | The I2C interface (0 or 1). |\n|           | `addr`       | The (raw) address to start reading from. |\n|           | `size`       | The number of Bytes (not words) to read from the given `addr`. |\n| `write`   | | Write data into the I2C memory. See `read` for how the memory is seen as raw, 1-dimensional memory. As an example, with a I2C slave configured for word `width=2`, in order to have an I2C master read the word `ABCD` from address `0x24`, one would have to write 2 bytes into the raw address `0x48`: `write(iface, addr=0x48, data=bytes([0xAB, 0xCD]))`. Note that data can be written into the I2C memory already before the slave is configured to operate on an I2C address. |\n|           | `iface`      | The I2C interface (0 or 1). |\n|           | `addr`       | The (raw) address to start writing `data` into. |\n|           | `data`       | The data bytes (not words) to write into the given `addr`. |\n| `clear`   |              | Reset all data in the I2C memory to 0 or a given value. |\n|           | `iface`      | The I2C interface (0 or 1). |\n|           | `value=0x00` | The reset value of the I2C memory. |\n| `stat`    |              | Get a read/write statistics report for the selected memory section. The statistics report has a maximum of `size` entries (see `config` operation) and has an entry for each addressable I2C memory address (not raw address). It gives a report for how often each I2C memory address has been read or written on the I2C interface. This report can be used to reverse-engineer or mock an I2C slave device in operation, when the internals of the I2C master or the specification of the to-be-mocked I2C slave are not known. The result data is a byte array with `size` entries, each in the (little-endian) format `{#read}{#write}`, where `#read` and `#write` are numbers of size 4 each. |\n|           | `iface`      | The I2C interface (0 or 1). |\n|           | `addr`       | The I2C memory address (not raw address) to start reading the report for. |\n|           | `size`       | The number of statistics report entries to read (from `addr`). |\n| `reset`   |              | Reset the PicoSlave MCU. This leads to all I2C configuration and memory to be reset, and also the USB device to be re-enumerated. |\n\n### CLI Usage\n\nThe PicoSlave can be configured using the CLI, which can be run from the installed package, or from\nsource (cloned repository):\n\n```sh\n# from source\n./picoslave/__main__.py -h\npython -m picoslave -h\n# from installed package\npicoslave -h\npicoslave <command> -h\n```\n\nSome example CLI usages:\n\n```sh\npicoslave scan                       # scan for PicoSlave USB devices\npicoslave config 0 0x16              # configure I2C0 for 7-bit address 0x16\npicoslave config 1 0x23              # configure I2C1 for 7-bit address 0x23\npicoslave write 0 0x10 aabbccddeeff  # write 6 bytes to memory address 0x10 of I2C0 slave\npicoslave read 0 0x10 6              # read 6 bytes from memory address 0x10 from 12C0 slave\npicoslave clear 0                    # clear the memory of I2C0 slave\npicoslave stat 0                     # get a full statistics dump for read/write access to I2C0 slave\npicoslave reset                      # reset the PicoSlave USB device\n\n# blocker function\npicoslave config -f blocker 0 --signals scl sda  # block on both signals\npicoslave config -f reset 0                      # reset the interface to release the blockage\n```\n\nNote that the CLI allows abbreviations for commands, e.g. `c` for `config`, etc.\n\n### Library Usage\n\nThe Python library to access PicoSlave devices can be used in an almost identical way as the CLI:\n\n```python\nfrom picoslave.picoslave import PicoSlave\n\npicoslave = PicoSlave()\npicoslave.config(iface=0, slave_address=0x16)\npicoslave.write(iface=0, mem_addr=0x10, data=b'aabbccddeeff')\nres: bytes = picoslave.read(iface=0, mem_addr=0x10, size=6)\nprint(' '.join(f'{b:02X}' for b in res))\npicoslave.clear(iface=0)\npicoslave.statistics(iface=0)\npicoslave.reset()\n\n# blocker function\npicoslave.config_blocker(iface=0, scl=True, sda=True)  # block on both signals\npicoslave.config_blocker(iface=0, scl=True)            # release the blockage on sda\npicoslave.config_reset(iface=0)                        # reset the interface to release the blockage\n```\n\n## USB Protocol\n\n### Wire packet\n\nThe top level wire packet wraps the specific packets (host and response) into a simple header, which consists of a length and a checksum:\n\n```text\n[LEN] [PAYLOAD] [CRC]\n```\n\nField      | Size | Description\n-----------|------|-----------------------------------------------\n`LEN`      |  4   | Length of the packet, including [CRC]\n`PAYLOAD`  |  N   | Payload data of variable length, see `Host packet` and `Response packet`\n`CRC`      |  2   | 16-bit CRC-CCITT checksum over [PAYLOAD] initialized with `0x8408`\n\n### Host packet\n\n```text\n[CMD=config] [IFACE]   [ADDR]   [SIZE=N] [DATA]\n[CMD=read]   [IFACE]   [ADDR]   [SIZE=N]\n[CMD=write]  [IFACE]   [ADDR]   [SIZE=N] [DATA]\n[CMD=clear]  [IFACE]   [ADDR]   [SIZE=0]\n[CMD=stat]   [IFACE]   [ADDR]   [SIZE=N]\n[CMD=info]   [IFACE=0] [ADDR=0] [SIZE=0]\n[CMD=reset]  [IFACE=0] [ADDR=0] [SIZE=0]\n```\n\nField    | Size | Description\n---------|------|-----------------------------------------------\n`CMD`    |  1   | command to send to the device\n`IFACE`  |  1   | I2C interface number\n`ADDR`   |  2   | 7-bit address to assign to I2C interface, or (16 bit) memory address to read/write\n`SIZE`   |  2   | `CMD=read`: number of bytes to read<br> `CMD=stat`: number of statistic entries to read<br>`CMD=config/write`: number of bytes to write (must match `len(DATA)`)\n`DATA`   |  N   | `CMD=config`: configuration structure, see \"Configuration Data Structures\"<br>`CMD=write`: data to write\n\n#### Commands\n\nCMD      | Value   | Description\n---------|---------|--------------------------------------------------\n`config` | `0xA0`  | configure the slave given with `IFACE` to operate on the address `ADDR`, or <br>deactivate the slave when `ADDR=0`.\n`read`   | `0xA1`  | read `SIZE` bytes from `ADDR` from the slave given with `IFACE`.\n`write`  | `0xA2`  | write `SIZE` bytes of `DATA` to the slave given with `IFACE`, to address `ADDR`. <br>Note that `SIZE` must match `len(DATA)`.\n`clear`  | `0xA3`  | clear all memory and statistics for the given `IFACE`.<br>Reset memory to the value given at `ADDR`.\n`stat`   | `0xA4`  | read `SIZE` many statistics from `ADDR`. Returns a statistics struct for each address.\n`info`   | `0xB0`  | obtain device information from picoslave, see _\"Info Response\"_\n`reset`  | `0xBF`  | reset the target device. Note that `IFACE` and `ADDR` are ignored, <br>but need to be transmitted as 0.\n\n#### Configuration Data Structures\n\n##### Slave configuration structure\n\nField    | Size | Description\n---------|------|-----------------------------------------------\n`SIZE`   |  2   | The number of I2C adressable words in the memory, after which the internal address counter auto-increments. The maximum (and default) size is 256 words.\n`WIDTH`  |  2   | The word size, in bytes. Allowed values are 1 (default), 2 and 4. Note that internally as well as from the USB interface (see `read`/`write`), the I2C memory is treated as a 1-dimensional array of size `size*width`. The word width defines the I2C-addressable sections. Hence when reading (or writing) from an address `N` from I2C to a memory with `width=2`, then the first read will yield `mem[N*width]` and the next read will yield `mem[N*width+1]`. In terms of endianness, the I2C transmission order can hence be seen as little-endian byte order, as the smaller memory address will be transmitted first.\n\n#### Blocker configuration structure\n\nField  | Size | Description\n-------|------|-----------------------------------------------\n`SCL`  |  1   | hold the SCL signal low to GND\n`SDA`  |  1   | hold the SDA signal low to GND\n\n### Response packet\n\n```text\n[CODE=0] [SIZE=N] [DATA]\n[CODE>0] [SIZE=0]\n```\n\nField    | Size | Description\n---------|------|-----------------------------------------------\n`CODE`   |  0   | response or error code\n`SIZE`   |  2   | number of received data bytes in `DATA`\n`DATA`   |  N   | received data (optional)\n\n### Response Codes\n\nCode | Description\n-----|----------------------------------------------------------\n  0  | `OK` (no error)\n  1  | `CRC_ERROR`\n  2  | `INVALID_PACKET`\n  3  | `INVALID_REQUEST`\n  4  | `INVALID_INTERFACE`\n  5  | `INVALID_ADDRESS`\n  6  | `INVALID_SIZE`\n  7  | `MEMORY_ERROR`\n  8  | `OPERATION_FAILED`\n\n#### Info Response\n\nWith `CMD=info` the `DATA` part of the response is a semicolon separated ASCII string with the following segments:\n\n```text\n[serial];[firmware];[protocol];[ifaces]\n```\n\nSegment      | Description\n-------------|----------------------------------------------------------\n  `serial`   | the device unique serial\n  `firmware` | exact firmware version\n  `protocol` | version of this USB protocol\n  `ifaces`   | number of I2C interfaces\n\n#### Statistics Response\n\nWith `CMD=stat` the `DATA` part of the response is structured data of `SIZE` statistics entries, each corresponding to the memory `ADDR` requested. A statistics entry has the format:\n\n```text\n[READ_CNT][WRITE_CNT]\n```\n\nWhere `READ_CNT` and `WRITE_CNT` are of size `4` each. They tell how many read/write accesses have been made to that register address.\n\nWhen a slave is configured as **address sniffer** (`ADDR=0xFF`), the `stat` command returns read/write count for I2C slave addresses instead of register addresses.\n\n## Development\n\n### Toolchain\n\n```sh\nsudo apt install cmake gcc-arm-none-eabi\n```\n\n### Install SDK\n\n```sh\ngit clone https://github.com/raspberrypi/pico-sdk\nexport PICO_SDK_PATH=\"$(pwd)/pico-sdk\"\n```\n\n### Debugging Raspberry Pi Pico\n\nWiring:\n\n- <https://hackaday.io/project/177198-pi-pico-picoprobe-and-vs-code/details>\n- <https://www.digikey.be/en/maker/projects/raspberry-pi-pico-and-rp2040-cc-part-2-debugging-with-vs-code/470abc7efb07432b82c95f6f67f184c0>\n\n### Compiling and deploying `picoprobe`\n\n[`picoprobe`](https://github.com/raspberrypi/picoprobe) (by \"raspberrypi\") is the firmware which turns a _Raspberry Pi Pico_ into a programmer for other _Raspberry Pi Pico's_.\n\nThe `picoprobe` binary needs to be flashed onto a _Raspberry Pi Pico_ only once.\n\n- latest build (built by us):\n[picoprobe.uf2](https://gitlab.com/janoskut/picoslave/-/jobs/artifacts/develop/file/picoprobe/build/picoprobe.uf2?job=build%3Apicoprobe)\n([download](https://gitlab.com/janoskut/picoslave/-/jobs/artifacts/develop/raw/picoprobe/build/picoprobe.uf2?job=build%3Apicoprobe))\n\n```sh\n# Picoprobe and picotool\ngit clone https://github.com/raspberrypi/picoprobe.git --depth=1\ncmake -S picoprobe -B picoprobe/build\ncmake --build picoprobe/build -j$(nproc)\n# hold the BOOTSEL button and connect the Pico USB\n# assuming the Pico mounts at `/media/<user>/RPI-RP2`\ncp picoprobe/build/picoprobe.uf2 /media/$(whoami)/RPI-RP2\n```\n\n### OpenOCD setup\n\n#### Compile & Install OpenOCD\n\n```sh\nsudo apt install libtool libusb-1.0-0-dev\ngit clone \"https://github.com/raspberrypi/openocd.git\" --branch \"picoprobe\" --depth=1\ncd openocd\n./bootstrap\n./configure --enable-ftdi --enable-sysfsgpio --enable-bcm2835gpio --enable-picoprobe\nmake -j$(nproc)\nsudo make install\n```\n\n#### Configure OpenOCD\n\nIn the `openocd` directory:\n\n```sh\nsudo cp ./contrib/60-openocd.rules /etc/udev/rules.d/\nsudo udevadm control --reload\nsudo udevadm trigger --attr-match=subsystem=usb\n```\n\n#### Test OpenOCD\n\n```sh\nopenocd -f interface/picoprobe.cfg -f target/rp2040.cfg\n# should show something, but no errors\nctrl+c\n```\n\n### Program a binary\n\n```sh\nopenocd -f interface/picoprobe.cfg -f target/rp2040.cfg -c \"program build/picoslave.elf verify reset exit\"\n```\n\nOr use the OpenOCD helper script `picoflash.sh`:\n\n```sh\n# program\n./util/picoflash.sh build/picoslave.elf\n# or e.g. reset target\n./util/picoflash.sh --reset\n```\n\nOr even easier, use the shell tools:\n\n```sh\nsource util/shellutil.sh\nflash\nreset\n```\n\n### Python Development\n\nQA:\n\n```sh\npip install -r requirements-dev.txt\n\nflake8 picoslave\npycodestyle picoslave\nmypy picoslave --strict\n```\n\n### System Testing\n\n-> See `./test/behave/README.md`.\n",
            "description_content_type": "text/markdown",
            "docs_url": null,
            "download_url": "",
            "downloads": {
                "last_day": -1,
                "last_month": -1,
                "last_week": -1
            },
            "home_page": "https://gitlab.com/janoskut/picoslave",
            "keywords": "python,Raspberry Pi Pico,I2C,testing,mock",
            "license": "MIT",
            "maintainer": "",
            "maintainer_email": "",
            "name": "picoslave",
            "package_url": "https://pypi.org/project/picoslave/",
            "platform": "Linux",
            "project_url": "https://pypi.org/project/picoslave/",
            "project_urls": {
                "Homepage": "https://gitlab.com/janoskut/picoslave"
            },
            "release_url": "https://pypi.org/project/picoslave/2.0.0.dev2/",
            "requires_dist": [
                "pyusb (>=1.2)"
            ],
            "requires_python": ">=3.7",
            "summary": "PicoSlave is a dual I2C slave simulator for hardware integration testing",
            "version": "2.0.0.dev2",
            "yanked": false,
            "yanked_reason": null
        },
        "last_serial": 15300622,
        "urls": [
            {
                "comment_text": "",
                "digests": {
                    "md5": "ba9a45651908ee84352178157339559a",
                    "sha256": "cceea5a15074f333dd8a9ecb389724c22513bd327f5e22968b4e4cf574ffd23c"
                },
                "downloads": -1,
                "filename": "picoslave-2.0.0.dev2-py3-none-any.whl",
                "has_sig": false,
                "md5_digest": "ba9a45651908ee84352178157339559a",
                "packagetype": "bdist_wheel",
                "python_version": "py3",
                "requires_python": ">=3.7",
                "size": 20899,
                "upload_time": "2022-10-04T09:48:34",
                "upload_time_iso_8601": "2022-10-04T09:48:34.585072Z",
                "url": "https://files.pythonhosted.org/packages/91/3a/45b272a35b336ba394b71dce55a4cb208f89e98fde0717c2d267107d9aff/picoslave-2.0.0.dev2-py3-none-any.whl",
                "yanked": false,
                "yanked_reason": null
            },
            {
                "comment_text": "",
                "digests": {
                    "md5": "b1dc024725fcb9a9a7ff6352afecb07d",
                    "sha256": "6a60108c249fdd4fbbcd89eda0ce258527f6140109f9bfc4b017c42cd60b6427"
                },
                "downloads": -1,
                "filename": "picoslave-2.0.0.dev2.tar.gz",
                "has_sig": false,
                "md5_digest": "b1dc024725fcb9a9a7ff6352afecb07d",
                "packagetype": "sdist",
                "python_version": "source",
                "requires_python": ">=3.7",
                "size": 26129,
                "upload_time": "2022-10-04T09:48:36",
                "upload_time_iso_8601": "2022-10-04T09:48:36.078775Z",
                "url": "https://files.pythonhosted.org/packages/2d/d0/ac888e40249fe57b2817dbaacb341c0fbae6cf940fec18ff8dfcdca3b436/picoslave-2.0.0.dev2.tar.gz",
                "yanked": false,
                "yanked_reason": null
            }
        ],
        "vulnerabilities": []
    }
}