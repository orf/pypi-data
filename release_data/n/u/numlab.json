{
    "0.1.0": {
        "info": {
            "author": "Jorge Morgado Vega",
            "author_email": "jorge.morgadov@gmail.com",
            "bugtrack_url": null,
            "classifiers": [
                "License :: OSI Approved :: MIT License",
                "Programming Language :: Python :: 3",
                "Programming Language :: Python :: 3.10",
                "Programming Language :: Python :: 3.8",
                "Programming Language :: Python :: 3.9"
            ],
            "description_content_type": "text/markdown",
            "docs_url": null,
            "download_url": "",
            "downloads": {
                "last_day": -1,
                "last_month": -1,
                "last_week": -1
            },
            "home_page": "",
            "keywords": "",
            "license": "MIT",
            "maintainer": "",
            "maintainer_email": "",
            "name": "numlab",
            "package_url": "https://pypi.org/project/numlab/",
            "platform": "",
            "project_url": "https://pypi.org/project/numlab/",
            "project_urls": null,
            "release_url": "https://pypi.org/project/numlab/0.1.0/",
            "requires_dist": [
                "typer (>=0.4.0,<0.5.0)"
            ],
            "requires_python": ">=3.8,<4.0",
            "summary": "Programming language for analyzing mathematical numerical problem's solutions",
            "version": "0.1.0",
            "yanked": false,
            "yanked_reason": null
        },
        "last_serial": 12947631,
        "urls": [
            {
                "comment_text": "",
                "digests": {
                    "md5": "30878686722652faf07bdeb64664635d",
                    "sha256": "03e289ce95d4bc6084c55b551c6f5672af1022f81ace06b92792c8777470b16b"
                },
                "downloads": -1,
                "filename": "numlab-0.1.0-py3-none-any.whl",
                "has_sig": false,
                "md5_digest": "30878686722652faf07bdeb64664635d",
                "packagetype": "bdist_wheel",
                "python_version": "py3",
                "requires_python": ">=3.8,<4.0",
                "size": 278902,
                "upload_time": "2022-02-06T17:04:24",
                "upload_time_iso_8601": "2022-02-06T17:04:24.096107Z",
                "url": "https://files.pythonhosted.org/packages/69/7f/3bdee0f105dbb111230e225fa81cc474cc7ca419ea7b2b456f1563bcb158/numlab-0.1.0-py3-none-any.whl",
                "yanked": false,
                "yanked_reason": null
            },
            {
                "comment_text": "",
                "digests": {
                    "md5": "f011cc26bfb89e38f0eb55e266f3a27d",
                    "sha256": "e38f01f4c8e6873c80fe7059492996c98762f4b5e7501905106293f7b228da66"
                },
                "downloads": -1,
                "filename": "numlab-0.1.0.tar.gz",
                "has_sig": false,
                "md5_digest": "f011cc26bfb89e38f0eb55e266f3a27d",
                "packagetype": "sdist",
                "python_version": "source",
                "requires_python": ">=3.8,<4.0",
                "size": 270682,
                "upload_time": "2022-02-06T17:04:26",
                "upload_time_iso_8601": "2022-02-06T17:04:26.595791Z",
                "url": "https://files.pythonhosted.org/packages/9b/fe/e511b377ce01a891e252abc01f97ab1519393f5c8bd23ace43bd8793feba/numlab-0.1.0.tar.gz",
                "yanked": false,
                "yanked_reason": null
            }
        ],
        "vulnerabilities": []
    },
    "0.1.1": {
        "info": {
            "author": "Jorge Morgado Vega",
            "author_email": "jorge.morgadov@gmail.com",
            "bugtrack_url": null,
            "classifiers": [
                "License :: OSI Approved :: MIT License",
                "Programming Language :: Python :: 3",
                "Programming Language :: Python :: 3.10",
                "Programming Language :: Python :: 3.8",
                "Programming Language :: Python :: 3.9"
            ],
            "description_content_type": "text/markdown",
            "docs_url": null,
            "download_url": "",
            "downloads": {
                "last_day": -1,
                "last_month": -1,
                "last_week": -1
            },
            "home_page": "",
            "keywords": "",
            "license": "MIT",
            "maintainer": "",
            "maintainer_email": "",
            "name": "numlab",
            "package_url": "https://pypi.org/project/numlab/",
            "platform": "",
            "project_url": "https://pypi.org/project/numlab/",
            "project_urls": null,
            "release_url": "https://pypi.org/project/numlab/0.1.1/",
            "requires_dist": [
                "typer (>=0.4.0,<0.5.0)"
            ],
            "requires_python": ">=3.8,<4.0",
            "summary": "Programming language for analyzing mathematical numerical problem's solutions",
            "version": "0.1.1",
            "yanked": false,
            "yanked_reason": null
        },
        "last_serial": 12947631,
        "urls": [
            {
                "comment_text": "",
                "digests": {
                    "md5": "4fb1ec2d69abcb72d9736a421e38d093",
                    "sha256": "0b95b9ed71acc2f098a6f87f4c3f63f83fbcda4723f238dab46e6b1372668dc9"
                },
                "downloads": -1,
                "filename": "numlab-0.1.1-py3-none-any.whl",
                "has_sig": false,
                "md5_digest": "4fb1ec2d69abcb72d9736a421e38d093",
                "packagetype": "bdist_wheel",
                "python_version": "py3",
                "requires_python": ">=3.8,<4.0",
                "size": 279448,
                "upload_time": "2022-02-06T17:49:09",
                "upload_time_iso_8601": "2022-02-06T17:49:09.986043Z",
                "url": "https://files.pythonhosted.org/packages/c0/d2/283ee4c53bc60fd697eae1a4f952316393253dd9d11b36fdbbafad21addc/numlab-0.1.1-py3-none-any.whl",
                "yanked": false,
                "yanked_reason": null
            },
            {
                "comment_text": "",
                "digests": {
                    "md5": "3e9829e392709866047a4a7866a6c05b",
                    "sha256": "9f99046b7ff1ee529acdb33464754909dfa77c24d33ce8a2334a4acc686fd5b1"
                },
                "downloads": -1,
                "filename": "numlab-0.1.1.tar.gz",
                "has_sig": false,
                "md5_digest": "3e9829e392709866047a4a7866a6c05b",
                "packagetype": "sdist",
                "python_version": "source",
                "requires_python": ">=3.8,<4.0",
                "size": 276045,
                "upload_time": "2022-02-06T17:49:11",
                "upload_time_iso_8601": "2022-02-06T17:49:11.611476Z",
                "url": "https://files.pythonhosted.org/packages/2f/eb/3888381539a95291f1afabf8923e14ad3bad35b2e2161484ba0d37182d03/numlab-0.1.1.tar.gz",
                "yanked": false,
                "yanked_reason": null
            }
        ],
        "vulnerabilities": []
    },
    "0.2.0": {
        "info": {
            "author": "Jorge Morgado Vega",
            "author_email": "jorge.morgadov@gmail.com",
            "bugtrack_url": null,
            "classifiers": [
                "License :: OSI Approved :: MIT License",
                "Programming Language :: Python :: 3",
                "Programming Language :: Python :: 3.10",
                "Programming Language :: Python :: 3.8",
                "Programming Language :: Python :: 3.9"
            ],
            "description_content_type": "text/markdown",
            "docs_url": null,
            "download_url": "",
            "downloads": {
                "last_day": -1,
                "last_month": -1,
                "last_week": -1
            },
            "home_page": "",
            "keywords": "",
            "license": "MIT",
            "maintainer": "",
            "maintainer_email": "",
            "name": "numlab",
            "package_url": "https://pypi.org/project/numlab/",
            "platform": "",
            "project_url": "https://pypi.org/project/numlab/",
            "project_urls": null,
            "release_url": "https://pypi.org/project/numlab/0.2.0/",
            "requires_dist": [
                "typer (>=0.4.0,<0.5.0)"
            ],
            "requires_python": ">=3.8,<4.0",
            "summary": "Programming language for analyzing mathematical numerical problem's solutions",
            "version": "0.2.0",
            "yanked": false,
            "yanked_reason": null
        },
        "last_serial": 12947631,
        "urls": [
            {
                "comment_text": "",
                "digests": {
                    "md5": "69f0cf02f7204963263cfc215b7cb7de",
                    "sha256": "911b2dd143c55cd141520f221e4d43450172755be7ada169238dcf18a202725c"
                },
                "downloads": -1,
                "filename": "numlab-0.2.0-py3-none-any.whl",
                "has_sig": false,
                "md5_digest": "69f0cf02f7204963263cfc215b7cb7de",
                "packagetype": "bdist_wheel",
                "python_version": "py3",
                "requires_python": ">=3.8,<4.0",
                "size": 283253,
                "upload_time": "2022-02-07T00:19:13",
                "upload_time_iso_8601": "2022-02-07T00:19:13.883050Z",
                "url": "https://files.pythonhosted.org/packages/db/46/7e089cf691159919bf22ebbf48c94ae752e494d09eebe6ef012c487dbe73/numlab-0.2.0-py3-none-any.whl",
                "yanked": false,
                "yanked_reason": null
            },
            {
                "comment_text": "",
                "digests": {
                    "md5": "be2bf23bca414829e5c3298cd6707df4",
                    "sha256": "0a6feb3914626ce9a6971e489fb44ff6dbecc97eb65ddbe98ef5f22850ec58c5"
                },
                "downloads": -1,
                "filename": "numlab-0.2.0.tar.gz",
                "has_sig": false,
                "md5_digest": "be2bf23bca414829e5c3298cd6707df4",
                "packagetype": "sdist",
                "python_version": "source",
                "requires_python": ">=3.8,<4.0",
                "size": 281798,
                "upload_time": "2022-02-07T00:19:15",
                "upload_time_iso_8601": "2022-02-07T00:19:15.513563Z",
                "url": "https://files.pythonhosted.org/packages/50/d0/1ae59e729d288abbeaf739b878f87b57b55c3571f351284825f2096d5df3/numlab-0.2.0.tar.gz",
                "yanked": false,
                "yanked_reason": null
            }
        ],
        "vulnerabilities": []
    },
    "0.2.1": {
        "info": {
            "author": "Jorge Morgado Vega",
            "author_email": "jorge.morgadov@gmail.com",
            "bugtrack_url": null,
            "classifiers": [
                "License :: OSI Approved :: MIT License",
                "Programming Language :: Python :: 3",
                "Programming Language :: Python :: 3.10",
                "Programming Language :: Python :: 3.8",
                "Programming Language :: Python :: 3.9"
            ],
            "description_content_type": "text/markdown",
            "docs_url": null,
            "download_url": "",
            "downloads": {
                "last_day": -1,
                "last_month": -1,
                "last_week": -1
            },
            "home_page": "",
            "keywords": "",
            "license": "MIT",
            "maintainer": "",
            "maintainer_email": "",
            "name": "numlab",
            "package_url": "https://pypi.org/project/numlab/",
            "platform": "",
            "project_url": "https://pypi.org/project/numlab/",
            "project_urls": null,
            "release_url": "https://pypi.org/project/numlab/0.2.1/",
            "requires_dist": [
                "typer (>=0.4.0,<0.5.0)"
            ],
            "requires_python": ">=3.8,<4.0",
            "summary": "Programming language for analyzing mathematical numerical problem's solutions",
            "version": "0.2.1",
            "yanked": false,
            "yanked_reason": null
        },
        "last_serial": 12947631,
        "urls": [
            {
                "comment_text": "",
                "digests": {
                    "md5": "ee977bdafb831dcbc3fb2d9562c5b990",
                    "sha256": "c50cd3ec8fde052c3aab018901b241bd6d5e752ffe0939c8558d6c1b1de23356"
                },
                "downloads": -1,
                "filename": "numlab-0.2.1-py3-none-any.whl",
                "has_sig": false,
                "md5_digest": "ee977bdafb831dcbc3fb2d9562c5b990",
                "packagetype": "bdist_wheel",
                "python_version": "py3",
                "requires_python": ">=3.8,<4.0",
                "size": 283250,
                "upload_time": "2022-02-18T02:04:15",
                "upload_time_iso_8601": "2022-02-18T02:04:15.766636Z",
                "url": "https://files.pythonhosted.org/packages/e5/61/82ca45d8ee657ba2fc7abc8b79899a61a273c99ae1f0d3781dcdbd899598/numlab-0.2.1-py3-none-any.whl",
                "yanked": false,
                "yanked_reason": null
            },
            {
                "comment_text": "",
                "digests": {
                    "md5": "d8daff278883bc898e7e08560ffe6b4e",
                    "sha256": "f65a65530e82c4442c9a7db45825ffc18d92dc3f75cf44bb643d7879b364bc0b"
                },
                "downloads": -1,
                "filename": "numlab-0.2.1.tar.gz",
                "has_sig": false,
                "md5_digest": "d8daff278883bc898e7e08560ffe6b4e",
                "packagetype": "sdist",
                "python_version": "source",
                "requires_python": ">=3.8,<4.0",
                "size": 281727,
                "upload_time": "2022-02-18T02:04:17",
                "upload_time_iso_8601": "2022-02-18T02:04:17.269303Z",
                "url": "https://files.pythonhosted.org/packages/39/05/6e940b13a94e4be0093c332936e10357a88b52812ea685050696a36da0ef/numlab-0.2.1.tar.gz",
                "yanked": false,
                "yanked_reason": null
            }
        ],
        "vulnerabilities": []
    },
    "0.2.2": {
        "info": {
            "author": "Jorge Morgado Vega",
            "author_email": "jorge.morgadov@gmail.com",
            "bugtrack_url": null,
            "classifiers": [
                "License :: OSI Approved :: MIT License",
                "Programming Language :: Python :: 3",
                "Programming Language :: Python :: 3.10",
                "Programming Language :: Python :: 3.8",
                "Programming Language :: Python :: 3.9"
            ],
            "description": "# Numlab\n\n## Contenidos\n\n- [Objetivos](https://github.com/jmorgadov/NumLab#objetivos)\n- [\u00bfC\u00f3mo instalar numlab?](https://github.com/jmorgadov/NumLab#c%C3%B3mo-instalar-numlab)\n- [Lenguaje](https://github.com/jmorgadov/NumLab#lenguaje)\n  - [Caracter\u00edsticas b\u00e1sicas](https://github.com/jmorgadov/NumLab#caracter%C3%ADsticas-b%C3%A1sicas)\n  - [Estad\u00edsticas en tiempo de ejecuci\u00f3n](https://github.com/jmorgadov/NumLab#estad%C3%ADsticas-en-tiempo-de-ejecuci%C3%B3n)\n  - [Simulaci\u00f3n de c\u00f3digo](https://github.com/jmorgadov/NumLab#simulaci%C3%B3n-de-c%C3%B3digo)\n    - [Configuraci\u00f3n de la simulaci\u00f3n](https://github.com/jmorgadov/NumLab#configuraci%C3%B3n-de-la-simulaci%C3%B3n)\n    - [Regiones de c\u00f3digo simuladas](https://github.com/jmorgadov/NumLab#regiones-de-c%C3%B3digo-simuladas)\n- [Implementaci\u00f3n](https://github.com/jmorgadov/NumLab#implementaci%C3%B3n)\n  - [Motor de expresiones regulares](https://github.com/jmorgadov/NumLab#motor-de-expresiones-regulares)\n  - [Tokenizador](https://github.com/jmorgadov/NumLab#tokenizador)\n  - [Gram\u00e1ticas](https://github.com/jmorgadov/NumLab#gram%C3%A1ticas)\n  - [\u00c1rbol de Sintaxis Abstracta (AST)](https://github.com/jmorgadov/NumLab#%C3%A1rbol-de-sintaxis-abstracta-ast)\n  - [Parser](https://github.com/jmorgadov/NumLab#parser)\n  - [Visitors](https://github.com/jmorgadov/NumLab#visitors)\n  - [Ejecuci\u00f3n](https://github.com/jmorgadov/NumLab#ejecuci%C3%B3n)\n    - [Tipos y funciones predefinidas](https://github.com/jmorgadov/NumLab#tipos-y-funciones-predefinidas)\n    - [Contextos](https://github.com/jmorgadov/NumLab#contextos)\n    - [Evaluaci\u00f3n](https://github.com/jmorgadov/NumLab#evaluaci%C3%B3n)\n- [Optimizaci\u00f3n de c\u00f3digo](https://github.com/jmorgadov/NumLab#optimizaci%C3%B3n-de-c%C3%B3digo)\n  - [Sistema difuso para la estimaci\u00f3n de la calidad de la optimizaci\u00f3n](https://github.com/jmorgadov/NumLab#sistema-difuso-para-la-estimaci%C3%B3n-de-la-calidad-de-la-optimizaci%C3%B3n)\n  - [Ejemplo de optimizaci\u00f3n](https://github.com/jmorgadov/NumLab#ejemplo-de-optimizaci%C3%B3n)\n- [Extras](https://github.com/jmorgadov/NumLab#extras)\n  - [Aplicaci\u00f3n CLI](https://github.com/jmorgadov/NumLab#aplicaci%C3%B3n-cli)\n  - [Extensi\u00f3n de VSCode](https://github.com/jmorgadov/NumLab#extensi%C3%B3n-de-vscode)\n\n## Objetivos\n\nEl objetivo de este proyecto es crear una herramienta de aprendizaje\ndesarrollada para ayudar a los estudiantes de Ciencias de la Computaci\u00f3n que\nest\u00e1n cursando la asignatura Matem\u00e1tica Num\u00e9rica. Se quiere crear un lenguaje\nbasado en Python en el cual los estudiantes implementen soluciones de problemas\nnum\u00e9ricos como: hallar cero de funciones, resolver sistemas de ecuaciones,\nentre otros; y a la vez, realizar un an\u00e1lisis de la ejecuci\u00f3n de estas\nsoluciones.\n\nUna de las caracter\u00edsticas que tendr\u00e1 este lenguaje es la capacidad de simular\nregiones de c\u00f3digo bajo ciertas condiciones o limitantes, como por ejemplo:\nlimitar el tiempo de ejecuci\u00f3n, limitar la cantidad de variables que se pueden\ncrear, lmitar el tiempo que toma realizar una operaci\u00f3n determinada, entre\notras. Esto fomenta en los estudiantes la b\u00fasqueda de soluciones m\u00e1s\neficientes. Adem\u00e1s, el lenguaje tambi\u00e9n constar\u00e1 con la posibilidad, mediante\nun algoritmo gen\u00e9tico, de optimizar c\u00f3digos ya escritos.\n\n## \u00bfC\u00f3mo instalar numlab?\n\n```bash\npip install numlab\n```\n\nPara m\u00e1s informaci\u00f3n sobre el uso del programa:\n\n```bash\nnumlab --help\n```\n\n> Tambi\u00e9n se encuentra una breve descripci\u00f3n en la secci\u00f3n\n> [Aplicaci\u00f3n CLI](https://github.com/jmorgadov/NumLab#aplicaci%C3%B3n-cli)\n\n\n## Lenguaje\n\n**Numlab** es el lenguaje que se ha implementado para dar soluci\u00f3n a los\nobjetivos mencionados anteriormente. En las siquientes secciones, se muestran\nlas principales caracter\u00edsticas del mismo.\n\n### Caracter\u00edsticas b\u00e1sicas\n\n**Numlab** est\u00e1 basado en Python, aunque no implementa todas las\nfuncionalidades del mismo, la sintaxis b\u00e1sica s\u00ed es la misma. Ejemplos:\n\n```python\n# Declaraci\u00f3n de variables\na = 5\npi = 3.14\nname = \"John\"\nval = True \n\n# Funciones built-in\nprint(\"my name is\", name)\n\n# Operaciones aritm\u00e9ticas\nprint(a + pi)\nprint(a - pi)\nprint(a ** 2)\n\n# Control de flujo\nif val:\n    print(\"val is true\")\nelse:\n    print(\"val is false\")\n\nfor i in range(10):\n    if i % 2 == 0:\n         print(i)\n\n\n# Declaraci\u00f3n de funciones\ndef foo(a, b):\n    return a + b\n\nbar = lambda a, b: a + b\n\n# Declaraci\u00f3n de tipos\nclass Foo:\n    def __init__(self, a, b):\n        self.a = a\n        self.b = b\n```\n\n### Estad\u00edsticas en tiempo de ejecuci\u00f3n\n\nEn cada ejecuci\u00f3n existe una variable llamada `stats`, la cual contiene un\ndiccionario con las estad\u00edsticas de la ejecuci\u00f3n. Entre las estad\u00edsticas que se\npueden obtener se encuentran:\n\n - `stats[\"time\"]`: tiempo de ejecuci\u00f3n en segundos.\n - `stats[\"assign_count\"]`: cantidad de asignaciones realizadas.\n - `stats[\"var_count\"]`: cantidad de variables creadas.\n - `stats[\"call_count\"]`: cantidad de llamados a funciones realizados.\n - `stats[\"add_count\"]`: cantidad de veces que se realiz\u00f3 la operaci\u00f3n suma.\n - `stats[\"sub_count\"]`: cantidad de veces que se realiz\u00f3 la operaci\u00f3n resta.\n - `stats[\"mul_count\"]`: cantidad de veces que se realiz\u00f3 la operaci\u00f3n multiplicaci\u00f3n.\n - `stats[\"truediv_count\"]`: cantidad de veces que se realiz\u00f3 la operaci\u00f3n divisi\u00f3n.\n - `stats[\"pow_count\"]`: cantidad de veces que se realiz\u00f3 la operaci\u00f3n potencia.\n - `stats[\"mod_count\"]`: cantidad de veces que se realiz\u00f3 la operaci\u00f3n m\u00f3dulo.\n - `stats[\"floordiv_count\"]`: cantidad de veces que se realiz\u00f3 la operaci\u00f3n divisi\u00f3n entera.\n - `stats[\"lshift_count\"]`: cantidad de veces que se realiz\u00f3 la operaci\u00f3n **left shift**.\n - `stats[\"rshift_count\"]`: cantidad de veces que se realiz\u00f3 la operaci\u00f3n **right shift**.\n - `stats[\"matmul_count\"]`: cantidad de veces que se realiz\u00f3 la operaci\u00f3n multiplicaci\u00f3n de matrices.\n - `stats[\"bit_xor_count\"]`: cantidad de veces que se realiz\u00f3 la operaci\u00f3n **bitwise xor**.\n - `stats[\"bit_and_count\"]`: cantidad de veces que se realiz\u00f3 la operaci\u00f3n **bitwise and**.\n - `stats[\"bit_or_count\"]`: cantidad de veces que se realiz\u00f3 la operaci\u00f3n **bitwise or**.\n - `stats[\"contains_count\"]`: cantidad de veces que se comprob\u00f3 si un elemento est\u00e1 contenido en otro.\n - `stats[\"eq_count\"]`: cantidad de veces que se comprob\u00f3 si dos elementos son iguales.\n - `stats[\"ne_count\"]`: cantidad de veces que se comprob\u00f3 si dos elementos son distintos.\n - `stats[\"lt_count\"]`: cantidad de veces que se comprob\u00f3 si un elemento es menor que otro.\n - `stats[\"gt_count\"]`: cantidad de veces que se comprob\u00f3 si un elemento es mayor que otro.\n - `stats[\"le_count\"]`: cantidad de veces que se comprob\u00f3 si un elemento es menor o igual que otro.\n - `stats[\"ge_count\"]`: cantidad de veces que se comprob\u00f3 si un elemento es mayor o igual que otro.\n - `stats[\"and_count\"]`: cantidad de veces que se realiz\u00f3 la operaci\u00f3n l\u00f3gica **and**.\n - `stats[\"or_count\"]`: cantidad de veces que se realiz\u00f3 la operaci\u00f3n l\u00f3gica **or**.\n\nEjemplo:\n\n```python\nfor i in range(10):\n    a = i * 2\n\nprint(stats[\"mul_count\"])  # Output: 10\n```\n\nEn cualquier momento de la ejecuci\u00f3n, se puede restablecer todas las estad\u00edsticas\na cero usando la palabra clave `resetstats`.\n\nEjemplo:\n```python\nfor i in range(10):\n    a = i * 2\n    if i == 4:\n        resetstats\n\nprint(stats[\"mul_count\"])  # Output: 5\n```\n\n### Simulaci\u00f3n de c\u00f3digo\n\nEn **Numlab** es posble simular regiones de c\u00f3digo bajo diferentes\nrestricciones, como lo son: limitar la cantidad de variables que se pueden\ncrear (`max_var_count`) y limitar el tiempo de ejecuci\u00f3n (`max_time`), limitar\nla cantidad de veces que se realiza una operaci\u00f3n determinada y establecer el\ntiempo que toma en realizarse una operaci\u00f3n.\n\nEl nombre de las restrcciones relacionadas con operadores se nombran:\n`max_<operator>_count` y `<operator>_time` para establecer la catidad m\u00e1xima de\nveces que se puede realizar una operaci\u00f3n y el tiempo que toma en realizarse\nrespectivamente. Por ejemplo, si se desea limitar la cantidad de veces que se\nrealiza la operaci\u00f3n suma: `max_add_count`.\n\n#### Configuraci\u00f3n de la simulaci\u00f3n\n\nPara establecer estas restricciones en **Numlab** las mismas se deben escribir\nen un bloque de configuraci\u00f3n:\n\n```python\nconf general_conf:\n    max_time 0.5\n    max_var_count 10\n    max_add_count 100\n    max_sub_count 100\n    sub_time 0.1\n```\n\nEs posible tambi\u00e9n crear jerarqu\u00edas de restricciones, por ejemplo:\n\n```python\nconf general_conf:\n    max_time 0.5\n    max_var_count 10\n    max_add_count 100\n    max_sub_count 100\n    sub_time 0.1\n\nconf add_config1(general_conf):\n    add_time 0.3\n\nconf add_config2(general_conf):\n    add_time 0.5\n```\n\nEstas configuraciones heredan las restricciones de la configuraci\u00f3n base. De\nesta forma se pueden declarar configuraciones diferentes pero que tengan\nrestricciones en com\u00fan sin necesidad de repetir las mismas. Si se establece una\nrestricci\u00f3n que ya estaba en la configuraci\u00f3n base, se sobreescribe.\n\nLos valores de una configuraci\u00f3n pueden ser resultados de una operaci\u00f3n, por\nejemplo:\n\n```python\na = 2\n\nconf c1:\n    max_time a ** 3 + 8\n```\n\nSi la restricci\u00f3n es sobre el tiempo de ejecuci\u00f3n de un operador, es posible\ntambi\u00e9n especificar en vez de un valor, una funci\u00f3n que devuelva el tiempo de\nejecuci\u00f3n de la operaci\u00f3n. Esta funci\u00f3n se ejecuta cada vez que se realiza la\noperaci\u00f3n determinada y debe devolver el tiempo que debe durar la operaci\u00f3n.\nPor ejemplo:\n\n```python\nconf c1:\n    add_time lambda : rand() * 2 \n```\n\n> `rand` es una funci\u00f3n built-in que devuelve un n\u00famero aleatorio entre 0 y 1\n> con una distribuci\u00f3n uniforme.\n\nEn el ejemplo anterior, cada vez que se simule la operaci\u00f3n suma, la misma\ndemorar\u00e1 un tiempo aleatorio entre 0 y 2.\n\n#### Regiones de c\u00f3digo simuladas\n\nPara establecer una regi\u00f3n de c\u00f3digo donde se simulen las restricciones\nestablescidas en una configuraci\u00f3n, se utilizan las palabras claves `begsim\n<config>` y `endsim`, donde `<config>` es el nombre de la configuraci\u00f3n que se\ndesea usar. Estas palabras indican donde comienza y termina la simulaci\u00f3n\nrespectivamente. Por ejemplo:\n\n```python\nconf c1:\n    max_time 0.5\n\nbegsim c1\na, b = 1, 1\nprint(a)\nprint(b)\nfor _ in range(98):\n    a, b = b, a + b\n    print(b)\nendsim\n```\n\nEs posible utilizar `begsim` y `endsim` m\u00e1s de una vez en una misma ejecuci\u00f3n\n(en tal caso se recomienta usar `resetstats` antes de cada empezar de\nsimulaci\u00f3n). Se pueden relizar simulaci\u00f3nes dentro de simulaciones, en tal caso\nse pasa a utilizar la configuraci\u00f3n de la \u00faltima simulaci\u00f3n. Cada `endsim`\ntermina un nivel de simulaci\u00f3n (la \u00faltima que se haya hecho). Estas palabras\nclaves pueden estar en cualquier parte del c\u00f3digo, la \u00fanica restricci\u00f3n es que\nno se pueden ejecutar m\u00e1s `endsim` que `begsim`.\n\n## Implementaci\u00f3n\n\n**Numlab** es un lenguaje evaluado escrito en Python. A continuaci\u00f3n se\nexponen las caracter\u00edsticas principales de la implementaci\u00f3n de cada estapa.\n\n### Aut\u00f3matas\n\nPara la creaci\u00f3n de las algunas de las proximas funcionalidades, se realiza\u00f3\nuna implementaci\u00f3n de un tipo `Automata` que permite simular una\nm\u00e1quina de estados de forma gen\u00e9rica. A los mismos se le pueden agregar\nestados as\u00ed como transiciones entre los mismos. Cada aut\u00f3mata tiene un estado\ninicial y uno o varios estados finales.\n\nLa ejecuci\u00f3n de una m\u00e1quina de estados realizada con un aut\u00f3mata es bastante\nsimple. Dado una entrada iterable, se comienza en el estado inicial y se va\nejecutando cada transici\u00f3n hasta llegar a un estado final. En caso de llegar a\nun estado en el que ninguna transici\u00f3n es v\u00e1lida, se termina la ejecuci\u00f3n y la\nentrada no es v\u00e1lida. En caso de terminar de recorrer la entrada se clasifica\nla entrada como v\u00e1lida o inv\u00e1lida en dependencia de si se lleg\u00f3 a un estado\nfinal o no respectivamente.\n\nLos aut\u00f3matas pueden tener transiciones **\u00e9psilon** entre estados, en este\ncaso, la ejecuci\u00f3n se bifurca y la maquina de estados se mueve por todos los\nestaos posibles al mismo timepo. Esto da la posibliadad de ejecutar aut\u00f3matas\nno deterministas.\n\nSe implement\u00f3 adem\u00e1s, utilizando el algoritmo visto en clase (calculando los\n**goto** y **epsilon clausuras**) la opci\u00f3n de convertir un aut\u00f3mata no\ndeterminista (NFA) a un aut\u00f3mata determinista (DFA).\n\n### Motor de expresiones regulares\n\nLas principales funcionalidades implementadas son:\n\n- Operador `*`: Matchea cero o m\u00e1s veces la expresi\u00f3n anterior.\n- Operador `|`: Mathcea la expresi\u00f3n anterior o la siguiente.\n- Operador `^`: Matchea cualquier expresion excepto la expresi\u00f3n que le prosigue.\n- Caracter `.`: Matchea cualquier caracter (ASCII).\n- Caracter `\\`: Inicio de un caracter especial.\n- Caracter `\\d`: Matchea un d\u00edgito.\n- Caracter `\\a`: Matchea una letra min\u00fascula.\n- Caracter `\\A`: Matchea una letra may\u00fascula.\n- Parentesis `(` y `)`: Agrupan una expresi\u00f3n regular.\n\n> Cualquier operador o caracter especal puede ser escapado con `\\`.\n\nPara la realizaci\u00f3n del motor de expresiones regulares se utiliz\u00f3 la clase\n`Automata`. Para cada expresi\u00f3n regular se construye un aut\u00f3mata finito no\ndeterminista (NFA) usando el algoritmo de Thompson y luego el mismo se\nconvierte a un DFA utlizando el m\u00e9todo `to_dfa` de la clase `Automata`.\n\nSe ofrecen adem\u00e1s dos funciones para el matcheo de cadenas segun una expresi\u00f3n\nregular: `match` (la cual tiene un comportamiento similar a `re.match`) y\n`compile_patt` (la cual tiene un comportamiento similar a `re.compile`). La\nventaja principal de usar `compile_patt` es que se no es necesario crear un\naut\u00f3mata para cada vez que se desea matchear una cadena (ya que el aut\u00f3mata es\nconstruido una sola vez).\n\n### Tokenizador\n\nPara la implementaci\u00f3n del tokenizador se cre\u00f3 una clase `Tokenizer`. Esta\nclase se encarga de tomar un texto y dividirlo en diferentes tipos de tokens.\nCada patr\u00f3n que se agrega est\u00e1 definido por un nombre (tipo del token) y una\nexpresi\u00f3n regular (se hace uso del motor de expresiones regulares\nimplementado).\n\n```python\ntknz = Tokenizer()\ntknz.add_pattern(\"NUMBER\", r\"\\d\\d*|\\d\\d*\\.\\d\\d*\")\n```\n\nAl tokenizar un texto, se revisan los patrones comenzando por el primero (en el\nmismo orden en el que fueron agregados) y el primero que matchee con un prefijo\nde la cadena se establece como un token nuevo (se toma como lexema la subcadena\nque matche\u00f3 con la expresi\u00f3n regular). Luego se vuelve a realizar esta\noperaci\u00f3n con el resto de la cadena, as\u00ed sucesivamente hasta terminar la misma.\nSi en alg\u00fan punto no se encuentra un token que matchee con el inicio de la\ncadena, se considera que la cadena no se puede tokenizar (con los tipos de\ntokens establecidos).\n\nCada vez que se agrega un patr\u00f3n al tokenizador se puede establecer una\nfunci\u00f3n que se aplicar\u00e1 al lexema antes de guardar su valor en el token.\n\nPor ejemplo, para quitar las comillas al tokenizar un **string**:\n\n```python\ntknz.add_pattern(\"STRING\", r\"'((^')|(\\\\'))*(^\\\\)'\", lambda t: t[1:-1])\n```\n\nEsta funci\u00f3n tambien puede ser utilizada para indicar que se quiere ignorar\nlos tokens de un tipo determinado. En tal caso basta con que la funci\u00f3n devuelva\n`None`:\n\n```python\ntknz.add_pattern(\"SPACE\", r\"( | \\t)( |\\t)*\", lambda t: None)\n```\n\nSe ofrece tambi\u00e9n la opci\u00f3n de agregar `keywords` (palabras claves) para una\nmayor comodidad. Esto se hace mediante el m\u00e9todo `add_keywords()` el cual recibe\nuna lista de palabras. En el proceso de tokenizaci\u00f3n, si el prefijo matcheado\nconicide con alguna de las palabras clave, entonces el tipo del token se\nestablece como `KEYWORD`.\n\nEn caso de que se quiera aplicar una funci\u00f3n para procesar todos los tokens\nobtenidos, se puede usar el decorador `process_tokens` de la clase `Tokenizer`.\nEste debe ser usado en una funci\u00f3n que reciba un solo argumento (la lista de\ntokens) y devuelva una lista de tokens procesados.\n\n```python\n@tknz.process_tokens\ndef process_tokens(tokens):\n    # ...\n    return tokens\n```\n\nFinalmente, para obtener los tokens de un texto basta con usar la funci\u00f3n\n`tokenize`:\n\n```python\ntokens = tknz.tokenize(\"some text\")\n```\n\n### Gram\u00e1ticas\n\nSe implementaron las clases `Grammar`, `NonTerminal`, `Terminal` y `Production`\nlas cuales son usadas para la representaci\u00f3n de una gram\u00e1tica general. Se\nimplement\u00f3 adem\u00e1s un parser de gram\u00e1ticas con el cual es posible crear\ngram\u00e1ticas dado un formato, esto permite definir la gram\u00e1tica del lenguaje en\nun archivo y poder cambiarla f\u00e1cilmente. Dado la sencillez del formato (el\nlenguaje de las gram\u00e1ticas), se implement\u00f3 un sencillo parser recursivo\ndescendente para la creaci\u00f3n de las mismas.\n\nEl formato especificado es el siguiente:\n\n```\nexpression: production_1 | production_2 | ... | production_n\n```\n\nDe forma equivalente, para mayor legibilidad:\n\n```\nexpression:\n    | production_1 \n    | production_2\n    | ...\n    | production_n\n```\n\nEjemplo:\n\n```\nExprAB:\n    | 'a' ExprAB 'b'\n    | EPS\n```\n\n> EPS es un elemento especial en las gram\u00e1ticas para representar *epsilon*\n\nLas gram\u00e1ticas luego pueden ser cargadas como se muestra a continuaci\u00f3n:\n\n```python\nfrom grammar im port Grammar\ngm = Grammar.open(\"expr_ab.gm\")\n```\n\nLas gram\u00e1ticas est\u00e1n compuestas por una lista de expresiones (no terminales).\nCada no terminal de la gram\u00e1tica, contiene una lista de producciones. Cada\nproducci\u00f3n contiene una lista de elementos (terminales o no terminales).\n\n### \u00c1rbol de Sintaxis Abstracta (AST)\n\nPara la creaci\u00f3n de un AST se cre\u00f3 la clase abstracta `AST`. De esta clase\nheredan todos las clases que representan los nodos del \u00e1rbol de sintaxis \nabstracta del lenguaje. En la clase se implementa tambi\u00e9n un m\u00e9todo `dump`\nque permite mostrar el \u00e1rbol de forma legible. Este m\u00e9todo usa el\natributo `__slots__` mediante el cual se definen los atributos que se\nquieren mostrar.\n\nEjemplo del \u00e1rbol generado a partir del c\u00f3digo:\n\n```python\nconf c1:\n    max_time 5\n    max_var_count 5\n\nbegsim c1\ndef foo(a, b):\n    print(\"hola\", a, b)\n\na, b = 1, 2\nfoo(a, b)\nendsim\n```\n\n\u00c1rbol generado:\n```text\nProgram:\n   stmts: [\n      ConfDefStmt:\n         name: c1\n         configs: [\n            ConfOption:\n               name: max_time\n               value: ConstantExpr(0.5)\n         ]\n      Begsim:\n         config: NameExpr('c1', ctx=ExprCtx.LOAD)\n      ForStmt:\n         target: NameExpr('i', ctx=ExprCtx.LOAD)\n         iter_expr: (TupleExpr)\n            elts: [\n               CallExpr:\n                  func: NameExpr('range', ctx=ExprCtx.LOAD)\n                  args: [\n                     ConstantExpr(100)\n                  ]\n            ]\n            ctx: ExprCtx.LOAD\n         body: [\n            TupleExpr:\n               elts: [\n                  CallExpr:\n                     func: NameExpr('print', ctx=ExprCtx.LOAD)\n                     args: [\n                        BinOpExpr:\n                           left: NameExpr('i', ctx=ExprCtx.LOAD)\n                           op: Operator.POW\n                           right: ConstantExpr(2)\n                     ]\n               ]\n               ctx: ExprCtx.LOAD\n         ]\n      Endsim:\n   ]\n```\n\nPara definir c\u00f3mo se construye cada nodo del AST se pueden asignar los\nconstructores a cada producci\u00f3n de la gram\u00e1tica usando la funci\u00f3n\n`assign_builders`. Esta funci\u00f3n recibe un diccionario donde las llaves son la\nrepresentaci\u00f3n textual de la producci\u00f3n y los valores son funciones que reciben\ncomo argumentos los elementos de la producci\u00f3n. En caso de que el s\u00edmbolo sea\nun terminal la funci\u00f3n recibir\u00e1 dicho terminal, en caso de ser un no terminal,\nla funci\u00f3n recibir\u00e1 el resultado de la ejecuci\u00f3n algunas de las funciones\nconstructoras de las producciones que tengan como cabeza a dicho no terminal.\n\nPor ejemplo, a continuaci\u00f3n se muestran algunos de los constructores para\nla gram\u00e1tica de **Numlab**:\n\n```python\nbuilders = {\n    # -------------------------------------------------------------------------\n    \"program -> stmt program\": lambda s, p: ast.Program([s] + p.stmts),\n    \"program -> NEWLINE program\": lambda n, p: p,\n    \"program -> EPS\": lambda: ast.Program([]),\n    # -------------------------------------------------------------------------\n    \"stmt -> simple_stmt\": lambda s: s,\n    \"stmt -> compound_stmt\": lambda c: c,\n    # -------------------------------------------------------------------------\n    \"stmt_list -> stmt\": lambda s: [s],\n    \"stmt_list -> stmt stmt_list\": lambda s, sl: [s] + sl,\n    # -------------------------------------------------------------------------\n    # ...\n    # ...\n```\n\n### Parser\n\nPara la implementaci\u00f3n del parser principal del lenguaje se cre\u00f3 la clase\nabstacta `Parser`. Usando esta clase como base se cre\u00f3 una clase `LR1Parser`,\nla cual implementa un parser LR(1).\n\nPara la realizaci\u00f3n del parser LR(1) fue necesario implementar las clases\n`LR1Item` y `LR1Table`. La primera de estas clases representa un item del\nparser, el cual contiene: la producci\u00f3n que lo genera, la posici\u00f3n del punto\n(dot) en la producci\u00f3n y el terminal que le debe proseguir (lookahead).\n\nLa segunda clase (`LR1Table`) representa la tabla de transici\u00f3n del parser.\nCada posici\u00f3n de la tabla puede contener tres tipos de elementos: un **string**\n`\"OK\"`, que indica que el estado de aceptaci\u00f3n; un val\u00f3r num\u00e9rico entero, que\nindica cual es el siguiente estado; o un no terminal de la gram\u00e1tica, el cual\nrepresenta que hay que realizar una reducci\u00f3n. Para no tener que recalcular la\ntabla cada vez que se va a parsear un texto, la misma puede ser serializada y\nluego cargada.\n\nLa construcci\u00f3n de la tabla se realiz\u00f3 siguiendo el algoritmo visto en las\nconferencias de la asignatura (calculando los **goto** y las **clausuras** de\nlos estados).\n\nEn el proceso de parsing, al realizar una acci\u00f3n de reducci\u00f3n, es donde se\nutilizan las funciones constructoras vistas en la secci\u00f3n anterior. En\ndependencia de la producci\u00f3n que se est\u00e1 reduciendo, se llama a la funci\u00f3n\nconstructora correspondiente.\n\nPara una mayor comodidad se implement\u00f3 tambi\u00e9n la clase `ParserManager`. Esta\nclase ofrece, dado una gram\u00e1tica, un tokenizador (opcional) y un parser\n(opcional, por defecto LR(1)), m\u00e9todos como: `parse_file` (para parsear un\narchivo), `parse` (para parsear un texto) y `parse_tokens` (para parsear una\nlista de tokens directamete). Estas funciones devuelven el AST resultante del\nproceso de parsing.\n\n### Visitors\n\nUna vez obtenido el AST de un programa es necesario realizar recorridos sobre\n\u00e9l. Para ello se implment\u00f3 una clase `Visitor` la cual contiene dos decoradores\n`@visitor` y `@callback`. Por cada **visitor** que se quiera implementar para\nel AST, se debe implementar una nueva clase que tenga como atributo de clase\nuna instancia de la clase `Visitor`. Luego, cada m\u00e9todo de la clase que tenga\nel decorador `@visitor`, se establecer\u00e1 como una sobrecarga. Es por ello que\ntodos estos m\u00e9todos deben tener sus argumentos tipados (esta es la forma en la\nque el **visitor** sabe cual de los m\u00e9todos de la clase debe llamar).\n\nPor ejemplo:\n\n```python\nfrom numlab.lang.visitor import Visitor\n\nclass EvalVisitor:\n    visitor_dec = Visitor().visitor\n\n    @visitor_dec\n    def eval(self, node: ast.Program):\n        for stmt in node.stmts:\n            stmt.eval(self)\n\n    @visitor_dec\n    def eval(self, node: ast.Stmt): ...\n\n    # ...\n```\n\nEl decorador `@callback` se utiliza para definir funciones que se van a llamar\ncada vez que se llame a una funci\u00f3n marcada como **visitor**. En el proyecto\nuno de los usos que se le da a este decorador es para comprobar que el tiempo de\nejecuci\u00f3n de una simulaci\u00f3n es menor que el l\u00edmite establecido en cada momento.\n\n### Ejecuci\u00f3n\n\nPara la ejecuci\u00f3n de un programa representado en un AST se implement\u00f3 un\nvisitor `EvalVisitor` (muy similar al ejemplo de la secci\u00f3n anterior). A\ncontinuaci\u00f3n se muestran algunas de las caracter\u00edsticas m\u00e1s importantes\nimplementadas en el proceso de evaluaci\u00f3n.\n\n\n#### Tipos y funciones predefinidas\n\nPara representar los tipos predefinidos de **Numlab** se cre\u00f3 la clase `Type`.\nCada instancia de esta clase representa un tipo de **Numlab**, entre ellos:\n`int`, `str`, `list`, etc (los tipos b\u00e1sicos existentes en python).\n\nA cada tipo de le pude agregar atributos (las funciones tambi\u00e9n se agregan como\natributo). Adem\u00e1s, cada tipo puede derivar de otro (permitiendo la herencia), por\nconsiguiente, en la resoluci\u00f3n de un atributo si el mismo no est\u00e1 definido en el\ntipo actual, se busca en el tipo padre (y as\u00ed susesivamente).\n\nSe implementaron tamb\u00eden varias de las funciones built-in de python en **Numlab**.\nEn la ejecuci\u00f3n del c\u00f3digo se puede acceder a estas funciones directamente.\n\n#### Contextos\n\nPara definir el contexto donde se encuentra cada variable, tipo o funci\u00f3n que se\ncrea, se implement\u00f3 la clase `Context`. Un **context** tiene un diccionario\ncon el nombre de cada objeto creado en el mismo y su respectivo valor. Cada contexto\ntiene adem\u00e1s una referencia al contexto padre (en caso de que exista). Esto\npermite que al realizar la resoluci\u00f3n de una variable, si la misma no se ecuentra\nen el contexto actual, se busque en el contexto padre.\n\n> En el EvalVisitor al realizar la resoluci\u00f3n de una variable, se busca primero\n> en el context actual, y si no se encuentra, se busca entre las funciones y\n> tipos predefinidos.\n\nEl contexto tambi\u00e9n es utilizado tambi\u00e9n en las secciones de c\u00f3digo simuladas\npara comprobar la cantidad de variables creadas (en caso de existir alguna\nrestricci\u00f3n sobre este valor).\n\n#### Evaluaci\u00f3n\n\nComo se hab\u00eda mencionado anteriormente, la evaluaci\u00f3n de un programa se realiza\nmediante un **visitor**. En este **visitor** se implementaron las funciones\nque definen c\u00f3mo se eval\u00faa cada uno de los nodos del AST.\n\nEn ocasiones, existen nodos que afectan la evaluaci\u00f3n de otros, como por\nejemplo las palabras claves de control de flujo (`break`, `continue`, `return`,\netc). Para ello, el `EvalVisitor` cuenta con un diccionario `flags` (atributo\nde instancia) que contiene diversa informaci\u00f3n que se puede utlizar en com\u00fan\nentre la evaluaci\u00f3n de los nodos.\n\nEn estas evaluaciones es tambi\u00e9n donde se van guardando las estad\u00edsiticas de la\nejecuci\u00f3n del programa (en un diccionario `stats` el cual tiene accesibilidad\nincluso desde el c\u00f3digo que se est\u00e1 ejecutando). Por ejemplo, al realizar un\nllamado a una funci\u00f3n, se incrementa el contador de llamados:\n\n```python\nclass EvalVisitor:\n    \n    # ... Other eval methods\n\n    @visitor\n    def eval(self, node: ast.CallExpr):\n        self.set_stat(\"call_count\", self.stats[\"call_count\"] + 1)\n        # Call eval implementation ...\n\n    # ... Other eval methods\n```\n\n## Optimizaci\u00f3n de c\u00f3digo\n\nSe implement\u00f3 tambi\u00e9n un optimizador de c\u00f3digo, el cual, mediante un algor\u00edtmo\ngen\u00e9tico, cambia la estructura de un AST para reducir el tiempo de ejecuci\u00f3n.\nPara ello se cre\u00f3 otro **visitor**, el cual se puede clasificar como un sistema\nexperto. Este **visitor**, busca en un programa determinado en qu\u00e9 nodos se\npueden realizar, bajo ciertas reglas, cambios que puedan reducir el tiempo de\nejecuci\u00f3n.\n\nEntre estas reglas se pueden mencionar por ejemplo, cambiar el orden de las\ncomprobaci\u00f3nes en una condicional (o ciclo while) para que se eval\u00faen primero\nlas condiciones que son m\u00e1s sencillas, o incluso, sustituir operaciones de\nmultiplicaci\u00f3n por operaciones **shift** si es posible, etc.\n\nUna vez se recorre el AST en busca de cambios, se crea un vector el cual\ncontiene en cada posici\u00f3n la informaci\u00f3n de d\u00f3nde se puede realizar un cambio\n(el nodo) y dos funciones: una que realiza el cambio y otra que devuelve el\nnodo a su estado original.\n\nEsta informaci\u00f3n se lleva a la ejecuci\u00f3n de un algor\u00edtmo gen\u00e9tico. La poblaci\u00f3n\nde este algoritmo consiste en vectores booleanos que indican si se debe realizar\nun cambio en un nodo o no. Al evaluar un AST se realizan los cambios necesarios\ny se obtiene el tiempo de ejecuci\u00f3n (en caso de existir un error el tiempo de\nejecuci\u00f3n ser\u00e1 infinito).\n\nLa poblaci\u00f3n inicial se genera aleatoriamente. El entrecruzamiento entre dos\nvectores se realiza dividi\u00e9ndolos en dos partes, he intercambiando las mismas.\nEsta forma de entrecruzamiento es posible ya que cada cambio es independiente.\nLa mutaci\u00f3n consiste en cambiar aleatoriamente alg\u00fan valor del vector.\n\nAl ejecutar la optimizaci\u00f3n se obtiene el AST resultante de realizar los cambios\ndefinidos por el mejor vector de la poblaci\u00f3n (luego de algunas generaciones).\n\nLos par\u00e1metros usados en el algoritmo gen\u00e9tico pueden ser modificados\ndirectamente desde el commando `optimize` del\n[CLI](https://github.com/jmorgadov/NumLab#aplicaci%C3%B3n-cli) o mediante un\narchivo de configuraci\u00f3n `.json`. Estos par\u00e1metros son:\n\n- `pop_size`: Tama\u00f1o de la polbaci\u00f3n.\n- `max_iter`: N\u00famero m\u00e1ximo de generaciones.\n- `mutation_prob`: Probabilidad de mutaci\u00f3n.\n- `best_sel_count`: N\u00famero de mejores individuos que se seleccionan para el siguiente ciclo.\n- `new_random_count`: N\u00famero de nuevos individuos que se generan aleatoriamente para el siguiente ciclo.\n\n### Sistema difuso para la estimaci\u00f3n de la calidad de la optimizaci\u00f3n\n\nDado que optimizar un c\u00f3digo conlleva la evaluaci\u00f3n del mismo varias veces, se\nimplement\u00f3 un sistema difuso para estimar que tan buena puede ser la calidad de\nla optimizaci\u00f3n antes de realizarla. A cada cambio posible se le asigna una\npuntuaci\u00f3n de calidad (entre 0 y 1) y finalmente se devuelve la mejor\npuntuaci\u00f3n obtenida.\n\nCada cambio tiene dos valores asociados:\n\n- Valor principal: Puntuaci\u00f3n que se asigna al cambio.\n- Profundidad en loops: N\u00famero de loops en los que se encuentra el cambio.\n\nEl valor principal var\u00eda en dependencia del cambio en s\u00ed. Por ejemplo, un\ncambio de una multiplicaci\u00f3n que puede convertirse en un **shift** no tiene\nun valor tan alto como cambiar el orden de las condiciones en un `if`. As\u00ed como\ncambiar el orden de las condiciones en un `while` tiene m\u00e1s valor que cambiarlas\nen un `if`.\n\nLa calidad de cada cambio es estimada por el sistema difuso siguiendo 3 reglas\nprincipales:\n\n- El cambio tiene baja puntuaci\u00f3n o bajo nivel de profundidad en ciclos (cambio pobre).\n- El cambio tiene puntuaci\u00f3n media o un nivel medio en profundidad en ciclos (cambio aceptable).\n- El cambio tiene alta puntuaci\u00f3n o alto nivel de profundidad en ciclos (buen cambio).\n\nPara ello, se implement\u00f3 una clase `FuzzyRule` que representa una regla del\nsistema difuso. En cada regla se guardan las funciones que se deben comprobar\npara cada valor (en nuestro caso funciones de tipo campana de Gauss variando su media y\nvariaza), as\u00ed como la funci\u00f3n que se debe aplicar a los valores resultantes\n(en nuestro caso la funci\u00f3n `max`, ya que todas las reglas utilizan solo el\noperador `OR`).\n\nToda la implementaci\u00f3n del sistema se realiz\u00f3 en la clase `FuzzyOptClassifier`.\nEn la obtenci\u00f3n de los consecuentes de las reglas se utiliza el m\u00e9todo de\nMamdani (truncar). En el caso de la desfusificaci\u00f3n de los cambios se utiliza\nel m\u00e9todo de media de los valores m\u00e1ximos.\n\n### Ejemplo de optimizaci\u00f3n\n\nA continuaci\u00f3n se muestra un ejemplo de c\u00f3digo y su optimizaci\u00f3n:\n\n```python\nitems = [1, 1, 1, 1, 1]\n\ndef foo():\n    a = [i for i in range(100)]\n    return items\n\nfor i in range(50):\n    if i in [j for j in range(48, 500)] or i < 40: \n        a = i + 3\n\n    if foo() and items[0] == 1:\n        items.remove(1)\n\nprint(stats[\"time\"])\n```\n\nEn este c\u00f3digo se puede ver que el primer `if` realiza dos comprobaciones. La\nprimera de ellas genera una lista de al rededor de 450 elementos cada vez que\nse ejecuta el `if`, mientras que la segunda solamente compara dos valores.\n\nSe puede observar adem\u00e1s que existe otra comprobaci\u00f3n, donde tambi\u00e9n se\nrealizan dos operaciones y la primera de ellas es m\u00e1s costosa temporalmente que\nla segunda. Sin embargo en este caso la segunda operaci\u00f3n es dependiente de la\nprimera, por lo que no se puede realizar antes. Esto no se comprueba en ning\u00fan\nmomento al extraer los cambios posibles debido a la complegidad que puede\npresentar comprobar este tipo relaciones entre los nodos. M\u00e1s adelante el\nalgoritmo gen\u00e9tico es quien decidir\u00e1 si es correcto realizar el cambio o no.\n\nAl ejecutar este c\u00f3digo se obtuvo un tiempo de ejecuci\u00f3n promedio de 1.8\nsegundos. Al optimizar el AST, se detectaron dos cambios potenciales (el orden\nde comprobaci\u00f3n en las expresiones condicionales mencionadas anteriormente). El\nvalor de la calidad de la optimizaci\u00f3n estimado fue aproximadamente 0.6. El\nalgoritmo gen\u00e9tico obtuvo como mejor resultado realizar el primer cambio y no\nel segundo. Finalmente, el c\u00f3digo optimizado tuvo un tiempo de ejecuci\u00f3n de\naproximadamente 0.6 segundos.\n\n```text\n$ numlab optmize \"numlab_test.nl\"\n\n .===============================================.\n |                 Configuration                 |\n |===============================================|\n | Parameter                               Value |\n |-----------------------------------------------|\n | Population size                            10 |\n | Maximum number of iterations                5 |\n | Mutation probability                      0.1 |\n | Number of best individuals to select        3 |\n | Number of new random individuals            2 |\n '==============================================='\n\n\nEstimated optimization quality: 0.6034089537672265\n\nDo you want to proceed with the optimization? [Y/n]: \nOutput (before optimizing):\n1.8277204990386963\n\nOptimizing program\nGenerating population of 10\nEvaluating population\nIteration 1 of 5\nBest solution: ([1, 0], 0.7729673385620117)\nIteration 2 of 5\nBest solution: ([1, 0], 0.7729673385620117)\nIteration 3 of 5\nBest solution: ([1, 0], 0.6900575160980225)\nIteration 4 of 5\nBest solution: ([1, 0], 0.6900575160980225)\nIteration 5 of 5\nBest solution: ([1, 0], 0.6900575160980225)\n\nOutput (after optimizing):\n0.6344912147521973\n```\n\n## Extras\n\n### Aplicaci\u00f3n CLI\n\nAl instalar **Numlab** es posible usar una interfaz de comando mediente la\nterminal. La misma cuenta con dos comandos principales: `run` y `optimize`, \nlas cuales ejecutan u optimizan un programa respectivamente.\n\n```text\n$ numlab --help\nUsage: numlab [OPTIONS] COMMAND [ARGS]...\n\nOptions:\n  --help  Show this message and exit.\n\nCommands:\n  optimize  Optimize a program given in the input file\n  run       Run the program given in the input file\n  version   Print the version number\n```\n\nEjemplo:\n\n```bash\nnumlab \"my_script.nl\" --verbose\n```\n\nPara m\u00e1s informaci\u00f3n sobre los comandos:\n\n```bash\nnumlab run --help\nnumlab optimize --help\n```\n\n### Extensi\u00f3n de VSCode\n\nUna [extensi\u00f3n](https://marketplace.visualstudio.com/items?itemName=JessicaNunez.numlab)\nde VSCode fue desarrollada tambi\u00e9n para el uso del lenguaje.\nLa misma aporta ***highlighting*** de las palabras claves del lenguaje\npara los archivos `.nl`.\n",
            "description_content_type": "text/markdown",
            "docs_url": null,
            "download_url": "",
            "downloads": {
                "last_day": -1,
                "last_month": -1,
                "last_week": -1
            },
            "home_page": "",
            "keywords": "",
            "license": "MIT",
            "maintainer": "",
            "maintainer_email": "",
            "name": "numlab",
            "package_url": "https://pypi.org/project/numlab/",
            "platform": "",
            "project_url": "https://pypi.org/project/numlab/",
            "project_urls": null,
            "release_url": "https://pypi.org/project/numlab/0.2.2/",
            "requires_dist": [
                "typer (>=0.4.0,<0.5.0)"
            ],
            "requires_python": ">=3.8,<4.0",
            "summary": "Programming language for analyzing mathematical numerical problem's solutions",
            "version": "0.2.2",
            "yanked": false,
            "yanked_reason": null
        },
        "last_serial": 12947631,
        "urls": [
            {
                "comment_text": "",
                "digests": {
                    "md5": "770c6495b99d8f486e6109fb15e385f9",
                    "sha256": "4dc8ef83abd4430cb582b305cc521ce49d41545aab25db46b75ae85ee790ff9f"
                },
                "downloads": -1,
                "filename": "numlab-0.2.2-py3-none-any.whl",
                "has_sig": false,
                "md5_digest": "770c6495b99d8f486e6109fb15e385f9",
                "packagetype": "bdist_wheel",
                "python_version": "py3",
                "requires_python": ">=3.8,<4.0",
                "size": 283270,
                "upload_time": "2022-02-20T00:37:14",
                "upload_time_iso_8601": "2022-02-20T00:37:14.867041Z",
                "url": "https://files.pythonhosted.org/packages/0b/d5/a18b6985940a23b6408c2b218a72b08ca21fb3f1eb0ef396f72864f8711a/numlab-0.2.2-py3-none-any.whl",
                "yanked": false,
                "yanked_reason": null
            },
            {
                "comment_text": "",
                "digests": {
                    "md5": "d9d21af51fe327a21c0f2110e46d197d",
                    "sha256": "d40dbea3dcfe886073cdc1a9951d1615f2f95a624fd155f813286564366992e8"
                },
                "downloads": -1,
                "filename": "numlab-0.2.2.tar.gz",
                "has_sig": false,
                "md5_digest": "d9d21af51fe327a21c0f2110e46d197d",
                "packagetype": "sdist",
                "python_version": "source",
                "requires_python": ">=3.8,<4.0",
                "size": 281724,
                "upload_time": "2022-02-20T00:37:16",
                "upload_time_iso_8601": "2022-02-20T00:37:16.151698Z",
                "url": "https://files.pythonhosted.org/packages/b1/23/9feffb5e50089b2e5b2527e340a11d4ea6c8bb944426a4814135f8b7643e/numlab-0.2.2.tar.gz",
                "yanked": false,
                "yanked_reason": null
            }
        ],
        "vulnerabilities": []
    }
}