{
    "1.0": {
        "info": {
            "author": "A K M Aminul Islam",
            "author_email": "aminul71bd@gmail.com",
            "bugtrack_url": null,
            "classifiers": [],
            "description_content_type": "",
            "docs_url": null,
            "download_url": "",
            "downloads": {
                "last_day": -1,
                "last_month": -1,
                "last_week": -1
            },
            "home_page": "",
            "keywords": "",
            "license": "NEWTONIA FREEWARE LICENSE",
            "maintainer": "",
            "maintainer_email": "",
            "name": "upmath",
            "package_url": "https://pypi.org/project/upmath/",
            "platform": "",
            "project_url": "https://pypi.org/project/upmath/",
            "project_urls": null,
            "release_url": "https://pypi.org/project/upmath/1.0/",
            "requires_dist": null,
            "requires_python": "",
            "summary": "This package provides universal precision number and standard math funcstions that support mathematical operations on the universal precision number.",
            "version": "1.0",
            "yanked": false,
            "yanked_reason": null
        },
        "last_serial": 7704331,
        "urls": [
            {
                "comment_text": "",
                "digests": {
                    "md5": "30d28ba510c80c319298652b4e11b6e9",
                    "sha256": "486bd659aee68aaca7d773712769f8c46254daa20b0e7abd80ed958023016c6a"
                },
                "downloads": -1,
                "filename": "upmath-1.0-py2.py3-none-any.whl",
                "has_sig": false,
                "md5_digest": "30d28ba510c80c319298652b4e11b6e9",
                "packagetype": "bdist_wheel",
                "python_version": "py2.py3",
                "requires_python": null,
                "size": 3421,
                "upload_time": "2020-07-15T08:44:11",
                "upload_time_iso_8601": "2020-07-15T08:44:11.907541Z",
                "url": "https://files.pythonhosted.org/packages/1a/2e/65393800f66285f8f220921475197c675c1be2ce6b5095db2049b1b8e6b2/upmath-1.0-py2.py3-none-any.whl",
                "yanked": false,
                "yanked_reason": null
            }
        ],
        "vulnerabilities": []
    },
    "1.2": {
        "info": {
            "author": "A K M Aminul Islam",
            "author_email": "aminul71bd@gmail.com",
            "bugtrack_url": null,
            "classifiers": [],
            "description_content_type": "text/markdown",
            "docs_url": null,
            "download_url": "",
            "downloads": {
                "last_day": -1,
                "last_month": -1,
                "last_week": -1
            },
            "home_page": "",
            "keywords": "",
            "license": "NEWTONIA FREEWARE LICENSE",
            "maintainer": "",
            "maintainer_email": "",
            "name": "upmath",
            "package_url": "https://pypi.org/project/upmath/",
            "platform": "",
            "project_url": "https://pypi.org/project/upmath/",
            "project_urls": null,
            "release_url": "https://pypi.org/project/upmath/1.2/",
            "requires_dist": null,
            "requires_python": "",
            "summary": "This package provides universal precision number and standard math functions that support mathematical operations on the universal precision number.",
            "version": "1.2",
            "yanked": false,
            "yanked_reason": null
        },
        "last_serial": 7704331,
        "urls": [
            {
                "comment_text": "",
                "digests": {
                    "md5": "b4ebe34a5d677f66782ef512012bec52",
                    "sha256": "a0b04a99515476e1820f2452f11c2ca920a0acbf063599e8eb2b81c9af7318f2"
                },
                "downloads": -1,
                "filename": "upmath-1.2-py2.py3-none-any.whl",
                "has_sig": false,
                "md5_digest": "b4ebe34a5d677f66782ef512012bec52",
                "packagetype": "bdist_wheel",
                "python_version": "py2.py3",
                "requires_python": null,
                "size": 59488,
                "upload_time": "2020-07-15T09:57:58",
                "upload_time_iso_8601": "2020-07-15T09:57:58.630779Z",
                "url": "https://files.pythonhosted.org/packages/7f/25/259d4dfb586ebd8c195a5821e78d461b38058c2c5d5fcfb75b5c1b575432/upmath-1.2-py2.py3-none-any.whl",
                "yanked": false,
                "yanked_reason": null
            },
            {
                "comment_text": "",
                "digests": {
                    "md5": "83c96ee27cfae7d157e246c0ab1ca675",
                    "sha256": "22baa094e6eee2cab1e3b4e05256078e04f2c53dbc93c0fd76bd99154a4a17ad"
                },
                "downloads": -1,
                "filename": "upmath-1.2.tar.gz",
                "has_sig": false,
                "md5_digest": "83c96ee27cfae7d157e246c0ab1ca675",
                "packagetype": "sdist",
                "python_version": "source",
                "requires_python": null,
                "size": 63380,
                "upload_time": "2020-07-15T09:58:01",
                "upload_time_iso_8601": "2020-07-15T09:58:01.295559Z",
                "url": "https://files.pythonhosted.org/packages/8c/87/bd6b1f3b0f08a7770a8fd2eb24e5f1f550454a8d52e79bd856037f22d862/upmath-1.2.tar.gz",
                "yanked": false,
                "yanked_reason": null
            }
        ],
        "vulnerabilities": []
    },
    "1.3": {
        "info": {
            "author": "A K M Aminul Islam",
            "author_email": "aminul71bd@gmail.com",
            "bugtrack_url": null,
            "classifiers": [],
            "description": "## upmath-1.3 (universal precision mathematics)\n\n**Description:** This python package contains a number class that supports \nhigh precision calculation and various number-bases like **2**, **8**, **10**, **16**, \n**32** and **64**. Numbers are correct to the precision (significant digits) set \nby the user. Numbers of different bases are equivalent and interconvertible. \nConverting a number to a higher base saves memory space and load on network traffic \nwhen it is sent from one machine to another over the computer network.\n\nBoth the integers and floating point numbers are supported by all the numbers of \nmentioned bases. Since it supports binary, octal, denary, hexadecimal, base-32 and\nbase-64 numbers equivalently, that's why, they are called *'universal'*. \n\nAll the standard mathematical functions are rewritten to support the high precision\nfeature. Mathematical operators are also redefined so. That's why, this package is \ncalled universal precision mathematics (upmath).\n\n### Examples\nUniversal precision numbers (upn) are accurate to the given precision. Default\nprecision is 36.\n```python\n>>> \n>>> import upmath\n>>> import upmath.pE as pe\n>>> upmath.e\nb10:2.7182818284590452353602874713526625\n>>> pe.getE(prec=200)\nb10:2.7182818284590452353602874713526624977572470936999595749669676277240766303535475\n9457138217852516642742746639193200305992181741359662904357290033429526059563073813232\n8627943490763233829880753195251019\n>>> \n>>> \n>>> upmath.PI\nb10:3.14159265358979323846264338327950288\n>>> import upmath.pi as pi\n>>> pi.getPI(prec=200)\nb10:3.1415926535897932384626433832795028841971693993751058209749445923078164062862089\n9862803482534211706798214808651328230664709384460955058223172535940812848111745028410\n2701938521105559644622948954930382\n>>> \n```\nMathematical operations are able to create the numbers correct to the given precision.\n```python\n>>> a=upn.Number('998001',prec=500)\n>>> a.inv()\nb10:0.00000100200300400500600700800901001101201301401501601701801902002102202302402502\n60270280290300310320330340350360370380390400410420430440450460470480490500510520530540\n55056057058059060061062063064065066067068069070071072073074075076077078079080081082083\n08408508608708808909009109209309409509609709809910010110210310410510610710810911011111\n21131141151161171181191201211221231241251261271281291301311321331341351361371381391401\n4114214314414514614714814915015115215315415515615715815916016116216316416516616716\n>>> \n```\nAll numbers are returned and manipulated in **string** format. It can handle integer \nand floating point numbers of any base from 2,8,10,16,32,64. This package can process\nany number from ultra small to ultra large level.\n```python\n>>> \n>>> import upmath.Number as upn\n>>> a=upn.Number('-1.6e-2020')\n>>> b=upn.Number('4.85e+2020')\n>>> a\nb10:-1.6e-2020\n>>> b\nb10:4.85e+2020\n>>> \n>>> a+1\nb10:0.99999999999999999999999999999999999999999999999999999999999999999999999999999999\n99999999999999999999999999999999999999999999999999999999999999999999999999999999999999\n99999999999999999999999999999999999999999999999999999999999999999999999999999999999999\n99999999999999999999999999999999999999999999999999999999999999999999999999999999999999\n99999999999999999999999999999999999999999999999999999999999999999999999999999999999999\n99999999999999999999999999999999999999999999999999999999999999999999999999999999999999\n99999999999999999999999999999999999999999999999999999999999999999999999999999999999999\n99999999999999999999999999999999999999999999999999999999999999999999999999999999999999\n99999999999999999999999999999999999999999999999999999999999999999999999999999999999999\n99999999999999999999999999999999999999999999999999999999999999999999999999999999999999\n99999999999999999999999999999999999999999999999999999999999999999999999999999999999999\n99999999999999999999999999999999999999999999999999999999999999999999999999999999999999\n99999999999999999999999999999999999999999999999999999999999999999999999999999999999999\n99999999999999999999999999999999999999999999999999999999999999999999999999999999999999\n99999999999999999999999999999999999999999999999999999999999999999999999999999999999999\n99999999999999999999999999999999999999999999999999999999999999999999999999999999999999\n99999999999999999999999999999999999999999999999999999999999999999999999999999999999999\n99999999999999999999999999999999999999999999999999999999999999999999999999999999999999\n99999999999999999999999999999999999999999999999999999999999999999999999999999999999999\n99999999999999999999999999999999999999999999999999999999999999999999999999999999999999\n99999999999999999999999999999999999999999999999999999999999999999999999999999999999999\n99999999999999999999999999999999999999999999999999999999999999999999999999999999999999\n99999999999999999999999999999999999999999999999999999999999999999999999999999999999999\n9999999999999999999999999999999999999999999999984\n>>> \n```\n\nThe central number system is binary and denary. Numbers of bases 8,16,32 and 64 are \nconverted efficiently through binary. Arithmetic and other mathematical operations \nare performed by denary (base10) operations.\n```python\n>>> \n>>> a=upn.Number('hello.world',64)\n>>> a.getDenaryForm()\n'b10:288970072.505963635630905628204345703125'\n>>> a.getBinaryForm()\n'b02:10001001110010101010101011000.100000011000011011010101001101'\n>>> a.getOctalForm()\n'b08:2116252530.4030332515'\n>>> a.getHexadecimalForm()\n'b16:11395558.8186d534'\n>>> a.getBase32Form()\n'b32:8jilao.g63dad'\n>>> \n```\n\nNumber data are stored in a dictionary data format. For example,\n```python\n>>> a=upn.Number('15.27')\n>>> a.getDict()\n{'base': 10, 'input_mode': 'fp', 'sign': '+', 'ipart': '15', 'fpart': '27', 'exp': 0,\n 'prec': 4, 'max_prec': 18, 'is_accurate': True, 'normalized': {'sign': '+',\n 'ipart': '15', 'fpart': '27', 'is_accurate': True}, 'is_integer': False,\n 'is_float': True, 'normal_prec': 4}\n>>> \n```\n\n| Base | Number System | Example | Digits |\n| --- | --- | --- | --- |\n| Base=2 | Binary | b02:-11001.011p600 | 0,1 |\n| Base=8 | Octal | b08:-4572.0273p-600 | 0-7 |\n| Base=10 | Denary | b10:-9078.0412p40 | 0-9 |\n| Base=16 | Hexadecimal | b16:-f04d.32abp70 | 0-9a-fA-F |\n| Base=32 | DuoTrigesimal | b32:-vV0o.25f9p+147 | 0-9a-vA-V |\n| Base=64 | Base-64 | b64:-zXo0.a4Btp-250 | 0-9a-zA-Z!@ |\n\n\nNumber input modes:'fp' and 'fr'\n    fp' (floating point) mode means numbers with floating digits.\n        Like:b02:-11110001.11p-10,b10:92.45e33\n    'fr' (fractional) mode which displays number as mixed or proper fraction.\n        Like:b02:-11110001 11/100p+17, b10:92 9/20e+23.\n    Difference: 'fp' numbers contain '.', but 'fr' numbers have '/'.\n\nValid Input Format:\n(fp)11110.101,'11110.101p+34','11110.101p34','11110.101p-23','-0.1101p-45'\n(fr) '-1101 11/1101', \"-1101 11/1101p+7\", \"-1101 11/1101p7\", '-1101 11/1101p-17'\n\nDefault base is 10. If base is not given in the number definition, it is automatically \nassumed 10.\n```python\n>>> \n>>> a=upn.Number('24 5/7p-5')\n>>> a\nb10:24 5/7e-5\n>>> a+1\nb10:1.0002471428571428571428571\n>>> a*1\nb10:0.0002471428571428571428571\n>>> \n```\n\nIf a floating or fractional number is recurring, 'upn' can handle it\nvery efficiently just by setting modify or ultraModify argument 'True'. modify() \nmethod and ultraModify() method also do the same job. These methods or arguments can \nalso convert the improper fractions to proper fraction with necessary simplifications.\n```python\n>>> \n>>> a=upn.Number('245.20451045104510451',modify=True)\n>>> a\nb10:245 1859/9090\n>>> \n>>> a=upn.Number('245.20451045104510451')\n>>> a\nb10:245.20451045104510451\n>>> a.modify()\n>>> a\nb10:245 1859/9090\n>>> \n>>> b=upn.Number('245/37',modify=True)\n>>> b\nb10:6 23/37\n>>> c=upn.Number('-30 245/35',modify=True)\n>>> c\nb10:-37\n>>> d=upn.Number('-30 245/45',modify=True)\n>>> d\nb10:-35 4/9\n>>> \n```\n### Arithmetic operations\nAddition(+), subtraction(-), multiplication(*), division(/), floor division(//), \nremainder or mod operation(%), power operation(**) etc. can be done very easily.\n```python\n>>> \n>>> a=upn.Number('12.45')     #denary number\n>>> b=upn.Number('-2 3/5')    #denary number\n>>> c=upn.Number('1101.11',2) #binary number\n>>> d=upn.Number('2 3/5',8)   #octal number\n>>> a+b\nb10:9.85\n>>> a+2.45\nb10:14.9\n>>> 10-a\nb10:-2.45\n>>> 5+b\nb10:2 2/5\n>>> c*2.5\nb10:34.375\n>>> 30/a\nb10:2.4096385542168674698795180722891566265\n>>> a/0\nb10:<INF>\n>>> b/0\nb10:<-INF>\n>>> 30//a\nb10:2\n>>> 30%a\nb10:5.1\n>>> a.power(2.5)\nb10:546.919462835080042646792227676322546\n>>> a**2.5\nb10:546.919462835080042646792227676322546\n>>> 5**a\nb10:503705338.789256548289543848618036647\n>>> b.power(-2.5)\nb10:<UNDEFINED>\n>>> b**-2.5\nb10:<UNDEFINED>\n>>> c**2.5\nb10:701.062513233261888120374289325692407\n>>> 2.5**c\nb10:296261.433052663007815877972404231589\n>>> c.power(-2.5)\nb10:0.00142640632058338821552976539808037757\n>>> c**-2.5\nb10:0.00142640632058338821552976539808037757\n>>> 2.5**upn.Number('4.5')\nb10:61.7632355501636588281033895397015339\n>>> 2**upn.Number('-4.5')\nb10:0.044194173824159220275052772631553065\n>>> \n\n```\n\n### Logical operations\nLogical operations like equal-to(==), not-equal-to(!=), greater-than(>),\nless-than(<), greater-than-or-equal-to(>=) and less-than-or-equal-to(<=)\ncan be performed on universal precision number objects as simple as done\nwith the normal numbers. 'True' or 'False' are returned.\n\n```python\n>>> \n>>> a=upn.Number('-2.5')\n>>> b=upn.Number('-10.1',2)\n>>> c=upn.Number('ab c/d',16)\n>>> d=upn.Number('f.10z',64)\n>>> \n>>> a==b\nTrue\n>>> a>b\nFalse\n>>> c<d\nFalse\n>>> d>b\nTrue\n>>> a!=b\nFalse\n>>> c>a\nTrue\n>>> a>=b\nTrue\n>>> a<10\nTrue\n>>> 10>a\nTrue\n>>> 20>=c\nFalse\n>>> 20>=d\nTrue\n>>> \n>>> \n```\n\n### In-Place assignment operations\nIn-place assignment operations like +=, -=, *=, /=, //=, %= are also\nsupported in this number system.\n\n|operator|operation|\n|---|---|\n|+=|Operands are added first, then the result is assigned to the left operand|\n|-=|Right Operand is subtracted from the left, then the result is assigned to the left operand|\n|*=|Operands are multiplied first, then the result is assigned to the left operand|\n|/=|Left operand is divided by the right one, then the result is assigned to the left operand|\n|//=|Left operand is divided by the right one, then the floor value of quotient is assigned to the left operand|\n|%=|Left operand is divided by the right one, then the remainder is assigned to the left operand|\n\n```python\n>>> \n>>> a=upn.Number('-2.5')\n>>> b=upn.Number('10.75')\n>>> c=upn.Number('13.25',8)\n>>> \n>>> a+=b\n>>> a\nb10:8.25\n>>> \n>>> a-=b\n>>> a\nb10:-2.5\n>>> \n>>> a*=c\n>>> a\nb10:-28.3203125\n>>> b/=c\n>>> b\nb10:0.9489655172413793103448275862068965517\n>>> \n>>> b=upn.Number('10.75')\n>>> c//=b\n>>> c\nb10:1\n>>> c=upn.Number('13.25',8)\n>>> c%=b\n>>> c\nb10:0.578125\n>>> \n```\n\n### Standard mathematical operations\nLogarithmic, exponential, trigonometric, hyperbolic, gamma, beta and error\nfunctions are executed efficiently with this 'upn' number system\n\n#### Inverse, factorial, logarithmic, exponential, square-root and power operations\n```python\n>>> \n>>> a=upn.Number('-2.5')\n>>> a.inv()\nb10:-0.4\n>>> b=upn.Number('7')\n>>> b.fact()\nb10:5040\n>>> \n>>> a.ln()\nb10:<UNDEFINED>\n>>> \n>>> a=upn.Number('3 4/7')\n>>> a.ln() # ln(a)\nb10:1.27296567581288744409616592300919555\n>>> a.ln(prec=50)\nb10:1.2729656758128874440961659230091955494141179789552\n>>> \n>>> a=upn.Number('-2.5')\n>>> b=upn.Number('4.75')\n>>> b.ln()        # ln(b)\nb10:1.5581446180465498411745631889715004\n>>> b.lg()        #log(b,base=10)\nb10:0.676693609624866571108855686307943264\n>>> b.log(base=2) #log(b,base=2)\nb10:2.24792751344358549379351942290683442\n>>> \n>>> a.exp()       #e^a\nb10:0.0820849986238987951695286744671598078\n>>> b.exp()       #e^b\nb10:115.584284527187658133414267136529079\n>>> \n>>> a.power(b)    #a^b\nb10:<UNDEFINED>\n>>> b.power(a)    #b^a\nb10:0.020336020730908522185680627421418239\n>>> \n>>> a=upn.Number('-2 1/2')\n>>> b=upn.Number('4 3/4')\n>>> a.sqrt()\nb10:<UNDEFINED>\n>>> b.sqrt()\nb10:2.17944947177033677611849099192980783\n>>> \n>>> a.power(b)\nb10:<UNDEFINED>\n>>> b.power(a)\nb10:0.020336020730908522185680627421418239\n>>> \n```\n\n#### Trigonometric and inverse trigonometric functions\n\n```python\n>>> \n>>> a=upn.Number('0')\n>>> b=upn.Number('390')\n>>> c=upn.Number('-405')\n>>> d=upn.Number('540')\n>>> e=upn.Number('-90')\n>>> \n>>> a.sin()\nb10:0\n>>> b.sin()\nb10:0.5\n>>> c.sin()\nb10:-0.707106781186547524400844362104849039\n>>> d.sin()\nb10:0\n>>> e.sin()\nb10:-1\n>>> \n>>> a.tan()\nb10:0\n>>> c.tan()\nb10:-1\n>>> d.tan()\nb10:0\n>>> e.tan()\nb10:<-INF>\n>>> c.cosec()\nb10:-1.41421356237309504880168872420969808\n>>> d.sec()\nb10:-1\n>>> e.cot()\nb10:0\n>>> \n>>> a=upn.Number('0')\n>>> b=upn.Number('1')\n>>> c=upn.Number('-1')\n>>> \n>>> a.asin()\nb10:0\n>>> a.acos()\nb10:90\n>>> \n>>> b.asin()\nb10:90\n>>> b.acos()\nb10:0\n>>> \n>>> b.acot(unit='rad')\nb10:0.78539816339744830961566084581987572\n>>> b.acot(unit='d')\nb10:-45\n>>> \n>>> c.acot()\nb10:45\n>>> c.atan()\nb10:-45\n>>> \n```\n#### Hyperbolic and inverse hyperbolic functions\n```python\n>>> \n>>> a=upn.Number('2')\n>>> b=upn.Number('-2')\n>>> c=upn.Number('0')\n>>> \n>>> a.sinh()\nb10:3.6268604078470187676682139828012617\n>>> a.cosh()\nb10:3.76219569108363145956221347777374611\n>>> b.tanh()\nb10:-0.96402758007581688394641372410092315\n>>> c.coth()\nb10:0\n>>> a.sech()\nb10:0.265802228834079692120862739819888972\n>>> b.cosech()\nb10:-0.275720564771783207758351482163027121\n>>> \n>>> a=upn.Number('2')\n>>> b=upn.Number('0.5')\n>>> c=upn.Number('0')\n>>> \n>>> a.asinh()\nb10:1.44363547517881034249327674027310527\n>>> a.acosh()\nb10:1.31695789692481670862504634730796844\n>>> b.atanh()\nb10:0.549306144334054845697622618461262852\n>>> c.atanh()\nb10:0\n>>> a.acoth()\nb10:0.549306144334054845697622618461262852\n>>> b.asech()\nb10:1.31695789692481670862504634730796844\n>>> c.acosech()\nb10:<INF>\n>>>\n```\n\n#### Gamma, beta and error functions\nGamma and beta functions give accurate answers for positive whole\nnumbers and approximate values for floating point numbers.\n\n```python\n>>> a=upn.Number('-1')\n>>> b=upn.Number('2')\n>>> c=upn.Number('0')\n>>> \n>>> b.gamma()\nb10:1\n>>> d=upn.Number('2.5')\n>>> d.gamma()\nb10:1.32934038817913766044178571868836165\n>>> b.beta()\nb10:0.5\n>>> c.beta()\nb10:<INF>\n>>> \n>>> a.erf()\nb10:-0.842700792949714869341220635082609259\n>>> a.erfc()\nb10:1.84270079294971486934122063508260926\n>>> b.erfc()\nb10:0.00467773498104726583793074363274707222\n>>> b.erf()\nb10:0.995322265018952734162069256367252928\n>>> c.erf()\nb10:0\n>>> c.erfc()\nb10:1\n>>> d.erf()\nb10:0.999593047982555041060435784260025087\n>>> d.erfc()\nb10:0.000406952017444958939564215739974912563\n>>> \n```\n\n#### Euler, Bernoulli and Tangent numbers\nFor odd positive integers, these numbers are zero.\n\n```python\n>>> \n>>> a=upn.Number('2')\n>>> b=upn.Number('3')\n>>> c=upn.Number('7')\n>>> d=upn.Number('8')\n>>> e=upn.Number('9')\n>>> \n>>> a.eulerNumber()\nb10:-1\n>>> b.eulerNumber()\nb10:0\n>>> c.eulerNumber()\nb10:0\n>>> d.eulerNumber()\nb10:1385\n>>> e.eulerNumber()\nb10:0\n>>> \n>>> a.bernoulliNumber()\nb10:1/6\n>>> b.bernoulliNumber()\nb10:0\n>>> c.bernoulliNumber()\nb10:0\n>>> d.bernoulliNumber()\nb10:-1/30\n>>> e.bernoulliNumber()\nb10:0\n>>> \n>>> a.tangentNumber()\nb10:1\n>>> b.tangentNumber()\nb10:0\n>>> c.tangentNumber()\nb10:0\n>>> d.tangentNumber()\nb10:272\n>>> e.tangentNumber()\nb10:0\n>>> \n```\n\n### Precision Standard Mathematical Functions (PSMF) in tabular presentation\nUPN (universal precision number) is a class instance. Denary integers\nanf floating numbers cannot use the methods of UPN class. PSMF module can\nperform math operations direcly onto integers and floating numbers.\n\n```python\n>>> \n>>> import upmath.psmf as smf\n>>> smf.nCr(10,7)\nb10:120\n>>> smf.fact(15)\nb10:1307674368000\n>>> \n>>> smf.power(2,10)\nb10:1024\n>>> \n>>> smf.e\nb10:2.7182818284590452353602874713526625\n>>> smf.E\nb10:2.7182818284590452353602874713526625\n>>> smf.PI\nb10:3.14159265358979323846264338327950288\n>>> \n```\n**Short descriptions of PSMFs**\n|Function|Arguments|Domain and Return|\n|---|---|---|\n|dataType(x=None)|x=variable|type-string returned|\n|fact(n)|n=positive integer;|factorial of n|\n|nCr(n=None,r=None)|n=integer;r=integer;n>r|integer; No of combinations|\n|nPr(n=None,r=None)|n=integer;r=integer;n>r|integer; No of permutations|\n|ln(x=None,prec=36)|x={R:x>=0};prec=positive integer|natural logarithm of x is returned|\n|lg(x=None,prec=36)|x={R:x>=0};prec=positive integer|10-based logarithm of x is returned|\n|log(x=None,base=10,prec=36)|x={R:x>=0};prec=positive integer|logarithm of x of given base is returned|\n|exp(x=None,prec=36)|x={R};prec=positive integer|exponential of x is returned|\n|sqrt(x=None,prec=36)|x={R:x>=0};prec=positive integer|square root of x is returned|\n|power(x=None,y=None,prec=36)|x=base {R:x>=0};y=power;prec=positive integer|x^y is returned|\n|sin(x=None,unit='d',prec=36)|x=angle{R};unit=unit of angle ('d','D','degre','Degre','r','R','c','rad','Rad','radian','Radian');prec=positive integer|sin of x is returned|\n|cos(x=None,unit='d',prec=36)|x=angle{R};unit=unit of angle ('d','D','degre','Degre','r','R','c','rad','Rad','radian','Radian');prec=positive integer|cos of x is returned|\n|tan(x=None,unit='d',prec=36)|x=angle{R};unit=unit of angle ('d','D','degre','Degre','r','R','c','rad','Rad','radian','Radian');prec=positive integer|tan of x is returned|\n|cot(x=None,unit='d',prec=36)|x=angle{R};unit=unit of angle ('d','D','degre','Degre','r','R','c','rad','Rad','radian','Radian');prec=positive integer|cot of x is returned|\n|sec(x=None,unit='d',prec=36)|x=angle{R};unit=unit of angle ('d','D','degre','Degre','r','R','c','rad','Rad','radian','Radian');prec=positive integer|sec of x is returned|\n|cosec(x=None,unit='d',prec=36)|x=angle{R};unit=unit of angle ('d','D','degre','Degre','r','R','c','rad','Rad','radian','Radian');prec=positive integer|cosec of x is returned|\n|asin(x=None,unit='d',prec=36)|x={R:-1<=x<=1};unit=unit of output angle ('d','D','degre','Degre','r','R','c','rad','Rad','radian','Radian');prec=positive integer|sin inverse of x is returned|\n|acos(x=None,unit='d',prec=36)|x={R:-1<=x<=1};unit=unit of output angle ('d','D','degre','Degre','r','R','c','rad','Rad','radian','Radian');prec=positive integer|cos inverse of x is returned|\n|atan(x=None,unit='d',prec=36)|x={R:-PI/2<=x<=PI/2};unit=unit of output angle ('d','D','degre','Degre','r','R','c','rad','Rad','radian','Radian');prec=positive integer|tan inverse of x is returned|\n|acot(x=None,unit='d',prec=36)|x={R:-PI/2<=x<=PI/2};unit=unit of output angle ('d','D','degre','Degre','r','R','c','rad','Rad','radian','Radian');prec=positive integer|cot inverse of x is returned|\n|asec(x=None,unit='d',prec=36)|x={R:-1>x>1};unit=unit of output angle ('d','D','degre','Degre','r','R','c','rad','Rad','radian','Radian');prec=positive integer|sec inverse of x is returned|\n|acosec(x=None,unit='d',prec=36)|x={R:-1>x>1};unit=unit of output angle ('d','D','degre','Degre','r','R','c','rad','Rad','radian','Radian');prec=positive integer|cosec inverse of x is returned|\n|sinh(x=None,prec=36)|x={R};prec=positive integer|hyperbolic sin of x is returned;Range:{R}|\n|cosh(x=None,prec=36)|x={R};prec=positive integer|hyperbolic cos of x is returned;Range:{R}|\n|tanh(x=None,prec=36)|x={R};prec=positive integer|hyperbolic tan of x is returned;Range:{R:-PI/2<=f(x)<=PI/2}|\n|coth(x=None,prec=36)|x={R};prec=positive integer|hyperbolic cot of x is returned;Range:{R:-1<=f(x)<=1}|\n|sech(x=None,prec=36)|x={R};prec=positive integer|hyperbolic sec of x is returned;Range:{R}|\n|cosech(x=None,prec=36)|x={R};prec=positive integer|hyperbolic cosec of x is returned;Range:{R}|\n|asinh(x=None,prec=36)|x={R};prec=positive integer|hyperbolic sin inverse of x is returned;Range:{R}|\n|acosh(x=None,prec=36)|x={R};prec=positive integer|hyperbolic cos inverse of x is returned;Range:{R}|\n|atanh(x=None,prec=36)|x={R:-1>=x>=1};prec=positive integer|hyperbolic tan inverse of x is returned;Range:{R}|\n|acoth(x=None,prec=36)|x={R:-1>=x>=1};prec=positive integer|hyperbolic cot inverse of x is returned;Range:{R}|\n|asech(x=None,prec=36)|x={R:1>=x>=0};prec=positive integer|hyperbolic sec inverse of x is returned;Range:{R}|\n|acosech(x=None,prec=36)|x={R:1>=x>=0};prec=positive integer|hyperbolic cosec inverse  of x is returned;Range:{R}|\n|gamma(x=None,prec=36)|x={R:x>0};prec=positive integer|gamma of x is returned;Range:{R:f(x)>=0}|\n|beta(x=None,y=None,prec=36)|x={R:x>0};y={R:y>0};prec=positive integer|beta of x and y is returned;Range:{R:1>=f(x)>=0}|\n|erf(x=None,prec=36)|x={R};prec=positive integer|error-function of x is returned;Range:{R:-1=<f(x)<=1}|\n|erfc(x=None,prec=36)|x={R};prec=positive integer|complementary error-function of x is returned;Range:{R:0=<f(x)<=2}|\n|eulerNumber(r=None)|r=positive integer|if r is odd, 0(zero) is returned;otherwise integer returned|\n|bernoulliNumber(r=None)|r=positive integer|if r is odd, 0(zero) is returned;otherwise fraction is returned|\n|tangentNumber(r=None)|r=positive integer|if r is odd, 0(zero) is returned;otherwise integer returned|\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
            "description_content_type": "text/markdown",
            "docs_url": null,
            "download_url": "",
            "downloads": {
                "last_day": -1,
                "last_month": -1,
                "last_week": -1
            },
            "home_page": "",
            "keywords": "",
            "license": "NEWTONIA FREEWARE LICENSE",
            "maintainer": "",
            "maintainer_email": "",
            "name": "upmath",
            "package_url": "https://pypi.org/project/upmath/",
            "platform": "",
            "project_url": "https://pypi.org/project/upmath/",
            "project_urls": null,
            "release_url": "https://pypi.org/project/upmath/1.3/",
            "requires_dist": null,
            "requires_python": "",
            "summary": "This package provides universal precision number and standard math functions that support mathematical operations on the universal precision number.",
            "version": "1.3",
            "yanked": false,
            "yanked_reason": null
        },
        "last_serial": 7704331,
        "urls": [
            {
                "comment_text": "",
                "digests": {
                    "md5": "07034d69e422d4f6dc475e3d9edb8ece",
                    "sha256": "2320c0b018594727a39f836617c445e02d1cac7b78be8e2fae623e2bc8354be2"
                },
                "downloads": -1,
                "filename": "upmath-1.3-py2.py3-none-any.whl",
                "has_sig": false,
                "md5_digest": "07034d69e422d4f6dc475e3d9edb8ece",
                "packagetype": "bdist_wheel",
                "python_version": "py2.py3",
                "requires_python": null,
                "size": 59485,
                "upload_time": "2020-07-15T10:09:36",
                "upload_time_iso_8601": "2020-07-15T10:09:36.565360Z",
                "url": "https://files.pythonhosted.org/packages/8c/05/9311c65688874cd7dc7043a51c9392651228e09ea1af6edb98ef2c8d0945/upmath-1.3-py2.py3-none-any.whl",
                "yanked": false,
                "yanked_reason": null
            },
            {
                "comment_text": "",
                "digests": {
                    "md5": "81c52e11b420e2e6da1521888122e98f",
                    "sha256": "96785b8f2abceb44d4d2893091616959c88da23d70f9ce6125d41f0c77725b46"
                },
                "downloads": -1,
                "filename": "upmath-1.3.tar.gz",
                "has_sig": false,
                "md5_digest": "81c52e11b420e2e6da1521888122e98f",
                "packagetype": "sdist",
                "python_version": "source",
                "requires_python": null,
                "size": 63397,
                "upload_time": "2020-07-15T10:09:39",
                "upload_time_iso_8601": "2020-07-15T10:09:39.489105Z",
                "url": "https://files.pythonhosted.org/packages/7d/f6/a46cb680a57c9c4de527a28a7deb0eee35ba785f4c71c238aa48387ec855/upmath-1.3.tar.gz",
                "yanked": false,
                "yanked_reason": null
            }
        ],
        "vulnerabilities": []
    }
}