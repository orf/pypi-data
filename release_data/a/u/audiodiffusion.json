{
    "1.2.6": {
        "info": {
            "author": "",
            "author_email": "",
            "bugtrack_url": null,
            "classifiers": [
                "Programming Language :: Python :: 3"
            ],
            "description": "---\ntitle: Audio Diffusion\nemoji: \ud83c\udfb5\ncolorFrom: pink\ncolorTo: blue\nsdk: gradio\nsdk_version: 3.1.4\napp_file: app.py\npinned: false\nlicense: gpl-3.0\n---\n# audio-diffusion [![Open in Colab](https://colab.research.google.com/assets/colab-badge.svg)](https://colab.research.google.com/github/teticio/audio-diffusion/blob/master/notebooks/gradio_app.ipynb)\n\n## Apply diffusion models to synthesize music instead of images using the new Hugging Face [diffusers](https://github.com/huggingface/diffusers) package\n\n---\n\n**UPDATES**:\n\n**7/11/2022**. Added pre-trained latent audio diffusion models [teticio/latent-audio-diffusion-256](https://huggingface.co/teticio/latent-audio-diffusion-256) and [teticio/latent-audio-diffusion-ddim-256](https://huggingface.co/teticio/latent-audio-diffusion-ddim-256). You can use the pre-trained VAE to train your own latent diffusion models on a different set of audio files.\n\n**22/10/2022**. Added DDIM encoder and ability to interpolate between audios in latent \"noise\" space. Mel spectrograms no longer have to be square (thanks to Tristan for this one), so you can set the vertical (frequency) and horizontal (time) resolutions independently.\n\n**15/10/2022**. Added latent audio diffusion (see below). Also added the possibility to train a DDIM ([De-noising Diffusion Implicit Models](https://arxiv.org/pdf/2010.02502.pdf)). These have the benefit that samples can be generated with much fewer steps (~50) than used in training.\n\n**4/10/2022**. It is now possible to mask parts of the input audio during generation which means you can stitch several samples together (think \"out-painting\").\n\n**27/9/2022**. You can now generate an audio based on a previous one. You can use this to generate variations of the same audio or even to \"remix\" a track (via a sort of \"style transfer\"). You can find examples of how to do this in the [`test_model.ipynb`](https://colab.research.google.com/github/teticio/audio-diffusion/blob/master/notebooks/test_model.ipynb) notebook.\n\n---\n\n![mel spectrogram](mel.png)\n\n---\n\n## DDPM ([De-noising Diffusion Probabilistic Models](https://arxiv.org/abs/2006.11239))\n\nAudio can be represented as images by transforming to a [mel spectrogram](https://en.wikipedia.org/wiki/Mel-frequency_cepstrum), such as the one shown above. The class `Mel` in `mel.py` can convert a slice of audio into a mel spectrogram of `x_res` x `y_res` and vice versa. The higher the resolution, the less audio information will be lost. You can see how this works in the [`test_mel.ipynb`](https://github.com/teticio/audio-diffusion/blob/main/notebooks/test_mel.ipynb) notebook.\n\nA DDPM is trained on a set of mel spectrograms that have been generated from a directory of audio files. It is then used to synthesize similar mel spectrograms, which are then converted back into audio.\n\nYou can play around with some pre-trained models on [Google Colab](https://colab.research.google.com/github/teticio/audio-diffusion/blob/master/notebooks/test_model.ipynb) or [Hugging Face spaces](https://huggingface.co/spaces/teticio/audio-diffusion). Check out some automatically generated loops [here](https://soundcloud.com/teticio2/sets/audio-diffusion-loops).\n\n| Model | Dataset | Description |\n|-------|---------|-------------|\n| [teticio/audio-diffusion-256](https://huggingface.co/teticio/audio-diffusion-256) | [teticio/audio-diffusion-256](https://huggingface.co/datasets/teticio/audio-diffusion-256) | My \"liked\" Spotify playlist |\n| [teticio/audio-diffusion-breaks-256](https://huggingface.co/teticio/audio-diffusion-breaks-256) | [teticio/audio-diffusion-breaks-256](https://huggingface.co/datasets/teticio/audio-diffusion-breaks-256) | Samples that have been used in music, sourced from [WhoSampled](https://whosampled.com) and [YouTube](https://youtube.com) |\n| [teticio/audio-diffusion-instrumental-hiphop-256](https://huggingface.co/teticio/audio-diffusion-instrumental-hiphop-256) | [teticio/audio-diffusion-instrumental-hiphop-256](https://huggingface.co/datasets/teticio/audio-diffusion-instrumental-hiphop-256) | Instrumental Hip Hop music |\n| [teticio/audio-diffusion-ddim-256](https://huggingface.co/teticio/audio-diffusion-ddim-256) | [teticio/audio-diffusion-256](https://huggingface.co/datasets/teticio/audio-diffusion-256) | De-noising Diffusion Implicit Model |\n| [teticio/latent-audio-diffusion-256](https://huggingface.co/teticio/latent-audio-diffusion-256) | [teticio/audio-diffusion-256](https://huggingface.co/datasets/teticio/audio-diffusion-256) | Latent Audio Diffusion model |\n| [teticio/latent-audio-diffusion-ddim-256](https://huggingface.co/teticio/latent-audio-diffusion-ddim-256) | [teticio/audio-diffusion-256](https://huggingface.co/datasets/teticio/audio-diffusion-256) | Latent Audio Diffusion De-noising Diffusion Implicit Model |\n\n---\n\n## Generate Mel spectrogram dataset from directory of audio files\n\n#### Install\n\n```bash\npip install .\n```\n\n#### Training can be run with Mel spectrograms of resolution 64x64 on a single commercial grade GPU (e.g. RTX 2080 Ti). The `hop_length` should be set to 1024 for better results\n\n```bash\npython scripts/audio_to_images.py \\\n--resolution 64,64 \\\n--hop_length 1024 \\\n--input_dir path-to-audio-files \\\n--output_dir path-to-output-data\n```\n\n#### Generate dataset of 256x256 Mel spectrograms and push to hub (you will need to be authenticated with `huggingface-cli login`)\n\n```bash\npython scripts/audio_to_images.py \\\n--resolution 256 \\\n--input_dir path-to-audio-files \\\n--output_dir data/audio-diffusion-256 \\\n--push_to_hub teticio/audio-diffusion-256\n```\n\nNote that the default `sample_rate` is 22050 and audios will be resampled if they are at a different rate. If you change this value, you may find that the results in the `test_mel.ipynb` notebook are not good (for example, if `sample_rate` is 48000) and that it is necessary to adjust `n_fft` (for example, to 2000 instead of the default value of 2048; alternatively, you can resample to a `sample_rate` of 44100). Make sure you use the same parameters for training and inference. You should also bear in mind that not all resolutions work with the neural network architecture as currently configured - you should be safe if you stick to powers of 2.\n\n## Train model\n\n#### Run training on local machine\n\n```bash\naccelerate launch --config_file config/accelerate_local.yaml \\\nscripts/train_unconditional.py \\\n--dataset_name data/audio-diffusion-64 \\\n--hop_length 1024 \\\n--output_dir models/ddpm-ema-audio-64 \\\n--train_batch_size 16 \\\n--num_epochs 100 \\\n--gradient_accumulation_steps 1 \\\n--learning_rate 1e-4 \\\n--lr_warmup_steps 500 \\\n--mixed_precision no\n```\n\n#### Run training on local machine with `batch_size` of 2 and `gradient_accumulation_steps` 8 to compensate, so that 256x256 resolution model fits on commercial grade GPU and push to hub\n\n```bash\naccelerate launch --config_file config/accelerate_local.yaml \\\nscripts/train_unconditional.py \\\n--dataset_name teticio/audio-diffusion-256 \\\n--output_dir models/audio-diffusion-256 \\\n--num_epochs 100 \\\n--train_batch_size 2 \\\n--eval_batch_size 2 \\\n--gradient_accumulation_steps 8 \\\n--learning_rate 1e-4 \\\n--lr_warmup_steps 500 \\\n--mixed_precision no \\\n--push_to_hub True \\\n--hub_model_id audio-diffusion-256 \\\n--hub_token $(cat $HOME/.huggingface/token)\n```\n\n#### Run training on SageMaker\n\n```bash\naccelerate launch --config_file config/accelerate_sagemaker.yaml \\\nscripts/train_unconditional.py \\\n--dataset_name teticio/audio-diffusion-256 \\\n--output_dir models/ddpm-ema-audio-256 \\\n--train_batch_size 16 \\\n--num_epochs 100 \\\n--gradient_accumulation_steps 1 \\\n--learning_rate 1e-4 \\\n--lr_warmup_steps 500 \\\n--mixed_precision no\n```\n\n## DDIM ([De-noising Diffusion Implicit Models](https://arxiv.org/pdf/2010.02502.pdf))\n\n#### A DDIM can be trained by adding the parameter\n\n```bash\n--scheduler ddim\n```\n\nInference can the be run with far fewer steps than the number used for training (e.g., ~50), allowing for much faster generation. Without retraining, the parameter `eta` can be used to replicate a DDPM if it is set to 1 or a DDIM if it is set to 0, with all values in between being valid. When `eta` is 0 (the default value), the de-noising procedure is deterministic, which means that it can be run in reverse as a kind of encoder that recovers the original noise used in generation. A function `encode` has been added to `AudioDiffusionPipeline` for this purpose. It is then possible to interpolate between audios in the latent \"noise\" space using the function `slerp` (Spherical Linear intERPolation).\n\n## Latent Audio Diffusion\n\nRather than de-noising images directly, it is interesting to work in the \"latent space\" after first encoding images using an autoencoder. This has a number of advantages. Firstly, the information in the images is compressed into a latent space of a much lower dimension, so it is much faster to train de-noising diffusion models and run inference with them. Secondly, similar images tend to be clustered together and interpolating between two images in latent space can produce meaningful combinations.\n\nAt the time of writing, the Hugging Face `diffusers` library is geared towards inference and lacking in training functionality (rather like its cousin `transformers` in the early days of development). In order to train a VAE (Variational AutoEncoder), I use the [stable-diffusion](https://github.com/CompVis/stable-diffusion) repo from CompVis and convert the checkpoints to `diffusers` format. Note that it uses a perceptual loss function for images; it would be nice to try a perceptual *audio* loss function.\n\n#### Train latent diffusion model using pre-trained VAE\n\n```bash\naccelerate launch ...\n...\n--vae teticio/latent-audio-diffusion-256\n```\n\n#### Install dependencies to train with Stable Diffusion\n\n```bash\npip install omegaconf pytorch_lightning\npip install -e git+https://github.com/CompVis/stable-diffusion.git@main#egg=latent-diffusion\npip install -e git+https://github.com/CompVis/taming-transformers.git@master#egg=taming-transformers\n```\n\n#### Train an autoencoder\n\n```bash\npython scripts/train_vae.py \\\n--dataset_name teticio/audio-diffusion-256 \\\n--batch_size 2 \\\n--gradient_accumulation_steps 12\n```\n\n#### Train latent diffusion model\n\n```bash\naccelerate launch ...\n...\n--vae models/autoencoder-kl\n```\n",
            "description_content_type": "text/markdown",
            "docs_url": null,
            "download_url": "",
            "downloads": {
                "last_day": -1,
                "last_month": -1,
                "last_week": -1
            },
            "home_page": "",
            "keywords": "",
            "license": "GPL3",
            "maintainer": "",
            "maintainer_email": "",
            "name": "audiodiffusion",
            "package_url": "https://pypi.org/project/audiodiffusion/",
            "platform": null,
            "project_url": "https://pypi.org/project/audiodiffusion/",
            "project_urls": null,
            "release_url": "https://pypi.org/project/audiodiffusion/1.2.6/",
            "requires_dist": [
                "torch",
                "numpy",
                "Pillow",
                "diffusers (>=0.4.1)",
                "librosa",
                "datasets"
            ],
            "requires_python": "",
            "summary": "Generate Mel spectrogram dataset from directory of audio files.",
            "version": "1.2.6",
            "yanked": false,
            "yanked_reason": null
        },
        "last_serial": 15710162,
        "urls": [
            {
                "comment_text": "",
                "digests": {
                    "md5": "8323fa0e4b95af8eed48a20959dbc8a3",
                    "sha256": "f9a27531762f70aa9017d051ac88b9a7ecb2b5f9030ca1847f3ce7417d274b89"
                },
                "downloads": -1,
                "filename": "audiodiffusion-1.2.6-py3-none-any.whl",
                "has_sig": false,
                "md5_digest": "8323fa0e4b95af8eed48a20959dbc8a3",
                "packagetype": "bdist_wheel",
                "python_version": "py3",
                "requires_python": null,
                "size": 29477,
                "upload_time": "2022-11-09T10:38:46",
                "upload_time_iso_8601": "2022-11-09T10:38:46.526827Z",
                "url": "https://files.pythonhosted.org/packages/77/e9/374106d1ae6eaedc167049ee75acbf7d9b5e3005c02667ccc674fc04835c/audiodiffusion-1.2.6-py3-none-any.whl",
                "yanked": false,
                "yanked_reason": null
            },
            {
                "comment_text": "",
                "digests": {
                    "md5": "16b2e76f93c559cd532cf9eaffca4e3d",
                    "sha256": "7106ef872d1d7d29ddc1e1ad5c826a499c98e6a7db556c9206ab3264466370ba"
                },
                "downloads": -1,
                "filename": "audiodiffusion-1.2.6.tar.gz",
                "has_sig": false,
                "md5_digest": "16b2e76f93c559cd532cf9eaffca4e3d",
                "packagetype": "sdist",
                "python_version": "source",
                "requires_python": null,
                "size": 27017,
                "upload_time": "2022-11-09T10:38:48",
                "upload_time_iso_8601": "2022-11-09T10:38:48.527074Z",
                "url": "https://files.pythonhosted.org/packages/97/d1/837887170b293bea419236abd7888f7a963b37c63009e167dfcde8220d6c/audiodiffusion-1.2.6.tar.gz",
                "yanked": false,
                "yanked_reason": null
            }
        ],
        "vulnerabilities": []
    }
}