{
    "0.1.1": {
        "info": {
            "author": "Vikram Patki, Aditya Vaderiyettil",
            "author_email": "vpatki@wayfair.com",
            "bugtrack_url": null,
            "classifiers": [
                "Development Status :: 4 - Beta",
                "License :: OSI Approved :: MIT License",
                "Programming Language :: Python",
                "Programming Language :: Python :: 3",
                "Programming Language :: Python :: 3.10",
                "Programming Language :: Python :: 3.7",
                "Programming Language :: Python :: 3.8",
                "Programming Language :: Python :: 3.9"
            ],
            "description_content_type": "text/markdown",
            "docs_url": null,
            "download_url": "",
            "downloads": {
                "last_day": -1,
                "last_month": -1,
                "last_week": -1
            },
            "home_page": "https://github.com/wayfair-incubator/dagger",
            "keywords": "",
            "license": "",
            "maintainer": "",
            "maintainer_email": "",
            "name": "wf-dagger",
            "package_url": "https://pypi.org/project/wf-dagger/",
            "platform": null,
            "project_url": "https://pypi.org/project/wf-dagger/",
            "project_urls": {
                "Homepage": "https://github.com/wayfair-incubator/dagger"
            },
            "release_url": "https://pypi.org/project/wf-dagger/0.1.1/",
            "requires_dist": [
                "faust-streaming"
            ],
            "requires_python": ">=3.7",
            "summary": "Workflow Engine.",
            "version": "0.1.1",
            "yanked": false,
            "yanked_reason": null
        },
        "last_serial": 15538995,
        "urls": [
            {
                "comment_text": "",
                "digests": {
                    "md5": "f2f32767d205fda90a9703f08e40b725",
                    "sha256": "76026c9076b0771e6af2a06bb2c893dec056c146a5c4582fbfe5c19f98222ae4"
                },
                "downloads": -1,
                "filename": "wf_dagger-0.1.1-py3-none-any.whl",
                "has_sig": false,
                "md5_digest": "f2f32767d205fda90a9703f08e40b725",
                "packagetype": "bdist_wheel",
                "python_version": "py3",
                "requires_python": ">=3.7",
                "size": 60524,
                "upload_time": "2022-10-19T17:09:44",
                "upload_time_iso_8601": "2022-10-19T17:09:44.470918Z",
                "url": "https://files.pythonhosted.org/packages/10/f1/14332e485c4ac71ad27f141fc1cdf49c160fd72664e840603e0284902be2/wf_dagger-0.1.1-py3-none-any.whl",
                "yanked": false,
                "yanked_reason": null
            },
            {
                "comment_text": "",
                "digests": {
                    "md5": "cb8018686f4115aa1874e8e908db2a37",
                    "sha256": "294cad44f88ad04dc9c620eb6a1e971023728ed3f9a249f3650baaa2fd967793"
                },
                "downloads": -1,
                "filename": "wf-dagger-0.1.1.tar.gz",
                "has_sig": false,
                "md5_digest": "cb8018686f4115aa1874e8e908db2a37",
                "packagetype": "sdist",
                "python_version": "source",
                "requires_python": ">=3.7",
                "size": 55771,
                "upload_time": "2022-10-19T17:09:46",
                "upload_time_iso_8601": "2022-10-19T17:09:46.145114Z",
                "url": "https://files.pythonhosted.org/packages/04/94/121e484c2369f0cee2e45a1fc0833b9a37c1f63c23f5e0125167156e0adc/wf-dagger-0.1.1.tar.gz",
                "yanked": false,
                "yanked_reason": null
            }
        ],
        "vulnerabilities": []
    },
    "0.1.4": {
        "info": {
            "author": "Vikram Patki, Aditya Vaderiyettil",
            "author_email": "vpatki@wayfair.com",
            "bugtrack_url": null,
            "classifiers": [
                "Development Status :: 4 - Beta",
                "License :: OSI Approved :: MIT License",
                "Programming Language :: Python",
                "Programming Language :: Python :: 3",
                "Programming Language :: Python :: 3.10",
                "Programming Language :: Python :: 3.7",
                "Programming Language :: Python :: 3.8",
                "Programming Language :: Python :: 3.9"
            ],
            "description": "![CI pipeline status](https://github.com/wayfair-incubator/dagger/workflows/CI/badge.svg?branch=main)\n[![PyPI](https://img.shields.io/pypi/v/wf-dagger)](https://pypi.org/project/wf-dagger/)\n![Contributor Covenant](https://img.shields.io/badge/Contributor%20Covenant-2.0-4baaaa.svg)\n![Maintainer](https://img.shields.io/badge/Maintainer-Wayfair-7F187F)\n![codecov](https://codecov.io/gh/wayfair-incubator/dagger/branch/main/graph/badge.svg)\n![Checked with mypy](https://img.shields.io/badge/mypy-checked-blue)\n![Code style: black](https://img.shields.io/badge/code%20style-black-black.svg)\n\n# Dagger\n\n**Dagger** is a distributed, scalable, durable, and highly available orchestration engine to execute asynchronous and\nsynchronous long-running business logic in a scalable and resilient way.\nDagger requires Python 3.7 or later for the new `async/await`_ syntax, and variable type annotations.\n\n## Pizza Ordering and Delivery Workflow Example\nHere's an example of how to use the library to build and run a Pizza Ordering Workflow:\n\n![Pizza Workflow](docs/images/workflow.jpg)\n\nThe PizzaWorkflow consists of 2 Processes: \n\n* Order : Responsible for communicating with the order service to place a pizza order(CommandTask) and wait for the order\nto be ready(ListenerTask)\n* Delivery: Once the order is ready, this process communicates with the delivery service to start delivery of the pizza\norder(CommandTask)\n\n### Step 1 Instantiate Dagger\n\n```python\nworkflow_engine = Dagger(\n                    broker=KAFKA_ADMIN_CLIENT_URL,\n                    store=\"aerospike://\",\n                    consumer_auto_offset_reset=\"latest\",\n                    task_update_topic=\"task_update_topic\",\n                    trigger_interval=600,\n                    aerospike_config=aerospike_config,\n                    enable_changelog=False,\n                    web_port=6066,\n                    serializer=\"raw\",\n                )\n```\n\n### Step 2 Define Leaf Command and Listener Tasks For Order Process\n\nLet's assume that the Order Microservice processes incoming orders over a Kafka Topic - `pizza_order_topic` with the \nJSON schema\n\n```json\n{\n  \"order_id\": \"id\",\n  \"pizza_type\": \"1\",\n  \"customer_id\": \"customer_id\"\n}\n```\n\nUsing this information let's build out the OrderCommandTask by overriding the `execute` method that implements the \nbusiness logic on how to send the payload to the Order Service over a Kafka topic\n\n```python\nclass OrderCommandTask(KafkaCommandTask[str, str]):\n    async def execute(\n        self,\n        runtime_parameters: Dict[str, str],\n        workflow_instance: ITemplateDAGInstance,\n    ) -> None:\n        payload = {\n            \"order_id\": runtime_parameters[\"order_id\"],\n            \"customer_id\": runtime_parameters[\"customer_id\"],\n            \"pizza_type\": runtime_parameters[\"pizza_type\"],\n        }\n        await workflow_engine.topics[self.topic].send(\n            value=json.dumps(payload)\n        )\n```\n\nAfter executing the `OrderCommandTask`, the workflow should enter a `WAIT_STATE` until it receives a message from the \nOrderService about the status of the order. Let's assume that Order Service sends a message on a Kafka Topic: \norder_status_topic when the order is ready in the following JSON format\n\n```json\n{\n  \"order_id\": \"id\",\n  \"status\": \"READY\"\n}\n```\n\nLet's model the `OrderListenerTask` to process this message on the `order_status_topic` by implementing the \n`get_correlatable_keys_from_payload` and `on_message` methods on the Listener. It also needs to specify the `correletable_key`\nas `order_id` to look up the payload\n\n```python\nclass PizzaWaitForReadyListener(KafkaListenerTask[str, str]):\n    correlatable_key = \"order_id\"\n\n    async def get_correlatable_keys_from_payload(\n        self, payload: Any\n    ) -> List[TaskLookupKey]:\n        tpayload = json.loads(payload)\n        key = tpayload[self.correlatable_key]\n        return [(self.correlatable_key, key)]\n\n    async def on_message(\n            self, runtime_parameters: Dict[str, VT], *args: Any, **kwargs: Any\n    ) -> bool :\n        logger.info(f\"Pizza Order is Ready\")\n        return True\n```\n\nWhen the order service sends a status message on the `order_status_topic`, Dagger invokes the `get_correlatable_keys_from_payload`\nto determine which workflow instance that message belongs to. Once it determines the workflow instance, it invokes \n`on_message` on the corresponding ListenerTask\n\nNow that we have the LEAF tasks modeled, lets attach them to the parent `Order` Process\n\n```python\ndef pizza_ordering_process(\n    process_name: str = \"Order\"\n) -> IProcessTemplateDAGBuilder:\n    dag_builder = DAGBuilderHelper(dagger_app=workflow_engine)\n    root_task = dag_builder.build_and_link_tasks(\n        [\n           dag_builder.generic_command_task_builder(\n                topic=\"pizza_order_topic\",\n                task_type=OrderCommandTask,\n                process_name=process_name,\n            ),\n            dag_builder.generic_listener_task_builder(\n                topic=\"PizzaWaitForReadyListener\",\n                task_type=PizzaWaitForReadyListener,\n                process_name=process_name,\n            ),\n        ]\n    )\n    return dag_builder.generic_process_builder(process_name=process_name, root_task=root_task)\n```\n\nThe Order Process is in `COMPLETED` when both the CommandTask and the PizzaWaitForReadyListener are `COMPLETED` and then\nthe workflow transitions to execute the next Process `Delivery`\n\n### Step 3 Define Leaf Command Tasks For Delivery Process\n\nLet's assume that the delivery service just requires an HTTP POST request with the following schema\n\n```json\n{\n  \"order_id\": \"id\",\n  \"customer_id\": \"customer_id\"\n}\n```\n\nWe can model the DeliveryCommandTask to POST this payload by implementing the `execute` method as follows\n\n```python\nclass DeliveryCommandTask(ExecutorTask[str, str]):\n    async def execute(\n        self, runtime_parameters: Dict[str, VT], workflow_instance: ITask = None\n    ) -> None:\n        payload = {\n            \"order_id\": runtime_parameters[\"order_id\"],\n            \"customer_id\": runtime_parameters[\"customer_id\"],\n        }\n        async with aiohttp.ClientSession() as session:\n            async with session.post(url=\"http://www.deliverysvc.com\", json=payload):\n                pass\n```\n\nLet's attach this to the parent `Delivery` Process\n\n```python\ndef pizza_delivery_process(\n    process_name: str = \"Delivery\",\n) -> IProcessTemplateDAGBuilder:\n    dag_builder = DAGBuilderHelper(dagger_app=workflow_engine)\n    root_task = dag_builder.build_and_link_tasks(\n        [\n            dag_builder.generic_executor_task_builder(\n                task_type=DeliveryCommandTask,\n                name=process_name,\n            )\n        ]\n    )\n    return dag_builder.generic_process_builder(\n        process_name=process_name, root_task=root_task\n    )\n```\n\n### Step 4 Define the Sequence of Process Execution and register the workflow definition using `register_template`\n\nBased on the workflow, we want the `Order` Process to execute first before the `Delivery` Process. The workflow ensures\nthat the `Delivery` tasks are executed only after both the tasks in the `Order` process are in a terminal state\n\n```python\n@Dagger.register_template(\"PizzaWorkflow\")\ndef register_pizza_workflow(template_name: str) -> ITemplateDAG:\n    dag_builder_helper = DAGBuilderHelper(workflow_engine)\n    order_process = dag_builder_helper.build_and_link_processes(\n        [\n            pizza_ordering_process(process_name=\"Order\"),\n            pizza_delivery_process(process_name=\"Delivery\"),\n        ]\n    )\n    return dag_builder_helper.generic_template(\n        template_name=template_name, root_process=order_process\n    )\n```\n\n### Step 5 Define an API to instantiate and execute pizza order workflows\n\n```python\nasync def create_and_submit_pizza_delivery_workflow(\n    order_id: str, customer_id: str, pizza_type: int\n):\n    pizza_workflow_template = workflow_engine.template_dags[\"PizzaWorkflow\"]\n    pizza_workflow_instance = await pizza_workflow_template.create_instance(\n        uuid.uuid1(),\n        repartition=False,  # Create this instance on the current worker\n        order_id=order_id,\n        customer_id=customer_id,\n        pizza_type=pizza_type,\n    )\n    await workflow_engine.submit(pizza_workflow_instance, repartition=False)\n```\n\n### Step 6 Start the worker\n\n```python\nworkflow_engine.main()\n```\n\n## Dagger is\n\n### Simple\n\nDagger is extremely easy to use. To get started applications need to install this library, define a DAG using the\ndefault templates or extending them based on the use case, creating instances of these DAG's and scheduling them for\nexecution. The library hides all the complexity of producing and consuming from Kafka, maintaining Kafka Streams\ntopology processing and also persistence and recovery of created tasks\n\n### Highly Available\n\nDagger is highly available and can survive network problems and server crashes. In the case of node failure, it can\nautomatically recover the state store(representing task data)\nor failover to a standby node\n\n### Distributed\n\nStart more instances of your application as needed to distribute the load on the system\n\n### Fast\n\nA single-core worker instance can already process tens of thousands of tasks every second. Dagger uses a fast key-value\nlookup store based on rocksDB replicated to kafka topics for fault tolerance\n\n## Installation\n\nYou can install dagger via the Wayfair artifactory or from source.\n\nTo install using `pip`:\n\n```shell\npip install wf-dagger\n```\n\ndagger has a dependency on `faust-streaming` for kafka stream processing\n\n## FAQ\n\n### Which version of python is supported?\n\ndagger supports python version >= 3.7\n\n### What kafka versions are supported?\n\ndagger supports kafka with version >= 0.10.\n\n## Roadmap\n\nSee the [open issues](https://github.com/wayfair-incubator/dagger/issues) for a list of proposed features (and known\nissues).\n\n## Contributing\n\nContributions are what make the open source community such an amazing place to learn, inspire, and create. Any\ncontributions you make are **greatly appreciated**. For detailed contributing guidelines, please\nsee [CONTRIBUTING.md](CONTRIBUTING.md)\n\n## License\n\nDistributed under the `MIT LICENSE` License. See `LICENSE` for more information.\n\n## Contact\n\nVikram Patki - vpatki@wayfair.com\n\nProject Link: [https://github.com/wayfair-incubator/dagger](https://github.com/wayfair-incubator/dagger)\n\n## Acknowledgements\n\nThis template was adapted from\n[https://github.com/othneildrew/Best-README-Template](https://github.com/othneildrew/Best-README-Template).\n\n## Documentation\n\nCheck out the [project documentation][dagger-docs].\n\nFor an overview on the repository structure and how to work with the code base, read the\n[Development Guide][development-docs].\n\n[dagger-docs]: https://wayfair-incubator.github.io/dagger/latest/\n[development-docs]: https://wayfair-incubator.github.io/dagger/latest/development-guide/\n",
            "description_content_type": "text/markdown",
            "docs_url": null,
            "download_url": "",
            "downloads": {
                "last_day": -1,
                "last_month": -1,
                "last_week": -1
            },
            "home_page": "https://github.com/wayfair-incubator/dagger",
            "keywords": "",
            "license": "",
            "maintainer": "",
            "maintainer_email": "",
            "name": "wf-dagger",
            "package_url": "https://pypi.org/project/wf-dagger/",
            "platform": null,
            "project_url": "https://pypi.org/project/wf-dagger/",
            "project_urls": {
                "Homepage": "https://github.com/wayfair-incubator/dagger"
            },
            "release_url": "https://pypi.org/project/wf-dagger/0.1.4/",
            "requires_dist": [
                "faust-streaming"
            ],
            "requires_python": ">=3.7",
            "summary": "Workflow Engine.",
            "version": "0.1.4",
            "yanked": false,
            "yanked_reason": null
        },
        "last_serial": 15538995,
        "urls": [
            {
                "comment_text": "",
                "digests": {
                    "md5": "f40394b5c017e670c1f36edd32273837",
                    "sha256": "ae9958edeb2e18bbc1d966bcea8c35d196bcc8da8732334224c9846fe73c735e"
                },
                "downloads": -1,
                "filename": "wf_dagger-0.1.4-py3-none-any.whl",
                "has_sig": false,
                "md5_digest": "f40394b5c017e670c1f36edd32273837",
                "packagetype": "bdist_wheel",
                "python_version": "py3",
                "requires_python": ">=3.7",
                "size": 65582,
                "upload_time": "2022-10-26T15:14:28",
                "upload_time_iso_8601": "2022-10-26T15:14:28.591451Z",
                "url": "https://files.pythonhosted.org/packages/a8/79/c97806f56aa45d7d71e42871cd6bff1a8875e089a2947b662b3da937e45c/wf_dagger-0.1.4-py3-none-any.whl",
                "yanked": false,
                "yanked_reason": null
            },
            {
                "comment_text": "",
                "digests": {
                    "md5": "03f0d51b54103e6b0294b77a45b314e6",
                    "sha256": "08680dfc0996680205fc78ba51c7736a3533b8fa19d64ac46b605b51e14eeb49"
                },
                "downloads": -1,
                "filename": "wf-dagger-0.1.4.tar.gz",
                "has_sig": false,
                "md5_digest": "03f0d51b54103e6b0294b77a45b314e6",
                "packagetype": "sdist",
                "python_version": "source",
                "requires_python": ">=3.7",
                "size": 60550,
                "upload_time": "2022-10-26T15:14:30",
                "upload_time_iso_8601": "2022-10-26T15:14:30.158085Z",
                "url": "https://files.pythonhosted.org/packages/13/08/6208fcdedef6e5d97ff9f126e4b11aac2cd972db3791b40b2f9d5c15b26a/wf-dagger-0.1.4.tar.gz",
                "yanked": false,
                "yanked_reason": null
            }
        ],
        "vulnerabilities": []
    }
}