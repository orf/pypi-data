{
    "1.0.1": {
        "info": {
            "author": "",
            "author_email": "Stanislav Tsaplev <stanislav.tsaplev@gmail.com>",
            "bugtrack_url": null,
            "classifiers": [
                "License :: OSI Approved :: MIT License",
                "Operating System :: OS Independent",
                "Programming Language :: Python :: 3"
            ],
            "description": "# SuperExpressive\n\nThis package is the Python port of the following JavaScript library: https://github.com/francisrstokes/super-expressive\n<br/>\n\n## Installation\n```\npip install super_expressive\n```\n<br/>\n\n## Example\n\nThe following example recognises and captures the value of a 16-bit hexadecimal number like `0xC0D3`.\n\n```py\nfrom super_expressive import SuperExpressive\n\n\nmy_regex = (\n    SuperExpressive()\n        .start_of_input\n        .optional.string('0x')\n        .capture\n            .exactly(4).any_of\n                .range('a', 'f')\n                .range('a', 'f')\n                .range('0', '9')\n            .end()\n        .end()\n        .end_of_input\n    .to_regex()\n)\n\n// Produces the following regular expression:\nre.compile('^(?:0x)?([A-Fa-f0-9]{4})$')\n```\n<br/>\n\n## API\n**Legend:**\n\n    [\u2013] original, not supported\n    [=] original, supported\n    [\u2248] original, supported (slightly different syntax)\n    [+] new, added\n\n---\n\n[\u2013] **`.allow_multiple_matches`**\n\nAPI compatibility stub.\n\nHas been intended to use the `g` flag on the regular expression, which indicates that it should match multiple values when run on a string.\n\nPython does not have a `g` flag, it implements this behavior at the pattern object method level.\n\n**Example:**\n```py\npattern = (\n    SuperExpressive()\n        .allow_multiple_matches\n        .string(\"hello\")\n    .to_regex_string()\n)\n# 'hello'\n```\n\n---\n\n[\u2013] **`.sticky`**\n\nAPI compatibility stub.\n\nHas been intended to use the y flag on the regular expression, which indicates that it should create a stateful regular expression that can be resumed from the last match.\n\nPython does not have a `y` flag.\n\n**Example:**\n```py\npattern = (\n    SuperExpressive()\n        .sticky\n        .string(\"hello\")\n    .to_regex_string()\n)\n# 'hello'\n```\n\n---\n\n[+] **`.ascii`**\n\nAssumes ascii 'locale'.\n\nUses the `a` flag on the regular expression, which indicates that it should use only ascii characters matching.\n\nYou could use this flag when necessary, considering the default mode in Python 3 is the unicode mode.\n\n**Example:**\n```py\npattern = (\n    SuperExpressive()\n        .ascii\n        .string(\"hello\")\n    .to_regex_string()\n)\n# '(?a)hello'\n```\n---\n\n[=] **`.case_insensitive`**\n- `.caseInsensitive`\n- `.ignore_case`\n- `.ignoreCase`\n\nIgnores case.\n\nUses the `i` flag on the regular expression, which indicates that it should treat ignore the uppercase/lowercase distinction when matching.\n\n*Warning: this produces a different regex syntax than the original one (Python, not JS).*\n\n**Example:**\n```py\npattern = (\n    SuperExpressive()\n        .case_insensitive\n        .string(\"hello\")\n    .to_regex_string()\n)\n# '(?i)hello'\n```\n---\n\n[=] **`.line_by_line`**\n- `.lineByLine`\n- `.multiline`\n\nMakes anchors look for newline.\n\nUses the `m` flag on the regular expression, which indicates that it should treat the `.start_of_input` and `.end_of_input` markers as the start and end of lines.\n\n*Warning: this produces a different regex syntax than the original one (Python, not JS).*\n\n**Example:**\n```py\npattern = (\n    SuperExpressive()\n        .line_by_line\n        .string(\"hello\")\n    .to_regex_string()\n)\n# '(?m)hello'\n```\n---\n\n[=] **`.single_line`**\n- `.singleLine`\n- `.dotall`\n\nMakes dot match newline.\n\nUses the `s` flag on the regular expression, which indicates \nthat the input should be treated as a single line, where the `.start_of_input` and `.end_of_input` markers explicitly mark the start and end of input, and `.any_char` also matches newlines.\n\n*Warning: this produces a different regex syntax than the original one (Python, not JS).*\n\n**Example:**\n```py\npattern = (\n    SuperExpressive()\n        .single_line\n        .string(\"hello\")\n    .to_regex_string()\n)\n# '(?s)hello'\n```\n---\n\n[=] **`.unicode`**\n\nAssumes unicode 'locale'.\n\nUses the `u` flag on the regular expression, which indicates \nthat it should use full unicode matching.\n\nSince unicode mode is the default in Python 3, there is no need for using this flag\n(but you can use `.ascii` instead when necessary).\n\n*Warning: this produces a different regex syntax than the original one (Python, not JS).*\n\n**Example:**\n```py\npattern = (\n    SuperExpressive()\n        .unicode\n        .string(\"hello\")\n    .to_regex_string()\n)\n# '(?u)hello'\n```\n---\n\n[=] **`.any_char`**\n- `.anyChar`\n\nMatches any single character.\n\nWhen combined with `.single_line` (aka `.dotall`), it also matches newlines.\n\n**Example:**\n```py\npattern = (\n    SuperExpressive()\n        .any_char\n    .to_regex_string()\n)\n# '.'\n```\n---\n\n[=] **`.whitespace_char`**\n- `.whitespaceChar`\n- `.whitespace`\n\nMatches any whitespace character, including the special whitespace characters: `\\r`, `\\n`, `\\t`, `\\f`, `\\v`.\n\n**Example:**\n```py\npattern = (\n    SuperExpressive()\n        .whitespace_char\n    .to_regex_string()\n)\n# '\\\\s'\n```\n---\n\n[=] **`.non_whitespace_char`**\n- `.nonWhitespaceChar`\n- `.non_whitespace`\n- `.nonWhitespace`\n\nMatches any non-whitespace character, excluding also the special whitespace characters: `\\r`, `\\n`, `\\t`, `\\f`, `\\v`.\n\n**Example:**\n```py\npattern = (\n    SuperExpressive()\n        .non_whitespace_char\n    .to_regex_string()\n)\n# '\\\\S'\n```\n---\n\n[=] **`.digit`**\n\nMatches any digit from `0-9`.\n\n**Example:**\n```py\npattern = (\n    SuperExpressive()\n        .digit\n    .to_regex_string()\n)\n# '\\\\d'\n```\n---\n\n[=] **`.non_digit`**\n- `.nonDigit`\n\nMatches any non-digit.\n\n**Example:**\n```py\npattern = (\n    SuperExpressive()\n        .non_digit\n    .to_regex_string()\n)\n# '\\\\D'\n```\n---\n\n[=] **`.word`**\n- `.word_char`\n- `.wordChar`\n\nMatches any alpha-numeric (`a-z`, `A-Z`, `0-9`) characters, as well as `_`.\n\n**Example:**\n```py\npattern = (\n    SuperExpressive()\n        .word\n    .to_regex_string()\n)\n# '\\\\w'\n```\n---\n\n[=] **`.non_word`**\n- `.nonWord`\n- `.non_word_char`\n- `.nonWordChar`\n\nMatches any non alpha-numeric (`a-z`, `A-Z`, `0-9`) characters, excluding `_` as well.\n\n**Example:**\n```py\npattern = (\n    SuperExpressive()\n        .non_word\n    .to_regex_string()\n)\n# '\\\\W'\n```\n---\n\n[=] **`.word_boundary`**\n- `.wordBoundary`\n\nMatches (without consuming any characters) immediately between a character matched by `.word` and a character not matched by `.word` (in either order).\n\n**Example:**\n```py\npattern = (\n    SuperExpressive()\n        .word_boundary\n    .to_regex_string()\n)\n# '\\\\b'\n```\n---\n\n[=] **`.non_word_boundary`**\n- `.nonWordBoundary`\n\nMatches (without consuming any characters) at the position between two characters matched by `.word`.\n\n**Example:**\n```py\npattern = (\n    SuperExpressive()\n        .non_word_boundary\n    .to_regex_string()\n)\n# '\\\\B'\n```\n---\n\n[=] **`.new_line`**\n- `.newLine`\n\nMatches a `\\n` character.\n\n**Example:**\n```py\npattern = (\n    SuperExpressive()\n        .new_line\n    .to_regex_string()\n)\n# '\\\\n'\n```\n---\n\n[=] **`.carriage_return`**\n- `.carriageReturn`\n\nMatches a `\\r` character.\n\n**Example:**\n```py\npattern = (\n    SuperExpressive()\n        .new_line\n    .to_regex_string()\n)\n# '\\\\r'\n```\n---\n\n[=] **`.tab`**\n\nMatches a `\\t` character.\n\n**Example:**\n```py\npattern = (\n    SuperExpressive()\n        .tab\n    .to_regex_string()\n)\n# '\\\\t'\n```\n---\n\n[=] **`.null_byte`**\n- `.nullByte`\n\nMatches a `\\\\u0000` character (ASCII 0).\n\n**Example:**\n```py\npattern = (\n    SuperExpressive()\n        .null_byte\n    .to_regex_string()\n)\n# '\\\\0'\n```\n---\n\n[=] **`.char(c: str)`**\n\nMatches the exact (single) character `c`.\n\n**Example:**\n```py\npattern = (\n    SuperExpressive()\n        .char('.')\n    .to_regex_string()\n)\n# '\\\\.'\n```\n---\n\n[=] **`.string(s: str)`**\n\nMatches the exact string (the sequential characters) `s`.\n\n**Example:**\n```py\npattern = (\n    SuperExpressive()\n        .string(\"1+1\")\n    .to_regex_string()\n)\n# '1\\\\+1'\n```\n---\n\n[=] **`.range(a: str|int, b: str|int)`**\n\nMatches any character that falls between `a` and `b`.\n\nOrdering is defined by a characters ASCII or unicode value.\n\n**Example:**\n```py\npattern = (\n    SuperExpressive()\n        .range(0, 9)\n        .range('a', 'f')\n    .to_regex_string()\n)\n# '[0-9][a-f]'\n```\n---\n\n[=] **`.any_of`**\n- `.anyOf`\n\nMatches a choice between specified elements.\n\nNeeds to be finalised with `.end()` or `.over`.\n\n**Example:**\n```py\npattern = (\n    SuperExpressive()\n        .any_of\n            .char('-')\n            .range(0, 9)\n            .string(\"no\")\n        .end()\n    .to_regex_string()\n)\n# '(?:no|[\\\\-0-9])'\n```\n---\n\n[=] **`.group`**\n\nCreates a non-capturing group of the proceeding elements.\n\nNeeds to be finalised with `.end()` or `.over`.\n\n**Example:**\n```py\npattern = (\n    SuperExpressive()\n        .optional.group\n            .char('-')\n            .range(0, 9)\n            .string(\"no\")\n        .end()\n    .to_regex_string()\n)\n# '(?:\\\\-[0-9]no)?'\n```\n---\n\n[=] **`.assert_ahead`**\n- `.assertAhead`\n\nAssert that the proceeding elements are found without consuming them.\n\nNeeds to be finalised with `.end()` or `.over`.\n\n**Example:**\n```py\npattern = (\n    SuperExpressive()\n        .assert_ahead\n            .range('a', 'f')\n        .end()\n        .range('a', 'z')\n    .to_regex_string()\n)\n# '(?=[a-f])[a-z]'\n```\n---\n\n[=] **`.assert_behind`**\n- `.assertBehind`\n\nAssert that the elements contained within are found immediately before this point in the string.\n\nNeeds to be finalised with `.end()` or `.over`.\n\n**Example:**\n```py\npattern = (\n    SuperExpressive()\n        .assert_behind\n            .range('a', 'f')\n        .end()\n        .range('a', 'z')\n    .to_regex_string()\n)\n# '(?<=[a-f])[a-z]'\n```\n---\n\n[=] **`.assert_not_ahead`**\n- `.assertNotAhead`\n\nAssert that the proceeding elements are not found without consuming them. \n\nNeeds to be finalised with `.end()` or `.over`.\n\n**Example:**\n```py\npattern = (\n    SuperExpressive()\n        .assert_not_ahead\n            .range('a', 'f')\n        .end()\n        .range('a', 'z')\n    .to_regex_string()\n)\n# '(?![a-f])[a-z]'\n```\n---\n\n[=] **`.assert_not_behind`**\n- `.assertNotBehind`\n\nAssert that the elements contained within are not found immediately before this point in the string.\n\nNeeds to be finalised with `.end()` or `.over`.\n\n**Example:**\n```py\npattern = (\n    SuperExpressive()\n        .assert_not_behind\n            .range('a', 'f')\n        .end()\n        .range('a', 'z')\n    .to_regex_string()\n)\n# '(?<![a-f])[a-z]'\n```\n---\n\n[=] **`.any_of_chars(chars: str)`**\n- `.anyOfChars(chars: str)`\n\nMatches any of the characters in the provided string `chars`.\n\n**Example:**\n```py\npattern = (\n    SuperExpressive()\n        .any_of_chars(\"aeiou\")\n        .any_of_chars(\"+-*/=\")\n    .to_regex_string()\n)\n# '[aeiou][\\\\+\\\\-\\\\*/=]'\n```\n---\n\n[=] **`.anything_but_chars(chars: str)`**\n- `.anythingButChars(chars: str)`\n\nMatches any character, except any of those in the provided string `chars`.\n\n**Example:**\n```py\npattern = (\n    SuperExpressive()\n        .anything_but_chars(\"aeiou\")\n        .anything_but_chars(\"+-*/=\")\n    .to_regex_string()\n)\n# '[^aeiou][^\\\\+\\\\-\\\\*/=]'\n```\n---\n\n[=] **`.anything_but_range(a: str, b: str)`**\n- `.anythingButRange(a: str, b: str)`\n\nMatches any character, except those that would be captured by the range specified by `a` and `b`.\n\n**Example:**\n```py\npattern = (\n    SuperExpressive()\n        .anything_but_range(0, 9)\n        .anything_but_range('a', 'f')\n    .to_regex_string()\n)\n# '[^0-9][^a-f]'\n```\n---\n\n[=] **`.anything_but_string(s: str)`**\n- `.anythingButString(s: str)`\n\nMatches any string the same length as `s`, except the `s` itself (the sequential characters in `s`).\n\n**Example:**\n```py\npattern = (\n    SuperExpressive()\n        .anything_but_string(\"aeiou\")\n        .anything_but_string(\"+-*/=\")\n    .to_regex_string()\n)\n# '(?:(?!aeiou).{5})(?:(?!\\\\+\\\\-\\\\*/=).{5})'\n```\n---\n\n[=] **`.capture`**\n\nCreates a capture group for the proceeding elements.\n\nNeeds to be finalised with `.end()` or `.over`.\n\nCan be later referenced with `.backreference(index)`.\n\n**Example:**\n```py\npattern = (\n    SuperExpressive()\n        .capture\n            .string(\"prefix:\")\n            .range(0, 9)\n            .char(\"-\")\n            .range('a', 'f')\n        .end()\n    .to_regex_string()\n)\n# '(prefix:[0-9]\\\\-[a-f])'\n```\n---\n\n[=] **`.named_capture(name: str)`**\n- `.namedCapture(name: str)`\n\nCreates a named capture group for the proceeding elements.\n\nNeeds to be finalised with `.end()` or `.over`.\n\nCan be later referenced with `.named_backreference(name)` or `.backreference(index)`.\n\n*Warning: this produces a different regex syntax than the original one (Python, not JS).*\n\n**Example:**\n```py\npattern = (\n    SuperExpressive()\n        .named_capture(\"some_stuff\")\n            .string(\"prefix:\")\n            .range(0, 9)\n            .char(\"-\")\n            .range('a', 'f')\n        .end()\n    .to_regex_string()\n)\n# '(?P<some_stuff>prefix:[0-9]\\\\-[a-f])'\n```\n---\n\n[=] **`.backreference(index: int)`**\n- `.backref(index: int)`\n\nMatches exactly what was previously matched by a `.capture` or `.named_capture` using a positional index.\n\nNote that regex indices start at 1, so the first capture group has index 1.\n\n*Warning: this produces a different regex syntax than the original one (Python, not JS).*\n\n**Example:**\n```py\npattern = (\n    SuperExpressive()\n        .capture\n            .string(\"prefix:\")\n            .range(0, 9)\n            .char(\"-\")\n            .range('a', 'f')\n        .end()\n        .string(\"something else\")\n        .backreference(1)\n    .to_regex_string()\n)\n# '(prefix:[0-9]\\\\-[a-f])something else\\\\1'\n```\n---\n\n[=] **`.named_backreference(name: str)`**\n- `.namedBackreference(name: str)`\n- `.named_backref(name: str)`\n- `.namedBackref(name: str)`\n\nMatches exactly what was previously matched by a `.named_capture`.\n\n*Warning: this produces a different regex syntax than the original one (Python, not JS).*\n\n**Example:**\n```py\npattern = (\n    SuperExpressive()\n        .named_capture(\"some_stuff\")\n            .string(\"prefix:\")\n            .range(0, 9)\n            .char(\"-\")\n            .range('a', 'f')\n        .end()\n        .string(\"something else\")\n        .named_backreference(\"some_stuff\")\n    .to_regex_string()\n)\n# '(?P<some_stuff>prefix:[0-9]\\\\-[a-f])something else(?P=some_stuff)'\n```\n---\n\n[=] **`.optional`**\n\nAssert that the proceeding element may or may not be matched.\n\n**Example:**\n```py\npattern = (\n    SuperExpressive()\n        .optional.digit\n    .to_regex_string()\n)\n# '\\d?'\n```\n---\n\n[=] **`.zero_or_more`**\n- `.zeroOrMore`\n\nAssert that the proceeding element may not be matched, or may be matched multiple times.\n\n**Example:**\n```py\npattern = (\n    SuperExpressive()\n        .zero_or_more.digit\n    .to_regex_string()\n)\n# '\\d*'\n```\n---\n\n[=] **`.zero_or_more_lazy`**\n- `.zeroOrMoreLazy`\n\nAssert that the proceeding element may not be matched, or may be matched multiple times, but as few times as possible.\n\n**Example:**\n```py\npattern = (\n    SuperExpressive()\n        .zero_or_more_lazy.digit\n    .to_regex_string()\n)\n# '\\d*?'\n```        \n---\n\n[=] **`.one_or_more`**\n- `.oneOrMore`\n\nAssert that the proceeding element may be matched once, or may be matched multiple times.\n\n**Example:**\n```py\npattern = (\n    SuperExpressive()\n        .one_or_more.digit\n    .to_regex_string()\n)\n# '\\d+'\n```\n---\n\n[=] **`.one_or_more_lazy`**\n- `.oneOrMoreLazy`\n\nAssert that the proceeding element may be matched once, or may be matched multiple times, but as few times as possible.\n\n**Example:**\n```py\npattern = (\n    SuperExpressive()\n        .one_or_more_lazy.digit\n    .to_regex_string()\n)\n# '\\d+?'\n```\n---\n\n[=] **`.exactly(n: int)`**\n\nAssert that the proceeding element will be matched exactly `n` times.\n\n**Example:**\n```py\npattern = (\n    SuperExpressive()\n        .exactly(5).digit\n    .to_regex_string()\n)\n# '\\d{5}'\n```\n---\n\n[=] **`.at_least(n: int)`**\n- `.atLeast(n: int)`\n\nAssert that the proceeding element will be matched at least `n` times.\n\n**Example:**\n```py\npattern = (\n    SuperExpressive()\n        .at_least(5).digit\n    .to_regex_string()\n)\n# '\\d{5,}'\n```\n---\n\n[=] **`.between(x: int, y: int)`**\n\nAssert that the proceeding element will be matched somewhere between `x` and `y` times.\n\n**Example:**\n```py\npattern = (\n    SuperExpressive()\n        .between(3, 5).digit\n    .to_regex_string()\n)\n# '\\d{3,5}'\n```\n---\n\n[=] **`.between_lazy(x: int, y: int)`**\n- `.betweenLazy(x: int, y: int)`\n\nAssert that the proceeding element will be matched somewhere between `x` and `y` times, but as few times as possible.\n\n**Example:**\n```py\npattern = (\n    SuperExpressive()\n        .between(3, 5).digit\n    .to_regex_string()\n)\n# '\\d{3,5}?'\n```\n---\n\n[+] **`.start_of_string`**\n- `.startOfString`\n\nAlways assert the start of input string, regardless of using multiline mode (aka `.line_by_line`).\n\n**Example:**\n```py\npattern = (\n    SuperExpressive()\n        .start_of_string\n        .string(\"hello\")\n    .to_regex_string()\n)\n# '\\Ahello'\n```\n---\n\n[+] **`.end_of_string`**\n- `.endOfString`\n\nAlways assert the end of input string, regardless of using multiline mode (aka `.line_by_line`).\n\n**Example:**\n```py\npattern = (\n    SuperExpressive()\n        .string(\"hello\")\n        .end_of_string\n    .to_regex_string()\n)\n# 'hello\\Z'\n```\n---\n\n[=] **`.start_of_input`**\n- `.startOfInput`\n\nAssert the start of input string, or the start of a line when multiline mode ( aka `.line_by_line`) is used.\n\n**Example:**\n```py\npattern = (\n    SuperExpressive()\n        .start_of_input\n        .string(\"hello\")\n    .to_regex_string()\n)\n# '^hello'\n```\n---\n\n[=] **`.end_of_input`**\n- `.endOfInput`\n\nAssert the end of input string, or the end of a line when multiline mode (aka `.line_by_line`) is used.\n\n**Example:**\n```py\npattern = (\n    SuperExpressive()\n        .string(\"hello\")\n        .end_of_input\n    .to_regex_string()\n)\n# 'hello$'\n```\n---\n\n[=] **`.end()`**\n\nCloses the context of `.any_of`, `.group`, `.capture`, or `.assert_*`.\n\nRequires parentheses when invoked (see also `.over`).\n\n**Example:**\n```py\npattern = (\n    SuperExpressive()\n        .string(\"prefix:\")\n        .capture\n            .anyOf\n                .range(0, 9)\n                .char(\"-\")\n                .range('a', 'f')\n                .string(\"something else\")\n            .end()\n        .end()\n    .to_regex_string()\n)\n# 'prefix:((?:something else|[0-9\\\\-a-f]))'\n```\n---\n\n[+] **`.over`**\n\nCloses the context of `.any_of`, `.group`, `.capture` or `.assert_*`.\n\nAlias for `.end()`, but doesn't require parentheses.\n\n**Example:**\n```py\npattern = (\n    SuperExpressive()\n        .string(\"prefix:\")\n        .capture\n            .anyOf\n                .range(0, 9)\n                .char(\"-\")\n                .range('a', 'f')\n                .string(\"something else\")\n            .over\n        .over\n    .to_regex_string()\n)\n# 'prefix:((?:something else|[0-9\\\\-a-f]))'\n```\n---\n\n[\u2248] **`.subexpression(expr: SuperExpressive, *, namespace: str = \"\", ignore_flags: bool = True, ignore_start_and_end: bool = True)`**\n- `.sub(expr, *, namespace=\"\", ignore_flags=True, ignore_start_and_end=True)`\n\nMatches another `SuperExpressive` instance inline. \n\nCan be used to create libraries, or to modularise you code.\n\n**Example:**\n```py\nhex_number = SuperExpressive().one_or_more.any_of.range(0, 9).range('A', 'F').end()\n\npattern = (\n    SuperExpressive()\n        .subexpression(hex_number)\n        .one_or_more.whitespace\n        .optional.subexpression(hex_number)\n    .to_regex_string()\n)\n# '[0-9A-F]+\\\\s+(?:[0-9A-F]+)?'\n```\n\nBy default, flags and start/end of input markers are ignored, but can be explicitly turned on in the keyword parameters.\n- `ignore_flags`: If set to true, any flags this subexpression specifies \nshould be disregarded (default is `True`).\n\n**Example:**\n```py\nhex_number = (\n    SuperExpressive()\n        .case_insensitive\n        .one_or_more.any_of\n            .range(0, 9)\n            .range('A', 'F')\n        .end()\n)\n\npattern1 = (\n    SuperExpressive()\n        .subexpression(hex_number)\n        .one_or_more.whitespace\n        .optional.subexpression(hex_number)\n    .to_regex_string()\n)\n# '[0-9A-F]+\\\\s+(?:[0-9A-F]+)?'\n\npattern2 = (\n    SuperExpressive()\n        .subexpression(hex_number, ignore_flags=False)\n        .one_or_more.whitespace\n        .optional.subexpression(hex_number)\n    .to_regex_string()\n)\n# '(?i)[0-9A-F]+\\\\s+(?:[0-9A-F]+)?'\n```\n\n- `ignore_start_and_end`: If set to true, any `.start_of_input` / `.end_of_input` \nasserted in this subexpression specifies should be disregarded (default is `True`).\n\n**Example:**\n```py\nhex_number = (\n    SuperExpressive()\n        .start_of_input\n        .one_or_more.any_of\n            .range(0, 9)\n            .range('A', 'F')\n        .end()\n        .end_of_input\n)\n\npattern1 = (\n    SuperExpressive()\n        .subexpression(hex_number)\n        .one_or_more.whitespace\n        .optional.subexpression(hex_number)\n    .to_regex_string()\n)\n# '[0-9A-F]+\\\\s+(?:[0-9A-F]+)?'\n\npattern2 = (\n    SuperExpressive()\n        .subexpression(hex_number)\n        .one_or_more.whitespace\n        .optional.subexpression(hex_number, ignore_start_and_end=False)\n    .to_regex_string()\n)\n# '[0-9A-F]+\\\\s+(?:^[0-9A-F]+$)?'\n```\n\n- `namespace`: A string namespace to use on all named capture groups in the subexpression, to avoid naming collisions with your own named groups (default is `\"\"`).\n\n**Example:**\n```py\nhex_number = (\n    SuperExpressive()\n        .named_capture(\"hex\")\n            .one_or_more.any_of\n                .range(0, 9)\n                .range('A', 'F')\n            .end()\n        .end()\n        .named_backreference(\"hex\")\n)\n#'(?P<hex>[0-9A-F]+)(?P=hex)'\n\npattern1 = (\n    SuperExpressive()\n        .subexpression(hex_number)\n        .one_or_more.whitespace\n        .optional.subexpression(hex_number, namespace=\"snd_\")\n    .to_regex_string()\n)\n# '(?P<hex>[0-9A-F]+)(?P=hex)\\\\s+(?:(?P<snd_hex>[0-9A-F]+)(?P=snd_hex))?'\n\npattern2 = (\n    SuperExpressive()\n        .named_capture(\"hex\")\n            .subexpression(hex_number, namespace=\"sub1_\")\n            .one_or_more.whitespace\n            .optional.subexpression(hex_number, namespace=\"sub2_\")\n        .end()\n        .named_backreference(\"hex\")\n    .to_regex_string()\n)\n# '(?P<hex>(?P<sub1_hex>[0-9A-F]+)(?P=sub1_hex)\\\\s+(?:(?P<sub2_hex>[0-9A-F]+)(?P=sub2_hex))?)(?P=hex)'\n\n```\n---\n\n[=] **`.to_regex()`**\n- `.toRegex()`\n\nOutputs the regular expression pattern that this `SuperExpression` models.\n\n---\n\n[=] **`.to_regex_string()`**\n- `.toRegexString()`\n- `.to_string()`\n- `.toString()`\n\nOutputs a string representation of the regular expression that this `SuperExpression` models.\n",
            "description_content_type": "text/markdown",
            "docs_url": null,
            "download_url": "",
            "downloads": {
                "last_day": -1,
                "last_month": -1,
                "last_week": -1
            },
            "home_page": "",
            "keywords": "",
            "license": "",
            "maintainer": "",
            "maintainer_email": "",
            "name": "super-expressive",
            "package_url": "https://pypi.org/project/super-expressive/",
            "platform": null,
            "project_url": "https://pypi.org/project/super-expressive/",
            "project_urls": {
                "bugtracker": "https://github.com/stanislav-tsaplev/super_expressive/issues",
                "documentation": "https://github.com/stanislav-tsaplev/super_expressive/README.md",
                "homepage": "https://github.com/stanislav-tsaplev/super_expressive",
                "repository": "https://github.com/stanislav-tsaplev/super_expressive"
            },
            "release_url": "https://pypi.org/project/super-expressive/1.0.1/",
            "requires_dist": null,
            "requires_python": ">=3.10",
            "summary": "Python port of the JS library: https://github.com/francisrstokes/super-expressive",
            "version": "1.0.1",
            "yanked": false,
            "yanked_reason": null
        },
        "last_serial": 16089219,
        "urls": [
            {
                "comment_text": "",
                "digests": {
                    "md5": "e65ad933869d306b651dc26dcd24d154",
                    "sha256": "ba74b4a2f8f9802a4c577cdd3934912fd740e6033472c5b18b592a6bc2115a3f"
                },
                "downloads": -1,
                "filename": "super_expressive-1.0.1-py3-none-any.whl",
                "has_sig": false,
                "md5_digest": "e65ad933869d306b651dc26dcd24d154",
                "packagetype": "bdist_wheel",
                "python_version": "py3",
                "requires_python": ">=3.10",
                "size": 14439,
                "upload_time": "2022-12-13T17:28:44",
                "upload_time_iso_8601": "2022-12-13T17:28:44.903638Z",
                "url": "https://files.pythonhosted.org/packages/db/c6/1f195a780cf40e93a322d49f3b6ac66f5b9a56280ccf5b28e51ee9433d93/super_expressive-1.0.1-py3-none-any.whl",
                "yanked": false,
                "yanked_reason": null
            },
            {
                "comment_text": "",
                "digests": {
                    "md5": "22f647b7731d003adc886846af6fc1f5",
                    "sha256": "4a3bd98e9d6774551c09a7ccb80e18bfa25e6158df68c664f9e0193b33395233"
                },
                "downloads": -1,
                "filename": "super_expressive-1.0.1.tar.gz",
                "has_sig": false,
                "md5_digest": "22f647b7731d003adc886846af6fc1f5",
                "packagetype": "sdist",
                "python_version": "source",
                "requires_python": ">=3.10",
                "size": 17908,
                "upload_time": "2022-12-13T17:28:47",
                "upload_time_iso_8601": "2022-12-13T17:28:47.784031Z",
                "url": "https://files.pythonhosted.org/packages/3e/e0/7f03eb01fa0a54d813f32efda143be766deb2d43d4dfdb8ce88bc038b053/super_expressive-1.0.1.tar.gz",
                "yanked": false,
                "yanked_reason": null
            }
        ],
        "vulnerabilities": []
    }
}