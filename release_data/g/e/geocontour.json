{
    "1.0.0": {
        "info": {
            "author": "Benjamin Krichman",
            "author_email": "benkrichman@gmail.com",
            "bugtrack_url": null,
            "classifiers": [
                "Intended Audience :: Science/Research",
                "License :: OSI Approved :: MIT License",
                "Programming Language :: Python :: 3",
                "Topic :: Scientific/Engineering",
                "Topic :: Scientific/Engineering :: Atmospheric Science",
                "Topic :: Scientific/Engineering :: Hydrology"
            ],
            "description": "<h1><img align=\"left\" src=\"https://github.com/benkrichman/geocontour/raw/main/images/icon_geocontour.png\" width=\"130\" height=\"130\">geocontour</h1>\n\nUtilities for masking, contour tracing, and geocontour construction for flux calculations from gridded geographic data.\n\n## Installation\n\n```bash\npip install geocontour\n```\n\nor\n\n```bash\npip install git+https://github.com/benkrichman/geocontour.git@main\n```\n\nTo run a full test of internal functions (minus cartopy features):\n\n```python\ngeocontour.tests.full()\n```\n\n## Example Use Case\n\n\\*to reconstruct these examples use (or view)\n```python\ngeocontour.examples.small()\ngeocontour.examples.large()\n```\n\n### mask search\n\nGiven a series of lat/lon points constituting a geographical boundary, and a set of gridded data on a lat/lon grid, find an appropriate mask to select gridded data within the boundary:\n\nUse the 'area' approach to mask calculation, defaulting to selection of all cells for which 50% or greater falls withing the boundary. Note that boundary falls outside gridded data bounds at some points.\n```python\nmask=geocontour.masksearch.area(latitudes,longitudes,boundary)\ngeocontour.output.plot(latitudes,longitudes,boundary=boundary,mask=mask,title='Example Mask and Boundary',outname='example_small_boundary+mask',outdpi='indep')\n```\n\n<img src=https://github.com/benkrichman/geocontour/raw/main/images/example_small_boundary%2Bmask.png width=\"450\" height=\"450\">\n\n### contour trace\n\nGiven the previously calculated mask, find the outer edge using a contour tracing algorithm:\n\nUse the improved Pavlidis algorithm to trace the contour.\n```python\ncontour,contoursearch=geocontour.contourtrace.pavlidis_imp(mask,latitudes,longitudes)\ngeocontour.output.plot(latitudes,longitudes,mask=mask,contoursearch=contoursearch,title='Example Contour Search',outname='example_small_contoursearch',outdpi='indep')\ngeocontour.output.plot(latitudes,longitudes,contour=contour,cells='contour',title='Example Contour',outname='example_small_contour',outdpi='indep')\n```\n<p float=\"middle\">\n<img src=https://github.com/benkrichman/geocontour/raw/main/images/example_small_contoursearch.png width=\"400\" height=\"400\"/>\n<img src=https://github.com/benkrichman/geocontour/raw/main/images/example_small_contour.png width=\"400\" height=\"400\"/>\n</p>\n\n### construct geocontour\n\nGiven the previously calculated contour, construct the geocontour to determine contour segment lengths and outward normal vectors:\n\nUse the build function of geocontour to construct the geocontour. Note that the 'simplify' option is used, combining cells with multiple visits into single segments.\n```python\ngeocontour=geocontour.build(contour,latitudes,longitudes,simplify=True)\ngeocontour.output.plot(latitudes,longitudes,geocontour=geocontour,buffer='on',title='Example Geocontour',outname='example_small_geocontour',outdpi='indep')\n```\n\n<img src=https://github.com/benkrichman/geocontour/raw/main/images/example_small_geocontour.png width=\"450\" height=\"450\">\n\n### project geocontour against map features\n\nGiven a large geocontour (in this case, the Mississippi River Basin) project against natural features and political borders (requires cartopy):\n\n```python\ngeocontour.output.plot(latitudes,longitudes,geocontour=geocontour,title='Example Geocontour\\nMississippi River Basin',outname='example_large_geocontour+natfeat',features='natural')\n```\n<img src=https://github.com/benkrichman/geocontour/raw/main/images/example_large_geocontour%2Bnatfeat.png width=\"800\">\n\n```python\ngeocontour.output.plot(latitudes,longitudes,geocontour=geocontour,title='Example Geocontour\\nMississippi River Basin',outname='example_large_geocontour+bordfeat',features='borders')\n```\n\n<img src=https://github.com/benkrichman/geocontour/raw/main/images/example_large_geocontour%2Bbordfeat.png width=\"800\">\n\n## Features\n\n### Masks\n\nSelectable criteria for masks created from input boundary coordinates\n- cell center\n- area ratio\n- node ratio\n\nUseful mask operators\n- return mask connectivity (and null connectivity)\n- return mask edge cells\n- return mask vertex points\n\n### Contours\n\nImplements 4 existing algorithms for contour tracing, and two improvements on known algorithms\n- square tracing [^IPP][^Toussaint]\n- moore neighbor tracing [^IPP][^Toussaint]\n- improved moore neighbor tracing (capturing inside corners)\n- pavlidis tracing [^IPP][^Pavlidis]\n- improved pavlidis tracing (capturing inside corners)\n- fast representative tracing [^FRT]\n\nTuning of contours created from tracing input masks\n- trace direction\n- selectable and adjustable stopping conditions\n- automatic or manual selection of starting cell\n- selectable connection type (cell to cell or cell edge to cell center)\n- simplification of output contour (removal of repeating cells)\n- selectable contour closure\n- usable for an associated lat/lon grid or on a non-specified grid\n\nUseful contour operators\n- return full search path for a contour trace\n- return cell neighbors with connectivity and directional input\n- return starting cell for contour tracing and check that starting cells work for a given algorithm\n\n### Geocontours\n\nFrom an input contour, create a closed geospatial contour with calculated segment lengths and outward unit vectors (for example: useful in calculating flux across a bounding surface from a geospatial data set)\n\nOptions for tuning criteria of geocontours created from input contours\n- selectable connection type (cell to cell or cell edge to cell center)\n- optionally simplify geocontours at the cell level to shorten and improve compute times in practical applications\n\n### Visualization\n\nEasy and semi-automated plotting function for visualization of boundaries/masks/contours/contour searches/geocontours\n- buffers\n- grid overlay\n- mask cell visibility\n- directional indicators for contours and contour searches\n- outward unit vector indicators for geocontours\n- automatic calculation of feature size and output resolution\n- display of natural features or political boundaries (optional with cartopy installed)\n- selectable marker/line/arrow/cell size/color/style\n\n## Function Overview\n\n\\*to see full function documentation use\n```python\nhelp(geocontour.module.function)\n```\n\n### check\n\n#### geocontour.check.cdim()\nChecks an input dimension array for 1-dimensionality and regular spacing\n\n#### geocontour.check.cboundary()\nChecks a list of boundary points for 2-dimensionality and proper ordering\n\n#### geocontour.check.cmask()\nChecks a mask for correct data type and dimensionality, and size if optional latitudes and longitudes are provided\n\n#### geocontour.check.ccontour()\nCheck contour for repeating cells, closure, and connectivity, and latitude/longitude range if optional latitudes and longitudes are provided\n\n#### geocontour.check.cgeocontour()\nCheck geocontour for latitude/longitude range and dimension\n\n### grid\n\n#### geocontour.grid.spacing()\nReturns the grid spacing for a given input dimension\n\n#### geocontour.grid.lonlens()\nReturns the lengths of a degree (default) of longitude over a range of latitudes [^Osborne]\n\n#### geocontour.grid.latlens()\nReturns the grid lengths of a defined range of latitudes [^Osborne]\n\n#### geocontour.grid.lonlen()\nReturns the length of a degree of longitude at the input latitude [^Osborne]\n\n#### geocontour.grid.latlen()\nReturns the length of a degree of latitude at the input latitude [^Osborne]\n\n#### geocontour.grid.areas()\nReturns the cell areas of a grid defined by a range of latitudes and longitudes\n\n#### geocontour.grid.clonrng()\nReturns a descriptor for the range of a set of longitude points\n  * negative (-180 to 180), positive (0 to 360), or indeterminate (0 to 180) range\n\n#### geocontour.grid.clatdir()\nReturns a descriptor for the direction of a set of latitude points (increasing or decreasing)\n\n#### geocontour.grid.switchlon()\nReturns a set of longitude points switched in place between negative (-180 to 180) and positive (0 to 360)\n\n#### geocontour.grid.switchind()\nReturns the index where a longitude array either crosses 0 or 180 degrees\n\n### masksearch\n\n#### geocontour.masksearch.center()\nReturns a mask over a range of input latitudes and longitudes determined by an input boundary\n  - Critera for inclusion of a cell is whether the center of the cell falls within the boundary\n\n#### geocontour.masksearch.center2()\nReturns a mask over a range of input latitudes and longitudes determined by an input boundary\n  - Critera for inclusion of a cell is whether the center of the cell falls within the boundary\n  - Functionally matches geocontour.masksearch.center(), but utilizes matplotlib.path functions, which are probably optimized and thus is roughly 2.5\\*sqrt(N) faster for N points, though lacks a \"precision\" buffer input\n\n#### geocontour.masksearch.nodes()\nReturns a mask over a range of input latitudes and longitudes determined by an input boundary\n  - Critera for inclusion of a cell is whether a given number (default=2) of cell nodes (corners) fall within the boundary\n\n#### geocontour.masksearch.nodes2()\nReturns a mask over a range of input latitudes and longitudes determined by an input boundary\n  - Critera for inclusion of a cell is whether a given number (default=2) of cell nodes (corners) fall within the boundary \n  - Functionally matches geocontour.masksearch.nodes(), but utilizes matplotlib.path functions, though speed is similar to the shapely implementation\n\n#### geocontour.masksearch.area()\nReturns a mask over a range of input latitudes and longitudes determined by an input boundary\n  - Critera for inclusion of a cell is whether the area of the cell enclosed by the boundary is greater than some fraction (default=0.5) \n\n### maskutil\n\n#### geocontour.maskutil.bbox()\nChecks input dimensions (lat/lon) against input boundary and returns min/max indicies of bounding box\n\n#### geocontour.maskutil.edge()\nReturns a mask of only the edge cells, and if latitudes and longitudes are provided also returns an array of the edge cells\n\n#### geocontour.maskutil.vertex()\nReturns the vertex points of all cells in the input mask, and the vertex points of only the mask edge\n\n#### geocontour.maskutil.neighbors()\nReturns the neighbors of a cell, with selected connectivity and direction\n\n#### geocontour.maskutil.conn()\nReturns whether a mask or its inverse are connected\n\n### contourtrace\n\n#### geocontour.contourtrace.square()\nReturns the contour trace of a mask input using the square tracing algorithm [^IPP][^Toussaint]\n\n#### geocontour.contourtrace.moore()\nReturns the contour trace of a mask input using the Moore neighbor tracing algorithm [^IPP][^Toussaint]\n\n#### geocontour.contourtrace.moore_imp()\nReturns the contour trace of a mask input using an improved Moore neighbor tracing algorithm \n  - Captures inside corners missed by Moore neighbor tracing\n\n#### geocontour.contourtrace.pavlidis()\nReturns the contour trace of a mask input using the Pavlidis tracing algorithm [^IPP][^Pavlidis]\n\n#### geocontour.contourtrace.pavlidis_imp()\nReturns the contour trace of a mask input using an improved Pavlidis tracing algorithm\n  - Captures inside corners missed by Pavlidis tracing\n\n#### geocontour.contourtrace.TSR()\nReturns the contour trace of a mask input using two-step representative tracing [^FRT]\n\n### contourutil\n\n#### geocontour.contourutil.findstart()\nReturns a starting cell for a contour, given a mask and a search criteria\n\n#### geocontour.contourutil.parsestart()\nChecks start input for contour tracing\n  - Mainly used internally for contour trace functions\n\n#### geocontour.contourutil.setstop()\nReturns a stopping function for use in contour tracing while loop\n  - Mainly used internally for contour trace functions\n\n#### geocontour.contourutil.clean()\nReturns a cleaned contour that will pass checks\n  - Mainly used internally for contour trace functions\n\n### geocontour\n\n#### geocontour.build()\nReturns a geocontour from a contour input\n\n### output\n\n#### geocontour.output.plot()\nPlots any/all geocontour-created elements: boundary, mask, contour, contoursearch, geocontour, vertices\n\n#### geocontour.output.save()\nSaves any/all geocontour-created elements: boundary, mask, contour, contoursearch, geocontour, vertices\n\n### tests\n\n#### geocontour.tests.full()\nRuns all user-facing geocontour functions with test data, printing/saving results\n\n### examples\n\n#### geocontour.examples.small()\nRuns a small scale example of geocontour processing using mock data, saves resulting plots to run directory\n  - find mask using area criteria (0.5) and plot boundary/mask\n  - trace contour using improved pavlidis algorithm and plot resultant contour and contour search\n  - compute geocontour from contour and plot, using simplify option\n\n#### geocontour.examples.large()\nRuns a large scale example of geocontour processing using the Mississippi River Basin boundary, saves resulting plots to run directory\n  - find mask using area criteria (0.5) and plot boundary/mask\n  - trace contour using improved pavlidis algorithm and plot resultant contour and contour search\n  - compute geocontour from contour and plot, using simplify option\n  - plot geocontour with cartopy background options (borders and physical features) - will error and exit if cartopy not installed\n  - plots will be large (dpi is auto-calculated to create enough resolution to zoom in for diagnostic use - this setting can be changed for quick plotting)\n\n\n[^IPP]:Contour Tracing Algorithms, [Pattern Recognition Project](https://www.imageprocessingplace.com/downloads_V3/root_downloads/tutorials/contour_tracing_Abeer_George_Ghuneim/alg.html)\n[^Toussaint]:Grids Connectivity and Contour Tracing, [Lesson Notes](http://www-cgrl.cs.mcgill.ca/~godfried/teaching/mir-reading-assignments/Chapter-2-Grids-Connectivity-Contour-Tracing.pdf)\n[^Pavlidis]:Algorithms for Graphics and Image Processing, [doi:10.1007/978-3-642-93208-3](https://link.springer.com/book/10.1007/978-3-642-93208-3)\n[^FRT]:Fast Contour-Tracing Algorithm Based on a Pixel-Following Method for Image Sensors, [doi:10.3390/s16030353](https://www.mdpi.com/1424-8220/16/3/353)\n[^Kovalevsky]:Other Source to Note: [Vladimir Kovalevsky](http://www.kovalevsky.de/index.htm)\n[^Osborne]:The Mercator Projections [doi:10.5281/ZENODO.35392](https://zenodo.org/record/35392)\n",
            "description_content_type": "text/markdown",
            "docs_url": null,
            "download_url": "",
            "downloads": {
                "last_day": -1,
                "last_month": -1,
                "last_week": -1
            },
            "home_page": "https://github.com/benkrichman/geocontour",
            "keywords": "",
            "license": "MIT",
            "maintainer": "",
            "maintainer_email": "",
            "name": "geocontour",
            "package_url": "https://pypi.org/project/geocontour/",
            "platform": null,
            "project_url": "https://pypi.org/project/geocontour/",
            "project_urls": {
                "Homepage": "https://github.com/benkrichman/geocontour"
            },
            "release_url": "https://pypi.org/project/geocontour/1.0.0/",
            "requires_dist": [
                "numpy",
                "scipy",
                "matplotlib",
                "shapely",
                "datascale"
            ],
            "requires_python": "",
            "summary": "Functions for applying contour tracing to gridded data",
            "version": "1.0.0",
            "yanked": false,
            "yanked_reason": null
        },
        "last_serial": 16003487,
        "urls": [
            {
                "comment_text": "",
                "digests": {
                    "md5": "fef0171fed713719a081a91e70424735",
                    "sha256": "94e6b0484e2deaf86e71801f4988f3267f2003ac7e2214ab20950dec2f32ef35"
                },
                "downloads": -1,
                "filename": "geocontour-1.0.0-py3-none-any.whl",
                "has_sig": false,
                "md5_digest": "fef0171fed713719a081a91e70424735",
                "packagetype": "bdist_wheel",
                "python_version": "py3",
                "requires_python": null,
                "size": 83464,
                "upload_time": "2022-12-06T03:10:48",
                "upload_time_iso_8601": "2022-12-06T03:10:48.569795Z",
                "url": "https://files.pythonhosted.org/packages/b6/7e/d916a1af0dca14096f64d9f00ac4d2894c83abd8dcad3b5a86aeb16b1a29/geocontour-1.0.0-py3-none-any.whl",
                "yanked": false,
                "yanked_reason": null
            },
            {
                "comment_text": "",
                "digests": {
                    "md5": "1d147c912ab93d962d9db9be3f2dbd12",
                    "sha256": "a7fdc1f4d08e56c5d976d1fa81ee84e9c242a5084da7b8ef766c2dd33a77dcd1"
                },
                "downloads": -1,
                "filename": "geocontour-1.0.0.tar.gz",
                "has_sig": false,
                "md5_digest": "1d147c912ab93d962d9db9be3f2dbd12",
                "packagetype": "sdist",
                "python_version": "source",
                "requires_python": null,
                "size": 10673959,
                "upload_time": "2022-12-06T03:10:51",
                "upload_time_iso_8601": "2022-12-06T03:10:51.507921Z",
                "url": "https://files.pythonhosted.org/packages/78/4e/f455d0940bd0ba91f5b6fb53dafb45273cca6e6c6cff875195fdd0ed5f37/geocontour-1.0.0.tar.gz",
                "yanked": false,
                "yanked_reason": null
            }
        ],
        "vulnerabilities": []
    }
}