{
    "0.1": {
        "info": {
            "author": "liuyancong",
            "author_email": "lyc456789@163.com",
            "bugtrack_url": null,
            "classifiers": [],
            "description": "safe_redis_lock\n~~~~~~~~~~~~~~~\n\n\u9879\u76ee\u63cf\u8ff0\n\n-  \u4e00\u4e2a\u5355\u673a\u7248\u7684redis\u5206\u5e03\u5f0f\u9501( A single redis distributed lock)\n-  \u9879\u76ee\u4f7f\u7528set\u547d\u4ee4\u6765\u52a0\u9501\n-  \u4f7f\u7528lua\u811a\u672c\u6765\u91ca\u653e\u9501\u4ee5\u4fdd\u8bc1\u539f\u5b50\u6027\n-  \u6ce8\u610f\u4e8b\u9879,\u4f20\u5165\u7684redis\u8fde\u63a5\u6c60\u9700\u8981\u5fc5\u987b\u53c2\u6570\u4e00\u6837,\u540c\u4e00\u4e2aredis\u6570\u636e\u5e93\n-  \u5f53block=False\u7684\u65f6\u5019\u5982\u679c\u6ca1\u6709\u83b7\u5f97\u9501\u5219\u8fd4\u56de\u4e00\u4e2aAcquireFailException\u5f02\u5e38\n-  acquire\u65b9\u6cd5\u8fd4\u56deTrue\u65f6\u5019\u5219\u8bf4\u660e\u83b7\u5f97\u9501\u6210\u529f\n\n\u4f7f\u7528\u65b9\u6cd5\u4e00\n\n-  \u88c5\u9970\u5668\u4f7f\u7528\u65b9\u6cd5\n\n-  \u65b0\u5efa\u4e00\u4e2aRedisLock\u5bf9\u8c61.\u4f7f\u7528RedisLock\u7684lock\u88c5\u9970\u5668\u6765\u88c5\u9970\u9700\u8981\u4fdd\u8bc1\u539f\u5b50\u6027\u7684\u51fd\u6570\n\n-  \u6ce8\u610f\u8be5\u51fd\u6570\u4e0d\u80fd\u662f\u963b\u585e\u7684\n\n-  .. code:: python\n\n      import threading\n      import redis\n\n      from safe_redis_lock import RedisLock\n      pool = redis.ConnectionPool(host='127.0.0.1', port=6379, password='lyc', db=0)\n\n      conn = redis.Redis(connection_pool=pool)\n\n      conn.set('producer', 10000)\n      redis_lock_ = RedisLock(lock_timeout=5, pool=pool, block=True)\n\n\n      @redis_lock_.lock\n      def consumer_pp(conn):\n          num = int(conn.get('producer'))\n          if num == 0:\n              return True\n          else:\n              print(f'we consumer one left --> {num}')\n              conn.set('producer', num - 1)\n\n\n      def consumer():\n          pool = redis.ConnectionPool(host='127.0.0.1', port=6379, password='lyc', db=0)\n          while True:\n              conn = redis.Redis(connection_pool=pool)\n              if consumer_pp(conn):\n                  break\n\n\n      def consumer_thread():\n          from threading import Thread\n          for i in range(20):\n              Thread(target=consumer).start()\n\n\n      consumer_thread()\n\n\u4f7f\u7528\u65b9\u6cd5\u4e8c:\n\n-\n\n.. code:: python\n\n   from safe_redis_lock import RedisLock,AcquireFailException\n\n   import redis\n   import threading\n   import os\n   pool = redis.ConnectionPool(host='127.0.0.1', port=6379, password='lyc', db=0)\n\n   conn = redis.Redis(connection_pool=pool)\n\n   conn.set('producer', 10000)\n   redis_lock_ = RedisLock(lock_timeout=5, pool=pool, block=True)\n\n\n   def consumer_pp(conn):\n       num = int(conn.get('producer'))\n       if num == 0:\n           return True\n       else:\n           print(f'we consumer one left --> {num}')\n           conn.set('producer', num - 1)\n\n\n   def consumer():\n       pool = redis.ConnectionPool(host='127.0.0.1', port=6379, password='lyc', db=0)\n       while True:\n           conn = redis.Redis(connection_pool=pool)\n           value = f'{threading.current_thread().ident}-{os.getpid()}'\n           get_lock = False\n           try:\n               get_lock = redis_lock_.acquire(value = value)\n               if get_lock:\n                   if consumer_pp(conn):\n                       break\n           except AcquireFailException:\n               print('can not get the lock')\n           finally:\n               if get_lock:\n                   redis_lock_.release(value)\n\n\n   def consumer_thread():\n       from threading import Thread\n       for i in range(20):\n           Thread(target=consumer).start()\n\n\n   consumer_thread()\n",
            "description_content_type": "",
            "docs_url": null,
            "download_url": "",
            "downloads": {
                "last_day": -1,
                "last_month": -1,
                "last_week": -1
            },
            "home_page": "https://gitee.com",
            "keywords": "",
            "license": "MIT",
            "maintainer": "",
            "maintainer_email": "",
            "name": "safe_redis_lock",
            "package_url": "https://pypi.org/project/safe_redis_lock/",
            "platform": "",
            "project_url": "https://pypi.org/project/safe_redis_lock/",
            "project_urls": {
                "Homepage": "https://gitee.com"
            },
            "release_url": "https://pypi.org/project/safe_redis_lock/0.1/",
            "requires_dist": null,
            "requires_python": "",
            "summary": "a safe redis lock in Single node Redis",
            "version": "0.1",
            "yanked": false,
            "yanked_reason": null
        },
        "last_serial": 6928565,
        "urls": [
            {
                "comment_text": "",
                "digests": {
                    "md5": "41c733239f12c8b0238c1cb82c77bcb4",
                    "sha256": "ed9b6545a0ea25762b48ef5a8f9848bd31221f140374aa6441828920c239453a"
                },
                "downloads": -1,
                "filename": "safe_redis_lock-0.1.tar.gz",
                "has_sig": false,
                "md5_digest": "41c733239f12c8b0238c1cb82c77bcb4",
                "packagetype": "sdist",
                "python_version": "source",
                "requires_python": null,
                "size": 3246,
                "upload_time": "2020-04-01T15:41:54",
                "upload_time_iso_8601": "2020-04-01T15:41:54.233543Z",
                "url": "https://files.pythonhosted.org/packages/68/5b/37f23c8537cbba196b3aa33bbd1b692e91435e12ec364aae8798bfe5bfe0/safe_redis_lock-0.1.tar.gz",
                "yanked": false,
                "yanked_reason": null
            }
        ],
        "vulnerabilities": []
    }
}