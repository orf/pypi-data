{
    "0.1.0": {
        "info": {
            "author": "Sander Schwenk-Nebbe",
            "author_email": "sandersn@econ.au.dk",
            "bugtrack_url": null,
            "classifiers": [],
            "description_content_type": "",
            "docs_url": null,
            "download_url": "",
            "downloads": {
                "last_day": -1,
                "last_month": -1,
                "last_week": -1
            },
            "home_page": "https://github.com/sander-sn/anatomy",
            "keywords": "",
            "license": "MIT",
            "maintainer": "",
            "maintainer_email": "",
            "name": "anatomy",
            "package_url": "https://pypi.org/project/anatomy/",
            "platform": null,
            "project_url": "https://pypi.org/project/anatomy/",
            "project_urls": {
                "Homepage": "https://github.com/sander-sn/anatomy"
            },
            "release_url": "https://pypi.org/project/anatomy/0.1.0/",
            "requires_dist": null,
            "requires_python": ">=3.9",
            "summary": "",
            "version": "0.1.0",
            "yanked": false,
            "yanked_reason": null
        },
        "last_serial": 15311199,
        "urls": [
            {
                "comment_text": "",
                "digests": {
                    "md5": "aec5eb9f4d8f956731416cf8fb7b150f",
                    "sha256": "32f72043bc91dbbe3a2ef4c60120571f58748bed943f528c4a956d8e5ee5de35"
                },
                "downloads": -1,
                "filename": "anatomy-0.1.0.tar.gz",
                "has_sig": false,
                "md5_digest": "aec5eb9f4d8f956731416cf8fb7b150f",
                "packagetype": "sdist",
                "python_version": "source",
                "requires_python": ">=3.9",
                "size": 8116,
                "upload_time": "2022-09-19T15:48:31",
                "upload_time_iso_8601": "2022-09-19T15:48:31.729154Z",
                "url": "https://files.pythonhosted.org/packages/3d/cd/1d02b1cb458bb2a305e38b11d13bea826010d40ead1f8ecd0249d9eb4ca5/anatomy-0.1.0.tar.gz",
                "yanked": false,
                "yanked_reason": null
            }
        ],
        "vulnerabilities": []
    },
    "0.1.1": {
        "info": {
            "author": "Sander Schwenk-Nebbe",
            "author_email": "sandersn@econ.au.dk",
            "bugtrack_url": null,
            "classifiers": [],
            "description_content_type": "text/markdown",
            "docs_url": null,
            "download_url": "",
            "downloads": {
                "last_day": -1,
                "last_month": -1,
                "last_week": -1
            },
            "home_page": "https://github.com/sander-sn/anatomy",
            "keywords": "",
            "license": "MIT",
            "maintainer": "",
            "maintainer_email": "",
            "name": "anatomy",
            "package_url": "https://pypi.org/project/anatomy/",
            "platform": null,
            "project_url": "https://pypi.org/project/anatomy/",
            "project_urls": {
                "Homepage": "https://github.com/sander-sn/anatomy"
            },
            "release_url": "https://pypi.org/project/anatomy/0.1.1/",
            "requires_dist": null,
            "requires_python": ">=3.9",
            "summary": "",
            "version": "0.1.1",
            "yanked": false,
            "yanked_reason": null
        },
        "last_serial": 15311199,
        "urls": [
            {
                "comment_text": "",
                "digests": {
                    "md5": "457b37c185686510c340f4c1381346db",
                    "sha256": "8915430e147a41a7f847664e198a7e42ef66be64b35b1d6ecf33949f70cd67e1"
                },
                "downloads": -1,
                "filename": "anatomy-0.1.1.tar.gz",
                "has_sig": false,
                "md5_digest": "457b37c185686510c340f4c1381346db",
                "packagetype": "sdist",
                "python_version": "source",
                "requires_python": ">=3.9",
                "size": 15593,
                "upload_time": "2022-09-27T13:39:59",
                "upload_time_iso_8601": "2022-09-27T13:39:59.158119Z",
                "url": "https://files.pythonhosted.org/packages/2d/26/d2e0e4421153b1402dcdd01ff545a39d7073f7c273cfb37fed707ebcc8d2/anatomy-0.1.1.tar.gz",
                "yanked": false,
                "yanked_reason": null
            }
        ],
        "vulnerabilities": []
    },
    "0.1.2": {
        "info": {
            "author": "Sander Schwenk-Nebbe",
            "author_email": "sandersn@econ.au.dk",
            "bugtrack_url": null,
            "classifiers": [],
            "description": "\n# Introduction\n\n*[to be added]*\n\n# Quickstart\n*If you haven't already, install the package via `pip install anatomy`, preferably in a new environment with Python 3.9.*\n\nThe anatomy package uses a simple workflow. An `Anatomy` object is initially estimated on your forecasting setup (using your data and your models), is then stored to disk, and can then be loaded at any future time without requiring re-estimation.\n\nAfter initial estimation, an `Anatomy` can anatomize:\n\n* forecasts produced by any combination of your models\n* your original forecasts\n* any loss or gain function applied to your forecasts\n* an arbitrary subset of your forecasts\n\nall of which requires *no additional computational time*.\n\n## General structure\nYou may already have trained your models before you create the `Anatomy`, and the aggregate of all your models at all periods may be too large to fit into your RAM. During estimation, the `Anatomy` will therefore ask you for the specific model and dataset it needs at a given iteration by calling your mapping function:\n\n    from anatomy import *\n    \n    def my_map(key: AnatomyModelProvider.PeriodKey) -> \\\n            AnatomyModelProvider.PeriodValue:  \n        \n        train, test, model = ...  # load from somewhere or generate here\n        \n        return AnatomyModelProvider.PeriodValue(train, test, model)\n\nYou wrap the mapping function in an `AnatomyModelProvider` alongside information about the forecasting application:\n \n    my_provider = AnatomyModelProvider(  \n        n_periods=..., n_features=..., model_names=[...],\n        y_name=..., provider_fn=my_map\n    )\n\nand finally create the `Anatomy`:\n\n    my_anatomy = Anatomy(provider=my_provider, n_iterations=...).precompute(  \n        n_jobs=16, save_path=\"my_anatomy.bin\"\n    )\n\nAfter running the above, the `Anatomy` is estimated and stored in your working directory as `my_anatomy.bin`.\n\n# Example:\n\n*For convenience, the examples below are contained in a single Python script available [here](https://github.com/sander-sn/anatomy/blob/main/examples/simple_dgp.py).*\n\nTo get started, we need a forecasting application. We use a linear DGP to generate our dataset consisting of 500 observations of the three predictors `x_{0,1,2}` and our target `y`:\n          \n    # set random seed for reproducibility:\n    np.random.seed(1338)\n    \n    xy = pd.DataFrame(np.random.normal(0, 1, (500, 3)), columns=[\"x_0\", \"x_1\", \"x_2\"])\n    xy[\"y\"] = xy.sum(axis=1) + np.random.normal(0, 1, 500)\n\n    # set a unique and monotonically increasing index (default index would suffice):\n    xy.index = pd.date_range(\"2021-04-19\", \"2022-08-31\").map(lambda x: x.date())\n\nFor convenience, the `AnatomySubsets` includes a generator that splits your dataset into training and test sets according to your forecasting scheme. Here, we include 100 periods in our first training set, forecast the target of the next period with no gap between the training set and the forecast, extend our training set by one period, and repeat until we reach the end of our data:\n    \n    subsets = AnatomySubsets.generate(\n        index=xy.index,\n        initial_window=100,\n        estimation_type=AnatomySubsets.EstimationType.EXPANDING,\n        periods=1,\n        gap=0\n    )\n\t\nIn this example, we have not yet trained our models. We thus do so directly in our mapping function:\n\n    def mapper(key: AnatomyModelProvider.PeriodKey) -> \\\n            AnatomyModelProvider.PeriodValue:  \n  \n        train = xy.iloc[subsets.get_train_subset(key.period)]  \n        test = xy.iloc[subsets.get_test_subset(key.period)]  \n\n        if key.model_name == \"ols\":\n            model = train_ols(train.drop(\"y\", axis=1), train[\"y\"])  \n        elif key.model_name == \"rf\":  \n            model = train_rf(train.drop(\"y\", axis=1), train[\"y\"])  \n      \n        return AnatomyModelProvider.PeriodValue(train, test, model)\n\nusing `train_ols` and `train_rf`, which train a model and yield its prediction function wrapped in an `AnatomyModel`:\n\n    from sklearn.ensemble import RandomForestRegressor  \n    from sklearn.linear_model import LinearRegression\n    \n    def train_ols(x_train: pd.DataFrame, y_train: pd.Series) -> AnatomyModel:\n        ols_model = LinearRegression().fit(x_train, y_train)  \n      \n        def pred_fn_ols(xs: np.ndarray) -> np.ndarray:  \n            xs_df = pd.DataFrame(xs, columns=x_train.columns)  \n            return np.array(ols_model.predict(xs_df)).flatten()  \n      \n        return AnatomyModel(pred_fn_ols)  \n\n    def train_rf(x_train: pd.DataFrame, y_train: pd.Series) -> AnatomyModel:\n        rf_model = RandomForestRegressor(random_state=1338).fit(x_train, y_train)  \n      \n        def pred_fn_rf(xs: np.ndarray) -> np.ndarray:  \n            xs_df = pd.DataFrame(xs, columns=x_train.columns)  \n            return np.array(rf_model.predict(xs_df)).flatten()  \n      \n        return AnatomyModel(pred_fn_rf)\n\nWe now have all we need to train the models and estimate the `Anatomy`:\n \n    provider = AnatomyModelProvider(\n        n_periods=subsets.n_periods,\n        n_features=xy.shape[1]-1,\n        model_names=[\"ols\", \"rf\"],\n        y_name=\"y\",\n        provider_fn=mapper\n    )  \n      \n    anatomy = Anatomy(provider=provider, n_iterations=10).precompute(  \n        n_jobs=16, save_path=\"anatomy.bin\"  \n    )\n\nAt this point, the `Anatomy` is stored as `anatomy.bin` in our working directory. We can load it at any later point using `anatomy = Anatomy.load(\"anatomy.bin\")`.\n\n# Anatomizing\nWe can now use our estimated `Anatomy` to anatomize our forecasts. In this example, we are using two models, `rf` and `ols`, as well as an equal-weighted combination of the two:\n\n    groups = {\n        \"rf\": [\"rf\"],  \n        \"ols\": [\"ols\"],\n        \"ols+rf\": [\"ols\", \"rf\"]\n    }\n\n## Anatomize the out-of-sample $R^2$ of the forecasts:\nTo decompose the out-of-sample $R^2$ of our forecasts produced by the two models and their combination, we use the unconditional forecasts as benchmark and provide a function transforming forecasts into out-of-sample $R^2$ to the `Anatomy`:\n      \n    prevailing_mean = np.array([  \n        xy.iloc[subsets.get_train_subset(period=i)][\"y\"].mean()  \n        for i in range(subsets.n_periods)  \n    ])  \n      \n    def transform(y_hat, y):  \n        return 1 - np.sum((y - y_hat) ** 2) / np.sum((y - prevailing_mean) ** 2)\n\n    df = anatomy.explain(\n        model_sets=AnatomyModelCombination(groups=groups),\n        transformer=AnatomyModelOutputTransformer(transform=transform)\n    )\n\nThis yields the change in out-of-sample $R^2$ attributable to each predictor:\n\n    >>> df\n                                     base_contribution       x_0       x_1       x_2\n    rf     2021-07-28 -> 2022-08-31           0.000759  0.257240  0.238458  0.215062\n    ols    2021-07-28 -> 2022-08-31           0.000000  0.285329  0.267940  0.249870\n    ols+rf 2021-07-28 -> 2022-08-31           0.000383  0.279073  0.259201  0.240548\n\n### *Interpretation*\n\nThe Shapley-based decomposition can be understood as a means to fairly allocate a single value (in this case the out-of-sample $R^2$) amongst multiple actors contributiong to it (the predictors in our model). This implies that the individual contributions of the actors and the contribution of the empty set of actors (`base_contribution`) sum up exactly to the original value that is decomposed.\n\nThe above depicts the individual contributions to the out-of-sample $R^2$, which can be negative, if a given predictor hurts accuracy, or positive, if a given predictor increases accuracy.  In this case, all predictors contribute positively to the out-of-sample $R^2$. In practice, predictors can hurt accuracy by reducing the out-of-sample $R^2$.\n\n*Note: In this example, we use the prevailing mean (average of the target in the training sets) as benchmark to compute the out-of-sample R\u00b2. The average forecast of an OLS model concides with this benchmark, which explains why the `base_contribution` of OLS is exactly zero.*\n\n## ... the RMSE of the forecasts:\n\n    def transform(y_hat, y):  \n        return np.sqrt(np.mean((y - y_hat) ** 2))\n    \n    df = anatomy.explain(  \n        model_sets=AnatomyModelCombination(groups=groups),  \n        transformer=AnatomyModelOutputTransformer(transform=transform)  \n    )\n\nwhich yields the change in root mean squared error attributable to each predictor:\n\n    >>> df\n                                     base_contribution       x_0       x_1       x_2\n    rf     2021-07-28 -> 2022-08-31           2.105513 -0.351430 -0.326065 -0.296708\n    ols    2021-07-28 -> 2022-08-31           2.106313 -0.414488 -0.386125 -0.371149\n    ols+rf 2021-07-28 -> 2022-08-31           2.105910 -0.397903 -0.368193 -0.350080\n\n### *Interpretation*\nWe previously decomposed the out-of-sample $R^2$. In this case, we use the RMSE *loss* function, implying that a predictor with a negative contribution increases forecasting accuracy. Because the RMSE cannot be negative, the `base_contribution`, which is the RMSE of the average forecasts of the models, can only be positive.\n\nSimilar to the previous case, we find that all predictors contribute positively to forecasting accuracy (by contributing negatively to the RMSE).\n   \n## ... the MAE:\n\n    def transform(y_hat, y):  \n        return np.mean(np.abs(y - y_hat))\n    \n    df = anatomy.explain(  \n        model_sets=AnatomyModelCombination(groups=groups),  \n        transformer=AnatomyModelOutputTransformer(transform=transform)  \n    )\n\nwhich yields the change in mean absolute error attributable to each predictor:\n\n    >>> df\n                                     base_contribution       x_0       x_1       x_2\n    rf     2021-07-28 -> 2022-08-31           1.679359 -0.299382 -0.249591 -0.221651\n    ols    2021-07-28 -> 2022-08-31           1.679946 -0.345583 -0.300613 -0.288960\n    ols+rf 2021-07-28 -> 2022-08-31           1.679652 -0.330303 -0.283129 -0.262270\n\n### *Interpretation*\n\nThe interpretation is similar to that of the RMSE.\n \n## ... the SE:\n\n    def transform(y_hat, y):  \n        return (y - y_hat) ** 2\n  \n    df = anatomy.explain(\n        model_sets=AnatomyModelCombination(groups=groups),\n        transformer=AnatomyModelOutputTransformer(transform=transform)\n    )\n\nwhich yields the change in squared error attributable to each predictor for each forecast:\n\n    >>> df\n                       base_contribution       x_0       x_1       x_2\n    rf     2021-07-28           0.026485 -0.063311 -0.115985  0.163743\n           2021-07-29           0.021582  0.238569 -0.370448  0.694773\n           2021-07-30           2.451742 -2.702365  1.660915 -1.407192\n    ...                              ...       ...       ...       ...\n\n*Note: The `transform` function in this case does not aggregate (returns a vector instead of a scalar). The `Anatomy` thus yields one decomposition per forecast, which is also known as a local (as opposed to global) decomposition.*\n\n### *Interpretation*\n\nThe previous decompositions have shown consistently that all predictors increase forecasting accuracy when it is gauged over the entire period (2021-07-28 to 2022-08-31). Anatomizing instead each individual forecast reveals that this is not always true, at least not at the local level. We now see that individual predictors are contributing positively to the squared error of some forecasts (thus reducing forecast accuracy).\n\n## ... the RMSE of the forecasts in a subperiod:\n\n    subset = pd.date_range(\"2021-07-28\", \"2021-08-06\").map(lambda x: x.date())\n    \t    \n    def transform(y_hat, y):  \n        return np.sqrt(np.mean((y - y_hat) ** 2))  \n        \n    df = anatomy.explain(  \n        model_sets=AnatomyModelCombination(groups=groups),  \n        transformer=AnatomyModelOutputTransformer(transform=transform),  \n        explanation_subset=subset \n    )\n\nwhich yields the change in root mean squared error in the ten-day period attributable to each predictor:\n\n```\n>>> df\n                                 base_contribution       x_0       x_1       x_2\nrf     2021-07-28 -> 2021-08-06           1.402950 -0.149847 -0.199615  0.118059\nols    2021-07-28 -> 2021-08-06           1.404761 -0.155275 -0.323760  0.317055\nols+rf 2021-07-28 -> 2021-08-06           1.403853 -0.169584 -0.275408  0.211672\n```\n\n### _Interpretation_\n\nIn this short subperiod of ten days, we find that our last predictor contributed positively to the RMSE (and thus negatively to forecasting accuracy).\n\n\n## ... or just the raw forecasts:\n\n    def transform(y_hat):\n        return y_hat\n        \n    df = anatomy.explain(\n        model_sets=AnatomyModelCombination(groups=groups),\n        transformer=AnatomyModelOutputTransformer(transform=transform)\n    )\n\nwhich yields the change in the forecast attributable to each predictor:\n\n    >>> df\n                       base_contribution       x_0       x_1       x_2\n    rf     2021-07-28           0.070861  0.222932  0.360182 -0.315820\n           2021-07-29           0.070354  0.250389 -0.617779  0.984992\n           2021-07-30           0.071163 -1.514547  0.839562 -0.835136\n    ...                              ...       ...       ...       ...\n\n### *Interpretation*\n\nDecomposing the forecasts themselves yields contributions that bear no relation to forecasting accuracy. Hence, a negative or positive contribution means no more than a decrease or increase in the forecast at that period attributable to the given predictor, which may or may not have be good for forecasting accuracy.\n\n***Hence: beware, a high average absolute contribution does not necessarily translate into a high gain in accuracy. That is precisely why we need to decompose the loss directly, and in consequence, take into account our target and how far away our forecasts were from it.***\n\nFrom the anatomized raw forecasts, we can compute the  $\\text{oShapley-VI}$ by averaging over the magnitudes of the invididual contributions:\n\n    >>> df.abs().mean(axis=0)\n    base_contribution    0.078436\n    x_0                  0.865098\n    x_1                  0.787327\n    x_2                  0.773340\n\n## The Efficiency property\n\n*During estimation, the `Anatomy` checks that the individual attributions of the predictors to the forecasts sum up exactly to the forecasts produced by the models. The estimation would be aborted if efficiency does not hold.*\n\nDue to the efficiency property of Shapley values, summing the individual contributions yields the decomposed value exactly. We can check that the results that `Anatomy` yields are consistet. We can recover the RMSE from the decomposed RMSE, but we can also recover the RMSE from the decomposed forecasts. Let's make sure that they match.\n\nWe first anatomize the RMSE:\n\n    def transform(y_hat, y):  \n        return np.sqrt(np.mean((y - y_hat) ** 2))  \n      \n    df = anatomy.explain(  \n        model_sets=AnatomyModelCombination(groups=groups),  \n        transformer=AnatomyModelOutputTransformer(transform=transform)  \n    )\n\nThe RMSE (or any other decomposed value) is the sum of the individual attributions, `rmse_a = df.sum(axis=1)`:\n\n    >>> rmse_a\n    rf      2021-07-28 -> 2022-08-31    1.131310\n    ols     2021-07-28 -> 2022-08-31    0.934551\n    ols+rf  2021-07-28 -> 2022-08-31    0.989733\n\nWe next decompose the raw forecasts and compute the RMSE from these:\n\n    def transform(y_hat):  \n        return y_hat  \n  \n    df = anatomy.explain(  \n        model_sets=AnatomyModelCombination(groups=groups),  \n        transformer=AnatomyModelOutputTransformer(transform=transform)  \n    )\n\nThe forecasts are recovered as the sum of the individual attributions, `y_hat = df.sum(axis=1)`:\n\n    >>> y_hat\n    rf      2021-07-28    0.338154\n            2021-07-29    0.687956\n            2021-07-30   -1.438958\n                               ...   \n\nFrom the forecasts, we can compute the RMSE:       \n      \n    y_true = np.hstack([  \n        xy.iloc[subsets.get_test_subset(period=i)][\"y\"]\n        for i in range(subsets.n_periods)  \n    ])  \n      \n    rmse_b = pd.Series({  \n        key: np.sqrt(np.mean((y_true - y_hat.xs(key)) ** 2))   \n        for key in groups.keys()  \n    })\n\nwhich yields the same RMSE as the sum of the contributions of the RMSE decomposition:\n\n    >>> rmse_b\n    rf        1.131310\n    ols       0.934551\n    ols+rf    0.989733\n\n",
            "description_content_type": "text/markdown",
            "docs_url": null,
            "download_url": "",
            "downloads": {
                "last_day": -1,
                "last_month": -1,
                "last_week": -1
            },
            "home_page": "https://github.com/sander-sn/anatomy",
            "keywords": "",
            "license": "MIT",
            "maintainer": "",
            "maintainer_email": "",
            "name": "anatomy",
            "package_url": "https://pypi.org/project/anatomy/",
            "platform": null,
            "project_url": "https://pypi.org/project/anatomy/",
            "project_urls": {
                "Homepage": "https://github.com/sander-sn/anatomy"
            },
            "release_url": "https://pypi.org/project/anatomy/0.1.2/",
            "requires_dist": [
                "joblib (>=0.15.0)",
                "numpy (>=1.18.1)",
                "pandas (>=1.0.0)"
            ],
            "requires_python": ">=3.9",
            "summary": "",
            "version": "0.1.2",
            "yanked": false,
            "yanked_reason": null
        },
        "last_serial": 15311199,
        "urls": [
            {
                "comment_text": "",
                "digests": {
                    "md5": "40228039e2e7aadc700b15ce26c341fd",
                    "sha256": "743804909e5cb581b1e3377222ca59018b69118ad7f717cccbf28cd634acd9f0"
                },
                "downloads": -1,
                "filename": "anatomy-0.1.2-py3-none-any.whl",
                "has_sig": false,
                "md5_digest": "40228039e2e7aadc700b15ce26c341fd",
                "packagetype": "bdist_wheel",
                "python_version": "py3",
                "requires_python": ">=3.9",
                "size": 14675,
                "upload_time": "2022-10-05T11:23:12",
                "upload_time_iso_8601": "2022-10-05T11:23:12.633547Z",
                "url": "https://files.pythonhosted.org/packages/d6/10/dc9360cba024355e7f1c45843d3056611e759d883a3f2ab82723ebd4f127/anatomy-0.1.2-py3-none-any.whl",
                "yanked": false,
                "yanked_reason": null
            },
            {
                "comment_text": "",
                "digests": {
                    "md5": "9158864c2f0816f02678072fe81e7abb",
                    "sha256": "d00fb800ac71b60772be5cc32edc26f755e70daad0d7d9e1154ee6293f6c1205"
                },
                "downloads": -1,
                "filename": "anatomy-0.1.2.tar.gz",
                "has_sig": false,
                "md5_digest": "9158864c2f0816f02678072fe81e7abb",
                "packagetype": "sdist",
                "python_version": "source",
                "requires_python": ">=3.9",
                "size": 18392,
                "upload_time": "2022-10-05T11:23:14",
                "upload_time_iso_8601": "2022-10-05T11:23:14.536713Z",
                "url": "https://files.pythonhosted.org/packages/69/e8/7530ef137b603dd0468c51dca047f2a397ddc0f6e52ea648776dea422b76/anatomy-0.1.2.tar.gz",
                "yanked": false,
                "yanked_reason": null
            }
        ],
        "vulnerabilities": []
    }
}