{
    "0.2.1": {
        "info": {
            "author": "Chunxi Xin",
            "author_email": "chvx1n@gmail.com",
            "bugtrack_url": null,
            "classifiers": [
                "License :: OSI Approved :: MIT License",
                "Operating System :: OS Independent",
                "Programming Language :: Python :: 3"
            ],
            "description_content_type": "text/markdown",
            "docs_url": null,
            "download_url": "",
            "downloads": {
                "last_day": -1,
                "last_month": -1,
                "last_week": -1
            },
            "home_page": "https://github.com/dex1n/ArgCat",
            "keywords": "",
            "license": "",
            "maintainer": "",
            "maintainer_email": "",
            "name": "argcat",
            "package_url": "https://pypi.org/project/argcat/",
            "platform": "",
            "project_url": "https://pypi.org/project/argcat/",
            "project_urls": {
                "Bug Tracker": "https://github.com/dex1n/ArgCat/issues",
                "Homepage": "https://github.com/dex1n/ArgCat"
            },
            "release_url": "https://pypi.org/project/argcat/0.2.1/",
            "requires_dist": null,
            "requires_python": ">=3.6",
            "summary": "A cute helper for ArgumentParser in Python 3",
            "version": "0.2.1",
            "yanked": false,
            "yanked_reason": null
        },
        "last_serial": 11292569,
        "urls": [
            {
                "comment_text": "",
                "digests": {
                    "md5": "8c4a3630d673147fb284b688f2f7117a",
                    "sha256": "33017a514b863dfadf741f80fadbb2a789ce4c8f6d28330fc3980c03ece8ba0f"
                },
                "downloads": -1,
                "filename": "argcat-0.2.1-py3-none-any.whl",
                "has_sig": false,
                "md5_digest": "8c4a3630d673147fb284b688f2f7117a",
                "packagetype": "bdist_wheel",
                "python_version": "py3",
                "requires_python": ">=3.6",
                "size": 11660,
                "upload_time": "2021-03-21T12:55:53",
                "upload_time_iso_8601": "2021-03-21T12:55:53.174955Z",
                "url": "https://files.pythonhosted.org/packages/b9/89/86b0ba66432372bfa401ca54b8cec42cf9749c17de790b012b715d3bf034/argcat-0.2.1-py3-none-any.whl",
                "yanked": false,
                "yanked_reason": null
            },
            {
                "comment_text": "",
                "digests": {
                    "md5": "030812ab976c1f006f376e57504abd71",
                    "sha256": "dad2f61ddd14172318d406a34f22607e40aead343dd5f1be88bd91347b226791"
                },
                "downloads": -1,
                "filename": "argcat-0.2.1.tar.gz",
                "has_sig": false,
                "md5_digest": "030812ab976c1f006f376e57504abd71",
                "packagetype": "sdist",
                "python_version": "source",
                "requires_python": ">=3.6",
                "size": 15377,
                "upload_time": "2021-03-21T12:55:56",
                "upload_time_iso_8601": "2021-03-21T12:55:56.428821Z",
                "url": "https://files.pythonhosted.org/packages/e1/bf/45cc7ea8a3818108e4835f197e7837e11afe0cf618d1edd3b3365b1ab492/argcat-0.2.1.tar.gz",
                "yanked": false,
                "yanked_reason": null
            }
        ],
        "vulnerabilities": []
    },
    "0.2.2": {
        "info": {
            "author": "Chunxi Xin",
            "author_email": "chvx1n@gmail.com",
            "bugtrack_url": null,
            "classifiers": [
                "License :: OSI Approved :: MIT License",
                "Operating System :: OS Independent",
                "Programming Language :: Python :: 3"
            ],
            "description_content_type": "text/markdown",
            "docs_url": null,
            "download_url": "",
            "downloads": {
                "last_day": -1,
                "last_month": -1,
                "last_week": -1
            },
            "home_page": "https://github.com/dex1n/ArgCat",
            "keywords": "",
            "license": "",
            "maintainer": "",
            "maintainer_email": "",
            "name": "argcat",
            "package_url": "https://pypi.org/project/argcat/",
            "platform": "",
            "project_url": "https://pypi.org/project/argcat/",
            "project_urls": {
                "Bug Tracker": "https://github.com/dex1n/ArgCat/issues",
                "Homepage": "https://github.com/dex1n/ArgCat"
            },
            "release_url": "https://pypi.org/project/argcat/0.2.2/",
            "requires_dist": null,
            "requires_python": ">=3.6",
            "summary": "A cute helper for ArgumentParser in Python 3",
            "version": "0.2.2",
            "yanked": false,
            "yanked_reason": null
        },
        "last_serial": 11292569,
        "urls": [
            {
                "comment_text": "",
                "digests": {
                    "md5": "4599fd764c469c090257d2ebbbb7ac3f",
                    "sha256": "3afdf9272e638ec60e5c23d7ecb38668887cccbc9d96ae236a0d2e4202ccae86"
                },
                "downloads": -1,
                "filename": "argcat-0.2.2-py3-none-any.whl",
                "has_sig": false,
                "md5_digest": "4599fd764c469c090257d2ebbbb7ac3f",
                "packagetype": "bdist_wheel",
                "python_version": "py3",
                "requires_python": ">=3.6",
                "size": 12003,
                "upload_time": "2021-08-27T06:56:04",
                "upload_time_iso_8601": "2021-08-27T06:56:04.031103Z",
                "url": "https://files.pythonhosted.org/packages/bd/8e/09678eb1c792d4debe4b7144b143d70104a4f5a9a0f08e0db60995a7d591/argcat-0.2.2-py3-none-any.whl",
                "yanked": false,
                "yanked_reason": null
            },
            {
                "comment_text": "",
                "digests": {
                    "md5": "79ad74e11a784445ddb111dcfdc9c331",
                    "sha256": "8243be470229c0784011cb71458ab53552cc16eb2d9235e32cfce1dbce2d9ccf"
                },
                "downloads": -1,
                "filename": "argcat-0.2.2.tar.gz",
                "has_sig": false,
                "md5_digest": "79ad74e11a784445ddb111dcfdc9c331",
                "packagetype": "sdist",
                "python_version": "source",
                "requires_python": ">=3.6",
                "size": 15262,
                "upload_time": "2021-08-27T06:56:05",
                "upload_time_iso_8601": "2021-08-27T06:56:05.953550Z",
                "url": "https://files.pythonhosted.org/packages/8e/70/29f408ffecf99423d13259ba2e8eeb42dd26611bb1c95d5890c207bce289/argcat-0.2.2.tar.gz",
                "yanked": false,
                "yanked_reason": null
            }
        ],
        "vulnerabilities": []
    },
    "0.2.3": {
        "info": {
            "author": "Chunxi Xin",
            "author_email": "chvx1n@gmail.com",
            "bugtrack_url": null,
            "classifiers": [
                "License :: OSI Approved :: MIT License",
                "Operating System :: OS Independent",
                "Programming Language :: Python :: 3"
            ],
            "description": "# ArgCat - A cute helper for ArgumentParser in Python 3\n\n## Background\n\nHave you already been tired of writing argument parsing codes for your python command line program? **YES, I AM! (Why I'm yelling as hell?!)**\n\n(This is the reason:) To me, adding/updating the argument parsers and setting varities of arguments in python are absolute chores and the most boring part of writing a python program.\n\nYou know, __Life is short, I use Python__ ... to write the creative and fun stuffs. But NOT these:\n\n```python\nargument_parser = argparse.ArgumentParser(prog='Cool program name', description='Awesome description')\nargument_parser.add_argument(\"-t\", \"--test\", nargs='?', dest='test', metavar='TEST', type=str, help='Just for test')\n\nargument_subparsers = argument_parser.add_subparsers(dest = \"sub_command\", title='The subparsers title\"', \n    description=\"The subparsers description\", help='The subparsers help')\n    \ninit_parser = argument_subparsers.add_parser('init', help=\"Initialize something.\")\n\ninfo_parser = argument_subparsers.add_parser('info', help=\"Show information of something.\")\ninfo_parser.add_argument(\"-d\", \"--detail\", nargs='?', dest='detail', metavar='DETAIL', type=str, \n    help='The detail of the information')\n\nconfig_parser = argument_subparsers.add_parser('config', help=\"Config something.\")\nconfig_arg_group = config_parser.add_mutually_exclusive_group()\nconfig_arg_group.add_argument(\"-n\", \"--name\", nargs='?', dest='name', metavar='NAME', type=str, help='The name.')\nconfig_arg_group.add_argument(\"-u\", \"--username\", nargs='?', dest='user_name', metavar='USER_NAME', type=str, help='The user name.')\n\nargs = argument_parser.parse_args()\nsub_command = args.sub_command\nif sub_command == \"init\":\n    init_handler()\nelif sub_command == \"info\":\n    info_handler()\nelif sub_command == \"config\":\n    foo = Foo()\n    foo.config_handler(args.name, args.user_name)\nelif sub_command is None:\n    main_handler(args.test)\n```\n\nThese codes for me really destroy every happy and exciting moment and kill the most valuable thing: **TIME!**\n\nSo, in the end, it does really matter! (BTW, I love Linkin Park)\n\nSo, (another so, you know, we love saying so) eventually I create __ArgCat__ as the way to get out of the boring hell.\n\n## About\n\nGenerally speaking, __ArgCat__ allows you to define and config your ArgumentParsers in a YAML format file then create the ArgumentParser instances according to the YAML in the runtime.\n\n## Installation\n\nWhy not install it before diving into details :)\n\n```bash\npip install argcat\n```\n\n## Usage\n\n### YAML\n\nAn example YAML file name `simple.yml` for __ArgCat__:\n\n```yaml\nmeta: # Include all essential configurations used for creating a new ArgumentParser.\n  prog: \"Cool program name\"\n  description: \"Awesome description\"\n  subparser:\n    title: \"The subparsers title\"\n    description: \"The subparsers description\"\n    help: \"The subparsers help\"\nparsers:  # All parsers including the \"main\" parser below, which is the very first parser created by argparse.ArgumentParser()\n  main:\n    arguments:\n      # Declare a positional argument for the main parser.\n      -\n        # Mainly used for main arguments. \n        # If this is set to True, the argument will be filtered out before being passed into subparser's handler. \n        # Default value is False.\n        # In this case, the argument test will not be passed into any subparser's handler,\n        # even this test argument has a valid value instead of None.\n        ignored_by_subparser: True\n        nargs: \"?\"\n        dest: \"test\"\n        metavar: \"TEST\"\n        type: \"str\" # The default type for this is \"str\". Use the type's lexical name here and ArgCat will try to convert it to the type object.\n        help: \"Just for test\"\n  init: # This is a subparser without any argument but only a help tip.\n    help: \"Initialize something.\"\n  info: # This is a subparser has only one positional argument.\n    help: \"Show information of something.\"\n    arguments:\n      -\n        nargs: \"?\"\n        dest: \"detail\"\n        metavar: \"DETAIL\"\n        type: \"str\"\n        help: \"The detail of the information\"\n  config: # This is a sub parser has a few named arguments and one group.\n    help: \"Config something.\"\n    argument_groups:  # All groups this subparser has.\n      a_group:  # Group name can be any valid string. And any argument in the group should declare this in its argument config.\n        name: \"Actual group name\"\n        description: \"Group description\"\n        is_mutually_exclusive: true # Whether the group is mutually exclusive. This is an useful property for some cases.\n    arguments:\n      -\n        name_or_flags: [\"-n\", \"--name\"]\n        nargs: \"?\"\n        dest: \"name\"\n        metavar: \"NAME\"\n        type: \"str\"\n        help: \"The name.\"\n        group: \"a_group\"  # Declare this argument is in the group whose name is \"a_group\" declared above.\n      - \n        name_or_flags: [\"-u\", \"--username\"]\n        nargs: \"?\"\n        dest: \"user_name\"\n        metavar: \"USER_NAME\"\n        type: \"str\" \n        help: \"The user name.\"\n        group: \"a_group\"\n\n```\n\nQuite simple, right? (Not short, but really simple and straightforward. :P )\n\n### Simple codes\n\n```python\nfrom argcat import ArgCat\nargcat = ArgCat()\nargcat.load(\"simple.yml\") # Load the settings from the YAML file.\nargcat.parse_args() # Start to parse the args input.\n```\n\nThat's it!\n\nWhen `argcat.parse_args()` gets called, __ArgCat__ starts to process the input arguments like what `ArgumentParser.parse_args()` does. It sends the corresponding arguments received and parsed, and then passes into the _Handlers_ you defined in your codes. Speaking of _Handlers_:\n\n### Handlers\n\nThe _Handler_ is a function for handling arguments processed by __ArgCat__. It's place you really deal with the arguments.\n\n#### How to define a Handler\n\nThere are two steps you need for defining __ArgCat__ _Handler_:\n\n1. Decorate the handler function with the `@ArgCat.handler` decorator and set the corresonding parser name. See a full example below:\n\n    ```python\n    #!/usr/bin/python\n\n    from argcat import ArgCat\n    import sys\n\n    class Foo:\n        def __init__(self):\n            self._value = \"foo value.\"\n        \n        @property\n        def value(self):\n            return self._value\n\n        @value.setter\n        def value(self, new_value):\n            self._value = new_value\n        \n        # Regular class instance method\n        @ArgCat.handler(\"config\") # Handle arguments for parser named \"config\"\n        def config_handler(self, name, user_name):\n            print(\"self._value = {}\".format(self._value))\n            print(\"name = {}, user_name = {}\".format(name, user_name))\n\n        # Static method of class\n        @staticmethod\n        @ArgCat.handler(\"init\") # Handle arguments for parser named \"init\"\n        def init_handler():\n            print(\"init_handler\")\n\n        # Class method\n        @classmethod\n        @ArgCat.handler(\"info\") # Handle arguments for parser named \"info\"\n        def info_handler(cls, detail):\n            print(\"info_handler with detail: {}\".format(detail))\n\n    # Regular function\n    @ArgCat.handler(\"main\")\n    def main_handler(test):\n        print(\"main_handler {}\".format(test))\n    ```\n\n    As you can see, there are four different kinds of functions of the class `Foo` decorated.\n\n2. Let __ArgCat__ know where to find the handlers by `ArgCat.add_handler_provider(provider: Any)`:\n\n    ```python\n    def main():\n        argcat = ArgCat(chatter=False)\n        argcat.load(\"hello_cat.yml\")\n        foo = Foo()\n        foo.value = \"new value\"\n        # Set module __main__ as a handler provider\n        argcat.add_handler_provider(sys.modules['__main__'])\n        # Set Foo as a handler provider\n        argcat.add_handler_provider(foo)\n        argcat.print_parsers()\n        argcat.print_parser_handlers()\n        argcat.parse()\n        \n    if __name__ == '__main__':\n        main()\n    ```\n\n    When `ArgCat.add_handler_provider(provider: Any)` is called, ArgCat will try to find the decorated handlers from the providers. Note that the function `init_handler()` is in `__main__`, so the corresponding `provider` should be `sys.modules['__main__']` which returns the `__main__` scope.  \n\nTo sum it up, there are four handlers in above example:\n\n- `init_handler()`: a `@staticmethod` method of the class for a parser named `init`\n- `info_handler()`: a `@classmethod` method of the class for a parser named `info`\n- `main_handler()`: a regular function for a parser named `main`\n- `config_handler()`:  a regular instance method of the class for a parser named `config`\n\n#### The requirement of Handler\n\n##### Parser name and function name\n\nThe parser's name must be exactly the same as the one declared in the YAML file, but the handler function name can be arbitary.\n\nSo, if you define a parser named init in the config file, \n\n```YAML\ninit: # This is a subparser without any argument but only a help tip.\n    help: \"Initialize something.\"\n```\n\nthen the decorated function must set the correct name `init`.\n\n```Python\n@ArgCat.handler(\"init\") # Handle arguments for parser named \"init\"\n    def init_handler():\n      print(\"init_handler\")\n```\n\n##### Function type\n\nIf the method of the handler is `@staticmethod` or `@classmethod`, the decorations should be closest to the method like:\n\n```python\n# Class method\n@classmethod\n@ArgCat.handler(\"info\")  # This decorator must be placed closest to the method.\ndef info_handler(cls, detail):\n    print(\"info_handler with detail: {}\".format(detail))\n```\n\n##### Signature\n\nHandler's signature must match the parsed arguments. For instances, in the above codes, `config_handler()` has two parameters `name` and `user_name` except `self`. They exactly match what `config`'s declared arguments below. In other words, if `config` parser has only 2 arguments and their `dest` are `name` and `user_name`, the handler function must also have 2 parameters which must be `name` and `user_name`.\n\n```yaml\narguments:\n      -\n        name_or_flags: [\"-n\", \"--name\"]\n        nargs: \"?\"\n        dest: \"name\" # NOTE THIS DEST\n        metavar: \"NAME\"\n        type: \"str\"\n        help: \"The name.\"\n        group: \"a_group\"  \n      - \n        name_or_flags: [\"-u\", \"--username\"]\n        nargs: \"?\"\n        dest: \"user_name\" # NOTE THIS DEST\n        metavar: \"USER_NAME\"\n        type: \"str\" \n        help: \"The user name.\"\n        group: \"a_group\"\n```\n\n##### Underneath the surface\n\nThe parsed argument dict would be something like `{'name': '1', 'user_name': None}` for `config`'s case. And the handler function `config_handler()` will be called with key arguments given by `**theDict` , which means the function will be called like this: `config_handler(**theDict)`. As a result, if one of `config_handler()` parameters is `foo_user_name` instead of `user_name`, the handler would not be able to receive the parsed arguments and an error would be reported by __ArgCat__ like:\n\n```Python\nERROR: Handling function Exception: \"config_handler() got an unexpected keyword argument 'user_name'\", with function sig: (name, foo_user_name) and received parameters: (name, user_name).\n```\n\n### Example\n\nThere are files of two examples in this project.\n\nOne includes two files: `hello_cat.py`, `hello_cat.yml`. The first one is a main file shows how to use __ArgCat__ and also contains the codes demonstrated in this README. And the latter one is the YAML config file. You can take them as reference, when you are using __ArgCat__.\n\nAnother file named `hello_chore.py` shows the traditional way to use the ArgumentParser.\n\nIf you encounter any issue or have any question please feel free to open an issue ticket or send me email.\n\n## In the end\n\nPhew...\n\nOk. I think that's all for this README at this point for v0.2.1.\n\nArgCat is good, but not perfect. I will continue to improve it and update this documentation.\n\nHope you enjoy coding in Python.\n\n`~Peace & Love~`\n\n## License\n\n```\nMIT License\n\nCopyright (c) 2021 Chunxi Xin\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n```\n\n",
            "description_content_type": "text/markdown",
            "docs_url": null,
            "download_url": "",
            "downloads": {
                "last_day": -1,
                "last_month": -1,
                "last_week": -1
            },
            "home_page": "https://github.com/dex1n/ArgCat",
            "keywords": "",
            "license": "",
            "maintainer": "",
            "maintainer_email": "",
            "name": "argcat",
            "package_url": "https://pypi.org/project/argcat/",
            "platform": "",
            "project_url": "https://pypi.org/project/argcat/",
            "project_urls": {
                "Bug Tracker": "https://github.com/dex1n/ArgCat/issues",
                "Homepage": "https://github.com/dex1n/ArgCat"
            },
            "release_url": "https://pypi.org/project/argcat/0.2.3/",
            "requires_dist": null,
            "requires_python": ">=3.6",
            "summary": "A cute helper for ArgumentParser in Python 3",
            "version": "0.2.3",
            "yanked": false,
            "yanked_reason": null
        },
        "last_serial": 11292569,
        "urls": [
            {
                "comment_text": "",
                "digests": {
                    "md5": "4d18e9464450980a9a89009495eb658e",
                    "sha256": "c80b46f9079c8db93e79d414582374a2398a3066f33e93ca406549b64fb13065"
                },
                "downloads": -1,
                "filename": "argcat-0.2.3-py3-none-any.whl",
                "has_sig": false,
                "md5_digest": "4d18e9464450980a9a89009495eb658e",
                "packagetype": "bdist_wheel",
                "python_version": "py3",
                "requires_python": ">=3.6",
                "size": 12001,
                "upload_time": "2021-08-27T07:05:16",
                "upload_time_iso_8601": "2021-08-27T07:05:16.062465Z",
                "url": "https://files.pythonhosted.org/packages/25/de/5308cd30d3248b25baa19b02c955f1b810a682e3d4800b4f3e0cd42848fa/argcat-0.2.3-py3-none-any.whl",
                "yanked": false,
                "yanked_reason": null
            },
            {
                "comment_text": "",
                "digests": {
                    "md5": "5e2dbc68500eb0b018847f8e51bc404f",
                    "sha256": "2765a8a544f7662b1475c8d454acc872dafd246144992c3cdacfa6f81b3ba4e3"
                },
                "downloads": -1,
                "filename": "argcat-0.2.3.tar.gz",
                "has_sig": false,
                "md5_digest": "5e2dbc68500eb0b018847f8e51bc404f",
                "packagetype": "sdist",
                "python_version": "source",
                "requires_python": ">=3.6",
                "size": 15274,
                "upload_time": "2021-08-27T07:05:18",
                "upload_time_iso_8601": "2021-08-27T07:05:18.028201Z",
                "url": "https://files.pythonhosted.org/packages/e6/a0/45e344596aaee412a901867f80ac12f6781f781853b08d9555f425e9d594/argcat-0.2.3.tar.gz",
                "yanked": false,
                "yanked_reason": null
            }
        ],
        "vulnerabilities": []
    }
}