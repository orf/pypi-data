{
    "1.0.9": {
        "info": {
            "author": "giocip",
            "author_email": "giocip7@gmail.com",
            "bugtrack_url": null,
            "classifiers": [
                "License :: OSI Approved :: MIT License",
                "Operating System :: OS Independent",
                "Programming Language :: Python :: 3.10"
            ],
            "description": "# SUPREME PRECISION GENERAL PURPOSE ARITHMETIC-LOGIC CLASS\r\n## _DESCRIPTION AND DOC_\r\n\r\nNum is a lightweight floating point numeric class for arbitrary precision results with always supreme precision.\r\n\r\nEasy to use like school math and WITHOUT IEEE754 ISSUES or +0 AND -0 FAILURES, it can be deployed  \r\nfor web e-commerce developing, accounting apps and general math programs included financial ones.\r\n\r\n## HOW TO USE (integer numeric strings (ex. '2.0') MUST BE SUFFIXED WITH .0):\r\n--- CALCULATOR MODE ---\r\n>>> from num7 import Num, Num as calc  \r\nADDITION:          >>> calc.add('-5.3', '2.1')    # Num('-3.2')  \r\nSUBTRACTION:       >>> calc.sub('-5.3', '2.1')    # Num('-7.4')  \r\nMULTIPLICATION:    >>> calc.mul('-5.3', '2.1')    # Num('-11.13')  \r\nDIVISION:          >>> calc.div('-5.3', '2.1')    # Num('-2.52380952380952380952380952380952380952380952380952380952380952380952380952380952')  \r\nM+:                >>> M = calc('0.0'); M.inc('3.0'); M.inc('3.3'); M.inc('3.7'); print(M) # 10.0  \r\nM-:                >>>                  M.dec('5.0'); M.dec('3.3'); M.dec('1.5'); print(M) # 0.2  \r\nMC:                >>> M.clear(); print(M) # 0.0  \r\nINT   DIV AND REM: >>> calc.divmod('5.0', '3.0')  # (Num('1.0'), Num('2.0')) => tuple  \r\nFLOAT DIV AND REM: >>> calc.divmod('5.2', '3.1')  # (Num('1.0'), Num('2.1')) => tuple  \r\nPOWER:             >>> calc.pow('-5.3', '2.0')    # Num('28.09')  \r\nSQRT:              >>> calc.sqrt('2.0')           # Num('1.41421356237309504880168872420969807856967187537694807317667973799073247846210703')  \r\nROUND:             >>> calc.sqrt('2.0').round(2)  # Num('1.41')  \r\nABSOLUTE VALUE     >>> calc.abs('-3.0')           # Num('3.0')  \r\nSUM:               >>> cart = ['19.32','18.37','15.13']; calc.sum(*cart)          # Num('52.82')  \r\nMEAN:              >>> cart = ['19.32','18.37','15.13']; calc.mean(*cart).round() # Num('17.61')  \r\nMIN:               >>> cart = ['19.32','18.37','15.13']; calc.min(cart)           # Num('15.13')  \r\nMAX:               >>> cart = ['19.32','18.37','15.13']; calc.max(cart)           # Num('19.32')  \r\nEXP:               >>> calc.mul('-5.3e1024', '2.1e1024').num2exp()                # '-1113E2046'  \r\nREPL:              >>> a = calc('0.1'); b = calc('0.2'); print(calc.add(a, b))    # 0.3  \r\n\r\nCODING:\r\n>>> from num7 import Num, Num as calc\r\n\r\n(=) assignment:\r\n>>> a = Num('3.0'); b = Num('5.0'); c = Num('0.0'); #  \r\n>>> print('a =', a, 'b =', b, 'c =', c) # a = 3.0 b = 5.0 c = 0.0  \r\n\r\n(+) adding:\r\n>>> R = a+b+c; print(R) # 8.0  \r\n>>> a = Num('0.1'); b = Num('0.2'); c = Num('0.0'); print(a+b+c) # 0.3  \r\n\r\n(-) subtracting:\r\n>>> a = Num('0.1'); b = Num('0.2'); c = Num('0.3');  \r\n>>> print(a+b-c) # 0.0  \r\n>>> R = Num('-3.99') - Num('-5.20') - Num('+3.01'); print(R) # -1.8  \r\n\r\n(*) multiplying:\r\n>>> Num('-3.99') * Num('-5.20') * Num('+3.01') # -3.99 * (-5.20) * (+3.01 ) = Num('62.45148')  \r\n\r\n(/) dividing (80 decimal digits default gets only for division operation):\r\n>>> Num('3.0') / Num('5.7') # 3 : 5.7 = Num('0.52631578947368421052631578947368421052631578947368421052631578947368421052631578')  \r\n\r\nDivision precision may be specified as parameter after numeric string as:\r\n128 decs  \r\n>>> Num('3.0', 128) / Num('5.7', 128) # 3 : 5.7 = Num('0.52631578947368421052631578947368421052631578947368421052631578947368421052631578947368421052631578947368421052631578947368421052')  \r\n\r\n(// % operators, divmod python3 built-in function) int division and remainder:\r\n>>> a = Num('5.0'); b = Num('2.0') #  \r\n>>> Q = a // b; R = a % b; print('Quotient =', Q, 'Remainder =', R) # Quotient = 2.0 Remainder = 1.0  \r\n>>> a = Num('15.0'); b = Num('4.0') #  \r\n>>> Q, R = divmod(a, b); print('Quotient =', Q, 'Remainder =', R)   # Quotient = 3.0 Remainder = 3.0  \r\n\r\n(divmod python3 built-in function) floating division and remainder:\r\n>>> a = Num('10.123456789'); b = Num('2.0') #  \r\n>>> Q, R = divmod(a, b); print('Quotient =', Q, 'Remainder =', R)   # Quotient = 5.0 Remainder = 0.123456789  \r\n\r\n(sqrt) square root function:\r\n>>> a = Num('123_456_789.1234567890123456789'); root = a.sqrt() # Num('11111.11106611111096998611053449930232404576951925017079015206589094347963821409843324')  \r\n>>> print('result digits number tuple =>', root.len()) # result digits number tuple => (5, 80)  \r\n\r\n(**) power operator and pow python3 built-in function:\r\n>>> a = Num('2.22123') ** 64; print(a) # 15204983311631674774944.65147209888660757554174463321311015807893679105748958794491681177995203669698667160837739445605536688871012507194541849848681968140805876570485027380472936734094801420552285940765338219588362327695177798251793912104057999943308320501195784173135380826413054938730768027747418766018606636039075568645106645889100039914241  \r\n>>> print(a.len()) # (23, 320) digits len tuple  \r\n>>> print(Num(Num.pi))  # 3.141592654  \r\n>>> pow(Num(Num.pi), 8) # Num('9488.531025982131642534428505085353941520356351078169077371202330414440366336')  \r\n\r\nlogic (in, not in, is, is not, <, <=, >, >=, !=, ==) and relational operators (and, or, not).\r\n\r\n(in):\r\n>>> L = [Num('0.1'), Num('1.0'), Num('5.5'), Num('-3.0'), Num('-2.9'), Num('-3.0001'), Num('2.2')]  \r\n>>> Num('-3.0001') in L; Num('-3.00001') in L         #True False  \r\n\r\n(not in):\r\n>>> Num('-3.0001') not in L; Num('-3.00001') not in L #False True  \r\n\r\n(is, is not):\r\n>>> M = calc('0.0'); Num('0.0') is M # False  \r\n>>> M = calc('0.0'); M.inc('0.1') is not M; M # True Num('0.1')  \r\n>>> M; N = M; N.dec('0.1'); N is M; M; N # Num('0.1') True Num('0.0') Num('0.0')  \r\n\r\n(< <= > >= != ==)\r\n>>> a = Num('0.0'); b = Num('0.1'); c = Num('-0.2')  \r\n>>> a <  b; a <  c; b <  c #True  False False  \r\n>>> a <= a; a <= c; b <= c #True  False False  \r\n>>> a >  b; a >  c; b >  c #False True  True  \r\n>>> a >= a; a >= c; b >= c #True  True  True  \r\n>>> c == -2*b; a == c + 2*b ; a != a+b+c #True  True  True  \r\n>>> a and b; a or b; not a     # Num('0.0') Num('0.1') True  \r\n>>> True if a and b else False # False  \r\n>>> True if a or  b else False # True  \r\n\r\n(+ - unary operators)\r\n>>> Num('+2.5521') # Num('2.5521')  \r\n>>> Num('-3.3321') # Num('-3.3321')  \r\n>>> Num('+2.5521') + Num('-3.3321') # Num('-0.78')  \r\n\r\n# advanced logic programming snippet\r\n\r\nLOOP EXAMPLE >>>  \r\n\r\n\tfrom num7 import Num, Num as calc  \r\n\ti = Num(0)  \r\n\twhile i < Num('1.0'):  \r\n\t\ti.inc('0.1') #i += Num('0.1')  \r\n\t\tif i <= Num('0.5'):  \r\n\t\t\tcontinue  \r\n\t\tprint(i) # 0.6, 0.7, 0.8, 0.9, 1.0  \r\n\twhile i:  \r\n\t\ti.dec('0.1') #i -= Num('0.1')  \r\n\t\tif i >= Num('0.5'):  \r\n\t\t\tcontinue  \r\n\t\tprint(i) #0.4 0.3 0.2 0.1 0.0  \r\n\r\nROUNDING AND ACCOUNTING >>>  \r\n\r\n\tfrom num7 import Num, Num as calc  \r\n\tp = Num('11.19')               #PRICE -Toslink cable for soundbar  \r\n\tpd = round(p.f_price_over(-7)) #PRICE DISCOUNTED 7%  \r\n\td = round(p - pd)              #DISCOUNT  \r\n\tp_noTAX = round(p.f_price_spinoff(22)) #COST ITEM WITHOUT TAX 22%  \r\n\tTAX = round(p - p_noTAX)               #TAX 22%  \r\n\tprint(F'price={p} PAYED={pd} discount={d} COST={p_noTAX} TAX={TAX}') #price=11.19 PAYED=10.41 discount=0.78 COST=9.17 TAX=2.02  \r\n\r\nPERFORMANCE EVALUATION AND SQUARENESS >>>  \r\n\t\r\n\tfrom num7 import Num, Num as calc  \r\n\tfrom time import perf_counter  \t\r\n\tdigits = 109  \r\n\ttic = perf_counter() # Start Time  \r\n\ta = Num('-1.123456789'+'e-100')      #calculating division 10**100...  \r\n\ttoc = perf_counter() # End Time  \r\n\tT1 = toc - tic  \r\n\tprint(f\"a finished sec. {T1:1.6f}\")  \r\n\ttic = perf_counter() # Start Time  \r\n\tb = ('-1.123456789') >> Num('100.0') #calculating division 10**100...  \r\n\ttoc = perf_counter() # End Time  \r\n\tT2 = toc - tic  \r\n\tprint(f\"b finished sec. {T2:1.6f}\")  \r\n\tR = Num.f_perf_time(str(T1), str(T2))  \r\n\tprint('PCT=>', R[0].round(), 'SCALE=>', R[1].round(), 'SQUARENESS=>', a == b) # PCT= -98.6 SCALE= -70.47 SQUARENESS=> True  \r\n\r\nSCIENTIFIC NOTATION AND HIGH PRECISION RESULTS >>>\r\n\r\n\tfrom num7 import Num, Num as calc  \r\n\ta = Num('1_000_000_000_000_000_000_000.0') #standard notation  \r\n\tb = Num('1e21') #scientific notation  \r\n\tSUM = a + b #SUM  \r\n\tieee754 = float(a)+float(b)  \r\n\tprint('SUM == ieee754', SUM == Num(str(ieee754)), ' SUM =>', SUM.num2exp()) #SUM == ieee754 True  SUM => 2e21  \r\n\t\r\n\ta = Num('1_000_000_000_000_000_000_000.0') #standard notation  \r\n\tb = Num('1e21') #scientific notation  \r\n\tMUL = a * b #MUL  \r\n\tieee754 = float(a)*float(b)  \r\n\tprint('MUL == ieee754', MUL == Num(str(ieee754)), ' MUL =>', MUL.num2exp()) #MUL == ieee754 True  MUL => 1e42  \r\n\t\r\n\ta = '1.23456789'  \r\n\tb = '9.87654321'  \r\n\tMUL = Num(a) * Num(b) #MUL  \r\n\tieee754 = float(a)*float(b)  \r\n\tprint('MUL == ieee754', MUL == Num(str(ieee754)), 'MUL =>', MUL, float(a)*float(b), '=> IEEE754 PRECISION FAILURE!') #MUL == ieee754 False MUL => 12.1932631112635269 12.193263111263525 => IEEE754 PRECISION FAILURE!  \r\n\t\r\n\ta = '1.23456789e320' #scientific notation  \r\n\tb = '9.87654321e320'  \r\n\tMUL = Num(a) * Num(b) #MUL  \r\n\tieee754 = float(a)*float(b)  \r\n\tprint('MUL == ieee754', MUL.str() == str(ieee754), 'MUL =>', MUL.num2exp(), float(a)*float(b), '=> IEEE754 inf FAILURE!') #MUL == ieee754 False MUL => 121932631112635269e624 inf => IEEE754 inf FAILURE!  \r\n\t\r\n\ta = '2e320' #scientific notation  \r\n\tb = '3e-320'  \r\n\tMUL = Num(a) * Num(b) #MUL  \r\n\tieee754 = float(a)*float(b)  \r\n\tprint('MUL == ieee754', MUL.str() == str(ieee754), 'MUL =>', MUL.num2exp(), ieee754, '=> IEEE754 inf FAILURE!') #MUL == ieee754 False MUL => 6.0 inf => IEEE754 inf FAILURE!  \r\n\t\r\n\ta = '1e200' #scientific notation  \r\n\tb = '5e1200'  \r\n\tT1 = Num(a, 1200) #ultra precision (over 80 digits default) floating point division must be specified!  \r\n\tT2 = Num(b)  \r\n\tDIV = T1 / T2 #DIV  \r\n\tieee754 = float(a)/float(b)  \r\n\tprint('DIV == ieee754', DIV.str() == str(ieee754), 'DIV =>', DIV.num2exp(), ieee754, '=> IEEE754 precision FAILURE!') #DIV == ieee754 False DIV => 2e-1001 0.0 => IEEE754 precision FAILURE!  \r\n\r\nFLOAT TO NUM CONVERSION LIST >>>\r\n\r\n\tfrom num7 import Num, Num as calc\r\n\tL = [1011, 0.0, 9.998412, 7.0, 0.123, -2.0123, 10, 6]\r\n\tLN= Num.float2num_list(L)\r\n\tprint(list(i.n for i in LN)) #['1011.0', '0.0', '9.998412', '7.0', '0.123', '-2.0123', '10.0', '6.0']\r\n\tprint(list(i for i in LN))   #[Num('1011.0'), Num('0.0'), Num('9.998412'), Num('7.0'), Num('0.123'), Num('-2.0123'), Num('10.0'), Num('6.0')]\r\n\r\nSAVE NUMERIC LIST TO DISK FILE >>>\r\n\r\n\tNum.f_filewrite(L) #\r\n\r\nREAD NUMERIC LIST FROM DISK FILE (nums.txt default filename) >>>\r\n\r\n\tL = Num.f_fileread(); print(L) #[Num('1011.0'), Num('0.0'), Num('9.998412'), Num('7.0'), Num('0.123'), Num('-2.0123'), Num('10.0'), Num('6.0')]\r\n\r\n### FAQ \r\n\r\nQ. I usually try to add 0.1 to 0.2 in python3 with this code:\r\n>>> print(0.1 + 0.2)  \r\nand the result is:  \r\n>>> 0.30000000000000004  \r\nHow instead can it get exactly 0.3?  \r\nA. Using Num class >>>  \r\nfrom num7 import Num, Num as calc  \r\nprint(Num('0.1') + Num('0.2'))  #calc.add('0.1', '0.2') #0.3  \r\n\r\nQ. I'll get an arror when i usually type:  \r\n>>>  Num(0.1) #ValueError: Num.__init__ => float, type not valid: 0.1  \r\nWhat is wrong?  \r\nA. You must use quotes or string conversion with built-in str function:\r\n>>> from num7 import Num, Num as calc  \r\n>>> Num('0.1')    #Num('0.1')  \r\n>>> Num(str(0.1)) #Num('0.1')  \r\n\r\nQ. How can i convert a regular float to a Decimal?\r\nA. With Num.ieee754() method >>>  \r\n\r\n\tfrom num7 import Num, Num as calc  \r\n\ta=0.1; b=0.2;  \r\n\tc=a+b #0.30000000000000004 => PRECISION FAILURE!  \r\n\tan = Num.ieee754(a); print(an)     #0.1000000000000000055511151231257827021181583404541015625  \r\n\tbn = Num.ieee754(b); print(bn)     #0.200000000000000011102230246251565404236316680908203125  \r\n\tcn = Num.ieee754(a+b);  \r\n\tprint(cn, '=> PRECISION FAILURE!') #0.3000000000000000444089209850062616169452667236328125 => PRECISION FAILURE!  \r\n\tT = calc.add(an, bn)  \r\n\tprint(T, '=> OK.')                 #0.3000000000000000166533453693773481063544750213623046875 => OK.  \r\n\r\nQ. I have two float variables in my code:  \r\n>>> a = 0.1; b = 0.2  \r\nHow can i convert them in Num type?  \r\nA. With Num.float2num method (or directly with str() bult-in function) >>>  \r\nfrom num7 import Num, Num as calc  \r\na = 0.1; b = 0.2 #  \r\nan= Num.float2num(a); bn= Num.float2num(b) #an= Num(str(a)); bn= Num(str(b))  \r\nprint(an+bn, 'OK. VS', a+b, 'PRECISION FAILURE!') #0.3 OK. VS 0.30000000000000004 PRECISION FAILURE!  \r\n\r\nQ. Can i do add or other math operations also with 10_000 digits after floating point?  \r\nA. Yes, you can. >>>\r\n\r\n\tfrom num7 import Num, Num as calc  \r\n\tprint((Num('1.123456789e-10_000') + Num('3.987654321e-10_000')).num2exp()) #511111111e-10008  \r\n\tprint((Num('1.123456789e-10_000') - Num('3.987654321e-10_000')).num2exp()) #-2864197532e-10009  \r\n\tprint((Num('1.123456789e-10_000') * Num('3.987654321e-10_000')).num2exp()) #4479957319112635269e-20018  \r\n\tprint((Num('1.123456789e-10_000') / Num('3.987654321e-10_000')))      #0.28173374584742497292307298769992856660154820877213142969420392746224704666420356  \r\n\r\n\r\n\r\n",
            "description_content_type": "text/markdown",
            "docs_url": null,
            "download_url": "",
            "downloads": {
                "last_day": -1,
                "last_month": -1,
                "last_week": -1
            },
            "home_page": "https://github.com/giocip/num7",
            "keywords": "",
            "license": "",
            "maintainer": "",
            "maintainer_email": "",
            "name": "num7",
            "package_url": "https://pypi.org/project/num7/",
            "platform": null,
            "project_url": "https://pypi.org/project/num7/",
            "project_urls": {
                "Homepage": "https://github.com/giocip/num7"
            },
            "release_url": "https://pypi.org/project/num7/1.0.9/",
            "requires_dist": null,
            "requires_python": "",
            "summary": "SUPREME PRECISION GENERAL PURPOSE ARITHMETIC-LOGIC CLASS",
            "version": "1.0.9",
            "yanked": false,
            "yanked_reason": null
        },
        "last_serial": 16050617,
        "urls": [
            {
                "comment_text": "",
                "digests": {
                    "md5": "b0d66614bf4861b243716954da8a9794",
                    "sha256": "a4798bd12a4c4a6be83a61da0955a8eb37e6c7b4db7526d53718f293e7005cae"
                },
                "downloads": -1,
                "filename": "num7-1.0.9-py3-none-any.whl",
                "has_sig": false,
                "md5_digest": "b0d66614bf4861b243716954da8a9794",
                "packagetype": "bdist_wheel",
                "python_version": "py3",
                "requires_python": null,
                "size": 18400,
                "upload_time": "2022-12-09T16:56:22",
                "upload_time_iso_8601": "2022-12-09T16:56:22.274237Z",
                "url": "https://files.pythonhosted.org/packages/78/b7/b255164ae24afd0776b61904a044473142a4863a449ce0ea7fd1b53f8155/num7-1.0.9-py3-none-any.whl",
                "yanked": false,
                "yanked_reason": null
            },
            {
                "comment_text": "",
                "digests": {
                    "md5": "4b88f737b95937141fca45fa8787e036",
                    "sha256": "218e4e1af63b8987f851ac1295f93eaaf4bb83424e917f945a6e02d33dccc813"
                },
                "downloads": -1,
                "filename": "num7-1.0.9.tar.gz",
                "has_sig": false,
                "md5_digest": "4b88f737b95937141fca45fa8787e036",
                "packagetype": "sdist",
                "python_version": "source",
                "requires_python": null,
                "size": 18440,
                "upload_time": "2022-12-09T16:56:24",
                "upload_time_iso_8601": "2022-12-09T16:56:24.000737Z",
                "url": "https://files.pythonhosted.org/packages/6e/92/c1fbd97d9a8175bc7f54a80939de7d2dcbbe4fbac0283cfc33c511c7a0d2/num7-1.0.9.tar.gz",
                "yanked": false,
                "yanked_reason": null
            }
        ],
        "vulnerabilities": []
    }
}