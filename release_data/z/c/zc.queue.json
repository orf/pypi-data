{
    "1.0.1": {
        "info": {
            "author": "Zope Project",
            "author_email": "zope3-dev@zope.org",
            "bugtrack_url": null,
            "classifiers": [],
            "description_content_type": null,
            "docs_url": null,
            "download_url": "UNKNOWN",
            "downloads": {
                "last_day": -1,
                "last_month": -1,
                "last_week": -1
            },
            "home_page": "UNKNOWN",
            "keywords": "zope zope3",
            "license": "ZPL 2.1",
            "maintainer": null,
            "maintainer_email": null,
            "name": "zc.queue",
            "package_url": "https://pypi.org/project/zc.queue/",
            "platform": "UNKNOWN",
            "project_url": "https://pypi.org/project/zc.queue/",
            "project_urls": {
                "Download": "UNKNOWN",
                "Homepage": "UNKNOWN"
            },
            "release_url": "https://pypi.org/project/zc.queue/1.0.1/",
            "requires_dist": null,
            "requires_python": null,
            "summary": "Queues that are optimized for persistency via the ZODB.",
            "version": "1.0.1",
            "yanked": false,
            "yanked_reason": null
        },
        "last_serial": 2896833,
        "urls": [
            {
                "comment_text": "",
                "digests": {
                    "md5": "09fedd6226920bb4fdc008acddf32f38",
                    "sha256": "27f1180f7fc5378f847881b00abca19498e3b3c97ba7afa13fc126e98501d353"
                },
                "downloads": -1,
                "filename": "zc.queue-1.0.1-py2.4.egg",
                "has_sig": false,
                "md5_digest": "09fedd6226920bb4fdc008acddf32f38",
                "packagetype": "bdist_egg",
                "python_version": "2.4",
                "requires_python": null,
                "size": 18187,
                "upload_time": "2006-12-01T14:48:56",
                "upload_time_iso_8601": "2006-12-01T14:48:56Z",
                "url": "https://files.pythonhosted.org/packages/01/d2/7cbec12083a9d4b83840ca3fa6fb7748fcf34d0a05c01dc22acc9ebe8a39/zc.queue-1.0.1-py2.4.egg",
                "yanked": false,
                "yanked_reason": null
            },
            {
                "comment_text": "",
                "digests": {
                    "md5": "3e9dd84de33ef60fc63c0d6834180397",
                    "sha256": "e0da74b2b0bd537c1f2e14bc13bdca50cd6adf11f1fc7b0e8c10aac897f6ea15"
                },
                "downloads": -1,
                "filename": "zc.queue-1.0.1.tar.gz",
                "has_sig": false,
                "md5_digest": "3e9dd84de33ef60fc63c0d6834180397",
                "packagetype": "sdist",
                "python_version": "source",
                "requires_python": null,
                "size": 11054,
                "upload_time": "2006-12-01T04:23:52",
                "upload_time_iso_8601": "2006-12-01T04:23:52Z",
                "url": "https://files.pythonhosted.org/packages/f8/2c/fba91f5e89223b4fc9e40675db35616d03bf09567735e491deb3cb05f3c5/zc.queue-1.0.1.tar.gz",
                "yanked": false,
                "yanked_reason": null
            }
        ],
        "vulnerabilities": []
    },
    "1.1": {
        "info": {
            "author": "Zope Project",
            "author_email": "zope3-dev@zope.org",
            "bugtrack_url": null,
            "classifiers": [],
            "description_content_type": null,
            "docs_url": null,
            "download_url": "UNKNOWN",
            "downloads": {
                "last_day": -1,
                "last_month": -1,
                "last_week": -1
            },
            "home_page": "UNKNOWN",
            "keywords": "zope zope3",
            "license": "ZPL 2.1",
            "maintainer": null,
            "maintainer_email": null,
            "name": "zc.queue",
            "package_url": "https://pypi.org/project/zc.queue/",
            "platform": "UNKNOWN",
            "project_url": "https://pypi.org/project/zc.queue/",
            "project_urls": {
                "Download": "UNKNOWN",
                "Homepage": "UNKNOWN"
            },
            "release_url": "https://pypi.org/project/zc.queue/1.1/",
            "requires_dist": null,
            "requires_python": null,
            "summary": "Queues that are optimized for persistency via the ZODB.",
            "version": "1.1",
            "yanked": false,
            "yanked_reason": null
        },
        "last_serial": 2896833,
        "urls": [
            {
                "comment_text": "",
                "digests": {
                    "md5": "603b9dd9927ab71e9aebbdad11e7d015",
                    "sha256": "c4503b82699d4947e899ba0591e623df8ba97d94b80d1e7e6f03b8f2f26a443c"
                },
                "downloads": -1,
                "filename": "zc.queue-1.1-py2.4.egg",
                "has_sig": false,
                "md5_digest": "603b9dd9927ab71e9aebbdad11e7d015",
                "packagetype": "bdist_egg",
                "python_version": "2.4",
                "requires_python": null,
                "size": 23014,
                "upload_time": "2007-06-26T02:56:38",
                "upload_time_iso_8601": "2007-06-26T02:56:38Z",
                "url": "https://files.pythonhosted.org/packages/62/ce/5be9a8064e3c05dfeb490baaab38db5a2c8adce364180e7fdc342e35692b/zc.queue-1.1-py2.4.egg",
                "yanked": false,
                "yanked_reason": null
            },
            {
                "comment_text": "",
                "digests": {
                    "md5": "a84dd7dc7b390fd9256c05a18f4b79ea",
                    "sha256": "ca34389e61cd772155cf02a325d299c9e23348d188ebc87237af5790789dec9f"
                },
                "downloads": -1,
                "filename": "zc.queue-1.1.tar.gz",
                "has_sig": false,
                "md5_digest": "a84dd7dc7b390fd9256c05a18f4b79ea",
                "packagetype": "sdist",
                "python_version": "source",
                "requires_python": null,
                "size": 17310,
                "upload_time": "2007-06-26T02:56:41",
                "upload_time_iso_8601": "2007-06-26T02:56:41Z",
                "url": "https://files.pythonhosted.org/packages/41/a8/816bb4cde552ed0316e8353960d44f6d25f61ea12df06550414990032007/zc.queue-1.1.tar.gz",
                "yanked": false,
                "yanked_reason": null
            }
        ],
        "vulnerabilities": []
    },
    "1.2": {
        "info": {
            "author": "Zope Project",
            "author_email": "zope-dev@zope.org",
            "bugtrack_url": null,
            "classifiers": [],
            "description_content_type": null,
            "docs_url": null,
            "download_url": "UNKNOWN",
            "downloads": {
                "last_day": -1,
                "last_month": -1,
                "last_week": -1
            },
            "home_page": "UNKNOWN",
            "keywords": "zope zope3",
            "license": "ZPL 2.1",
            "maintainer": null,
            "maintainer_email": null,
            "name": "zc.queue",
            "package_url": "https://pypi.org/project/zc.queue/",
            "platform": "UNKNOWN",
            "project_url": "https://pypi.org/project/zc.queue/",
            "project_urls": {
                "Download": "UNKNOWN",
                "Homepage": "UNKNOWN"
            },
            "release_url": "https://pypi.org/project/zc.queue/1.2/",
            "requires_dist": null,
            "requires_python": null,
            "summary": "Queues that are optimized for persistency via the ZODB.",
            "version": "1.2",
            "yanked": false,
            "yanked_reason": null
        },
        "last_serial": 2896833,
        "urls": [
            {
                "comment_text": "",
                "digests": {
                    "md5": "18f8c8028c935247286919b092cd8674",
                    "sha256": "b44ba1ce642c3cf09c0d6733e2626ccdf95e192c7466bf8a3f1fd21807c0f12c"
                },
                "downloads": -1,
                "filename": "zc.queue-1.2.tar.gz",
                "has_sig": false,
                "md5_digest": "18f8c8028c935247286919b092cd8674",
                "packagetype": "sdist",
                "python_version": "source",
                "requires_python": null,
                "size": 16960,
                "upload_time": "2011-12-18T01:02:35",
                "upload_time_iso_8601": "2011-12-18T01:02:35.979265Z",
                "url": "https://files.pythonhosted.org/packages/c9/5d/4ff0cbc654313208a14ea72cea7e6062b5f5642f2babac7bab039ac66064/zc.queue-1.2.tar.gz",
                "yanked": false,
                "yanked_reason": null
            }
        ],
        "vulnerabilities": []
    },
    "1.2.1": {
        "info": {
            "author": "Zope Project",
            "author_email": "zope-dev@zope.org",
            "bugtrack_url": null,
            "classifiers": [],
            "description_content_type": null,
            "docs_url": null,
            "download_url": "UNKNOWN",
            "downloads": {
                "last_day": -1,
                "last_month": -1,
                "last_week": -1
            },
            "home_page": "UNKNOWN",
            "keywords": "zope zope3",
            "license": "ZPL 2.1",
            "maintainer": null,
            "maintainer_email": null,
            "name": "zc.queue",
            "package_url": "https://pypi.org/project/zc.queue/",
            "platform": "UNKNOWN",
            "project_url": "https://pypi.org/project/zc.queue/",
            "project_urls": {
                "Download": "UNKNOWN",
                "Homepage": "UNKNOWN"
            },
            "release_url": "https://pypi.org/project/zc.queue/1.2.1/",
            "requires_dist": null,
            "requires_python": null,
            "summary": "Queues that are optimized for persistency via the ZODB.",
            "version": "1.2.1",
            "yanked": false,
            "yanked_reason": null
        },
        "last_serial": 2896833,
        "urls": [
            {
                "comment_text": "",
                "digests": {
                    "md5": "5a2e3484d521296235e016db9d045efe",
                    "sha256": "45db19db648ac030b23ee80d5113af86e4b82d18e84d43da84d685f7b3deee14"
                },
                "downloads": -1,
                "filename": "zc.queue-1.2.1.tar.gz",
                "has_sig": false,
                "md5_digest": "5a2e3484d521296235e016db9d045efe",
                "packagetype": "sdist",
                "python_version": "source",
                "requires_python": null,
                "size": 17003,
                "upload_time": "2011-12-18T01:26:48",
                "upload_time_iso_8601": "2011-12-18T01:26:48.763507Z",
                "url": "https://files.pythonhosted.org/packages/f5/0c/947800e3278ff5f743f4de2d2c3cc8a98ffaaa74cf6e289ef1cbc7350920/zc.queue-1.2.1.tar.gz",
                "yanked": false,
                "yanked_reason": null
            }
        ],
        "vulnerabilities": []
    },
    "1.3": {
        "info": {
            "author": "Zope Project",
            "author_email": "zope-dev@zope.org",
            "bugtrack_url": null,
            "classifiers": [],
            "description_content_type": null,
            "docs_url": null,
            "download_url": "UNKNOWN",
            "downloads": {
                "last_day": -1,
                "last_month": -1,
                "last_week": -1
            },
            "home_page": "UNKNOWN",
            "keywords": "zope zope3",
            "license": "ZPL 2.1",
            "maintainer": null,
            "maintainer_email": null,
            "name": "zc.queue",
            "package_url": "https://pypi.org/project/zc.queue/",
            "platform": "UNKNOWN",
            "project_url": "https://pypi.org/project/zc.queue/",
            "project_urls": {
                "Download": "UNKNOWN",
                "Homepage": "UNKNOWN"
            },
            "release_url": "https://pypi.org/project/zc.queue/1.3/",
            "requires_dist": null,
            "requires_python": null,
            "summary": "Queues that are optimized for persistency via the ZODB.",
            "version": "1.3",
            "yanked": false,
            "yanked_reason": null
        },
        "last_serial": 2896833,
        "urls": [
            {
                "comment_text": "",
                "digests": {
                    "md5": "93113bec10a9ddb51b774607fe2a683d",
                    "sha256": "26a3e23d06570f83b9ae687918dfc199c93e56726b4b7e2fcd3c6d6976e69ca7"
                },
                "downloads": -1,
                "filename": "zc.queue-1.3.tar.gz",
                "has_sig": false,
                "md5_digest": "93113bec10a9ddb51b774607fe2a683d",
                "packagetype": "sdist",
                "python_version": "source",
                "requires_python": null,
                "size": 24962,
                "upload_time": "2012-01-12T00:33:26",
                "upload_time_iso_8601": "2012-01-12T00:33:26.435864Z",
                "url": "https://files.pythonhosted.org/packages/46/ec/e1381af7baa8384269ae37ffdeade3c643c9116b3646a655ff6bd2faca56/zc.queue-1.3.tar.gz",
                "yanked": false,
                "yanked_reason": null
            }
        ],
        "vulnerabilities": []
    },
    "2.0.0": {
        "info": {
            "author": "",
            "author_email": "",
            "bugtrack_url": null,
            "classifiers": [
                "Framework :: Zope3",
                "Programming Language :: Python",
                "Programming Language :: Python :: 2",
                "Programming Language :: Python :: 2.7",
                "Programming Language :: Python :: 3",
                "Programming Language :: Python :: 3.4",
                "Programming Language :: Python :: 3.5",
                "Programming Language :: Python :: 3.6",
                "Programming Language :: Python :: Implementation :: CPython",
                "Programming Language :: Python :: Implementation :: PyPy"
            ],
            "description_content_type": null,
            "docs_url": null,
            "download_url": "",
            "downloads": {
                "last_day": -1,
                "last_month": -1,
                "last_week": -1
            },
            "home_page": "",
            "keywords": "",
            "license": "",
            "maintainer": "",
            "maintainer_email": "",
            "name": "zc.queue",
            "package_url": "https://pypi.org/project/zc.queue/",
            "platform": "",
            "project_url": "https://pypi.org/project/zc.queue/",
            "project_urls": null,
            "release_url": "https://pypi.org/project/zc.queue/2.0.0/",
            "requires_dist": [
                "setuptools",
                "ZODB",
                "persistent",
                "zope.interface",
                "zope.testing; extra == 'test'",
                "zope.testrunner; extra == 'test'"
            ],
            "requires_python": "",
            "summary": "Queues that are optimized for persistency via the ZODB.",
            "version": "2.0.0",
            "yanked": false,
            "yanked_reason": null
        },
        "last_serial": 2896833,
        "urls": [
            {
                "comment_text": "",
                "digests": {
                    "md5": "7f843608e61fcead505f8d115c381520",
                    "sha256": "6c492e4fc7440b01693f52c0b22e23e4d7dbe5f6eb40fec06e8e54231e4f4f3a"
                },
                "downloads": -1,
                "filename": "zc.queue-2.0.0-py2.py3-none-any.whl",
                "has_sig": false,
                "md5_digest": "7f843608e61fcead505f8d115c381520",
                "packagetype": "bdist_wheel",
                "python_version": "py2.py3",
                "requires_python": null,
                "size": 29142,
                "upload_time": "2017-05-11T13:34:23",
                "upload_time_iso_8601": "2017-05-11T13:34:23.730572Z",
                "url": "https://files.pythonhosted.org/packages/bb/6b/74abe8cbfedd1df08277a3958ee09e553bbba2e66b8a66cae42cd7e93b79/zc.queue-2.0.0-py2.py3-none-any.whl",
                "yanked": false,
                "yanked_reason": null
            },
            {
                "comment_text": "",
                "digests": {
                    "md5": "6055315f3fb74648a22368e04ef79585",
                    "sha256": "fe12171e05b177506b97666507659dc4bb3babd74869dc6000291baefe1a8940"
                },
                "downloads": -1,
                "filename": "zc.queue-2.0.0.tar.gz",
                "has_sig": false,
                "md5_digest": "6055315f3fb74648a22368e04ef79585",
                "packagetype": "sdist",
                "python_version": "source",
                "requires_python": null,
                "size": 29702,
                "upload_time": "2017-05-11T13:34:25",
                "upload_time_iso_8601": "2017-05-11T13:34:25.514381Z",
                "url": "https://files.pythonhosted.org/packages/60/70/95c7c8ade25ff3cad0f872b00c0f93f191c1e17b6de73634c6fcb9c8ec26/zc.queue-2.0.0.tar.gz",
                "yanked": false,
                "yanked_reason": null
            }
        ],
        "vulnerabilities": []
    },
    "2.0.0a1": {
        "info": {
            "author": "Zope Project",
            "author_email": "zope-dev@zope.org",
            "bugtrack_url": null,
            "classifiers": [
                "Development Status :: 5 - Production/Stable",
                "Framework :: Zope3",
                "Intended Audience :: Developers",
                "License :: OSI Approved :: Zope Public License",
                "Natural Language :: English",
                "Operating System :: OS Independent",
                "Programming Language :: Python",
                "Programming Language :: Python :: 2",
                "Programming Language :: Python :: 2.6",
                "Programming Language :: Python :: 2.7",
                "Programming Language :: Python :: 3",
                "Programming Language :: Python :: 3.3",
                "Programming Language :: Python :: Implementation :: CPython"
            ],
            "description": "=================\nPersistent Queues\n=================\n\nPersistent queues are simply queues that are optimized for persistency via the\nZODB. They assume that the ZODB is using MVCC to avoid read conflicts. They\nattempt to resolve write conflicts so that transactions that add and remove\nobjects simultaneously are merged, unless the transactions are trying to\nremove the same value from the queue.\n\nAn important characteristic of these queues is that they do not expect to\nhold more than one reference to any given equivalent item at a time.  For\ninstance, some of the conflict resolution features will not perform\ndesirably if it is reasonable for your application to hold two copies of the\nstring \"hello\" within the same queue at once [#why]_.\n\nThe module provides two flavors: a simple persistent queue that keeps all\ncontained objects in one persistent object (`Queue`), and a\npersistent queue that divides up its contents into multiple composite\nelements (`CompositeQueue`). They should be equivalent in terms of\nAPI and so are mostly examined in the abstract in this document: we'll generate\ninstances with a representative `Queue` factory, that could be either class.\nThey only differ in an aspect of their write conflict resolution behavior,\nwhich is discussed below.\n\nQueues can be instantiated with no arguments.\n\n    >>> q = Queue()\n    >>> from zc.queue.interfaces import IQueue\n    >>> from zope.interface.verify import verifyObject\n    >>> verifyObject(IQueue, q)\n    True\n\nThe basic API is simple: use `put` to add items to the back of the queue, and\n`pull` to pull things off the queue, defaulting to the front of the queue.\nNote that `Item` could be either persistent or non persistent object.\n\n    >>> q.put(Item(1))\n    >>> q.put(Item(2))\n    >>> q.pull()\n    1\n    >>> q.put(Item(3))\n    >>> q.pull()\n    2\n    >>> q.pull()\n    3\n\nThe `pull` method takes an optional zero-based index argument, and can accept\nnegative values.\n\n    >>> q.put(Item(4))\n    >>> q.put(Item(5))\n    >>> q.put(Item(6))\n    >>> q.pull(-1)\n    6\n    >>> q.pull(1)\n    5\n    >>> q.pull(0)\n    4\n\nRequesting an item from an empty queue raises an IndexError.\n\n    >>> q.pull() # doctest: +ELLIPSIS\n    Traceback (most recent call last):\n    ...\n    IndexError: ...\n\nRequesting an invalid index value does the same.\n\n    >>> q.put(Item(7))\n    >>> q.put(Item(8))\n    >>> q.pull(2) # doctest: +ELLIPSIS\n    Traceback (most recent call last):\n    ...\n    IndexError: ...\n\nBeyond these core queue operations, queues support len...\n\n    >>> len(q)\n    2\n    >>> q.pull()\n    7\n    >>> len(q)\n    1\n    >>> q.pull()\n    8\n    >>> len(q)\n    0\n\n...iter (which does *not* empty the queue)...\n\n    >>> next(iter(q))\n    Traceback (most recent call last):\n    ...\n    StopIteration\n    >>> q.put(Item(9))\n    >>> q.put(Item(10))\n    >>> q.put(Item(11))\n    >>> next(iter(q))\n    9\n    >>> [i for i in q]\n    [9, 10, 11]\n    >>> q.pull()\n    9\n    >>> [i for i in q]\n    [10, 11]\n\n...bool...\n\n    >>> bool(q)\n    True\n    >>> q.pull()\n    10\n    >>> q.pull()\n    11\n    >>> bool(q)\n    False\n\n...and list-like bracket access (which again does *not* empty the queue).\n\n    >>> q.put(Item(12))\n    >>> q[0]\n    12\n    >>> q.pull()\n    12\n    >>> q[0] # doctest: +ELLIPSIS\n    Traceback (most recent call last):\n    ...\n    IndexError: ...\n    >>> for i in range (13, 23):\n    ...     q.put(Item(i))\n    ...\n    >>> q[0]\n    13\n    >>> q[1]\n    14\n    >>> q[2]\n    15\n    >>> q[-1]\n    22\n    >>> q[-10]\n    13\n\nThat's it--there's no additional way to add anything beyond `put`, and no\nadditional way to remove anything beyond `pull`.\n\nThe only other wrinkle is the conflict resolution code.  Conflict\nresolution in ZODB has some general caveats of which you should be aware\n[#caveats]_.\n\nThese general caveats aside, we'll now examine some examples of zc.queue\nconflict resolution at work.  To show this, we will have to have two\ncopies of the same queue, from two different connections.\n\nNOTE: this testing approach has known weaknesses.  See discussion in tests.py.\n\n    >>> import transaction\n    >>> from zc.queue.tests import ConflictResolvingMappingStorage\n    >>> from ZODB import DB\n    >>> db = DB(ConflictResolvingMappingStorage('test'))\n    >>> transactionmanager_1 = transaction.TransactionManager()\n    >>> transactionmanager_2 = transaction.TransactionManager()\n    >>> connection_1 = db.open(transaction_manager=transactionmanager_1)\n    >>> root_1 = connection_1.root()\n\n    >>> q_1 = root_1[\"queue\"] = Queue()\n    >>> transactionmanager_1.commit()\n\n    >>> transactionmanager_2 = transaction.TransactionManager()\n    >>> connection_2 = db.open(transaction_manager=transactionmanager_2)\n    >>> root_2 = connection_2.root()\n    >>> q_2 = root_2['queue']\n\nNow we have two copies of the same queue, with separate transaction managers\nand connections about the same way two threads would have them. The '_1'\nsuffix identifies the objects for user 1, in thread 1; and the '_2' suffix\nidentifies the objects for user 2, in a concurrent thread 2.\n\nFirst, let's have the two users add some items to the queue concurrently.\nFor concurrent commits of only putting a single new item (one each in two\ntransactions), in both types of queue the user who commits first gets the\nlower position in the queue--that is, the position that will leave the queue\nsooner using default `pull` calls.\n\nIn this example, even though q_1 is modified first, q_2's transaction is\ncommitted first, so q_2's addition is first after the merge.\n\n    >>> q_1.put(Item(1001))\n    >>> q_2.put(Item(1000))\n    >>> transactionmanager_2.commit()\n    >>> transactionmanager_1.commit()\n    >>> connection_1.sync()\n    >>> connection_2.sync()\n    >>> list(q_1)\n    [1000, 1001]\n    >>> list(q_2)\n    [1000, 1001]\n\nFor commits of more than one additions per connection of two, or of more than\ntwo concurrent adding transactions, the behavior is the same for the\nQueue: the first commit's additions will go before the second\ncommit's.\n\n    >>> from zc import queue\n    >>> if isinstance(q_1, queue.Queue):\n    ...     for i in range(5):\n    ...         q_1.put(Item(i))\n    ...     for i in range(1002, 1005):\n    ...         q_2.put(Item(i))\n    ...     transactionmanager_2.commit()\n    ...     transactionmanager_1.commit()\n    ...     connection_1.sync()\n    ...     connection_2.sync()\n    ...\n\nAs we'll see below, that will again reliably put all the values from the first\ncommit earlier in the queue, to result in\n[1000, 1001, 1002, 1003, 1004, 0, 1, 2, 3, 4].\n\nFor the CompositeQueue, the behavior is different.  The order\nwill be maintained with a set of additions in a transaction, but the values\nmay be merged between the two transactions' additions.  We will compensate\nfor that here to get a reliable queue state.\n\n    >>> if isinstance(q_1, queue.CompositeQueue):\n    ...     for i1, i2 in ((1002, 1003), (1004, 0), (1, 2), (3, 4)):\n    ...         q_1.put(Item(i1))\n    ...         q_2.put(Item(i2))\n    ...         transactionmanager_1.commit()\n    ...         transactionmanager_2.commit()\n    ...         connection_1.sync()\n    ...         connection_2.sync()\n    ...\n\nWhichever kind of queue we have, we now have the following values.\n\n    >>> list(q_1)\n    [1000, 1001, 1002, 1003, 1004, 0, 1, 2, 3, 4]\n    >>> list(q_2)\n    [1000, 1001, 1002, 1003, 1004, 0, 1, 2, 3, 4]\n\nIf two users try to add the same item, then a conflict error is raised.\n\n    >>> five = Item(5)\n    >>> q_1.put(five)\n    >>> q_2.put(five)\n    >>> transactionmanager_1.commit()\n    >>> from ZODB.POSException import ConflictError, InvalidObjectReference\n    >>> try:\n    ...     transactionmanager_2.commit() # doctest: +ELLIPSIS\n    ... except (ConflictError, InvalidObjectReference):\n    ...     print(\"Conflict Error\")\n    Conflict Error\n    >>> transactionmanager_2.abort()\n    >>> connection_1.sync()\n    >>> connection_2.sync()\n    >>> list(q_1)\n    [1000, 1001, 1002, 1003, 1004, 0, 1, 2, 3, 4, 5]\n    >>> list(q_2)\n    [1000, 1001, 1002, 1003, 1004, 0, 1, 2, 3, 4, 5]\n\nUsers can also concurrently remove items from a queue...\n\n    >>> q_1.pull()\n    1000\n    >>> q_1[0]\n    1001\n\n    >>> q_2.pull(5)\n    0\n    >>> q_2[5]\n    1\n\n    >>> q_2[0] # 1000 value still there in this connection\n    1000\n\n    >>> q_1[4] # 0 value still there in this connection.\n    0\n\n    >>> transactionmanager_1.commit()\n    >>> transactionmanager_2.commit()\n    >>> connection_1.sync()\n    >>> connection_2.sync()\n    >>> list(q_1)\n    [1001, 1002, 1003, 1004, 1, 2, 3, 4, 5]\n    >>> list(q_2)\n    [1001, 1002, 1003, 1004, 1, 2, 3, 4, 5]\n\n...as long as they don't remove the same item.\n\n    >>> q_1.pull()\n    1001\n    >>> q_2.pull()\n    1001\n    >>> transactionmanager_1.commit()\n    >>> transactionmanager_2.commit() # doctest: +ELLIPSIS\n    Traceback (most recent call last):\n    ...\n    ConflictError: ...\n    >>> transactionmanager_2.abort()\n    >>> connection_1.sync()\n    >>> connection_2.sync()\n    >>> list(q_1)\n    [1002, 1003, 1004, 1, 2, 3, 4, 5]\n    >>> list(q_2)\n    [1002, 1003, 1004, 1, 2, 3, 4, 5]\n\nThere's actually a special case: the composite queue's buckets will refuse to\nmerge if they started with a non-empty state, and one of the two new states\nis empty.  This is to prevent the loss of an addition to the queue.  See\ntests.py for an example.\n\nAlso importantly, users can concurrently remove and add items to a queue.\n\n    >>> q_1.pull()\n    1002\n    >>> q_1.pull()\n    1003\n    >>> q_1.pull()\n    1004\n    >>> q_2.put(Item(6))\n    >>> q_2.put(Item(7))\n    >>> transactionmanager_1.commit()\n    >>> transactionmanager_2.commit()\n    >>> connection_1.sync()\n    >>> connection_2.sync()\n    >>> list(q_1)\n    [1, 2, 3, 4, 5, 6, 7]\n    >>> list(q_2)\n    [1, 2, 3, 4, 5, 6, 7]\n\nAs a final example, we'll show the conflict resolution code under extreme\nduress, with multiple simultaneous puts and pulls.\n\n    >>> res_1 = []\n    >>> for i in range(6, -1, -2):\n    ...     res_1.append(q_1.pull(i))\n    ...\n    >>> res_1\n    [7, 5, 3, 1]\n    >>> res_2 = []\n    >>> for i in range(5, 0, -2):\n    ...     res_2.append(q_2.pull(i))\n    ...\n    >>> res_2\n    [6, 4, 2]\n    >>> for i in range(8, 12):\n    ...     q_1.put(Item(i))\n    ...\n    >>> for i in range(12, 16):\n    ...     q_2.put(Item(i))\n    ...\n    >>> list(q_1)\n    [2, 4, 6, 8, 9, 10, 11]\n    >>> list(q_2)\n    [1, 3, 5, 7, 12, 13, 14, 15]\n    >>> transactionmanager_1.commit()\n    >>> transactionmanager_2.commit()\n    >>> connection_1.sync()\n    >>> connection_2.sync()\n\nAfter these commits, if the queue is a Queue, the new values are\nin the order of their commit.  However, as discussed above, if the queue is\na CompositeQueue the behavior is different. While the order will be\nmaintained comparitively--so if object `A` is ahead of object `B` in the queue\non commit then `A` will still be ahead of `B` after a merge of the conflicting\ntransactions--values may be interspersed between the two transactions.\n\nFor instance, if our example queue were a Queue, the values would\nbe [8, 9, 10, 11, 12, 13, 14, 15].  However, if it were a\nCompositeQueue, the values might be the same, or might be any\ncombination in which [8, 9, 10, 11] and [12, 13, 14, 15], from the two\ntransactions, are still in order.  One ordering might be\n[8, 9, 12, 13, 10, 11, 14, 15], for instance.\n\n    >>> if isinstance(q_1, queue.Queue):\n    ...     res_1 = list(q_1)\n    ...     res_2 = list(q_2)\n    ... elif isinstance(q_1, queue.CompositeQueue):\n    ...     firstsrc_1 = list(q_1)\n    ...     firstsrc_2 = list(q_2)\n    ...     secondsrc_1 = firstsrc_1[:]\n    ...     secondsrc_2 = firstsrc_2[:]\n    ...     for val in [12, 13, 14, 15]:\n    ...         firstsrc_1.remove(Item(val))\n    ...         firstsrc_2.remove(Item(val))\n    ...     for val in [8, 9, 10, 11]:\n    ...         secondsrc_1.remove(Item(val))\n    ...         secondsrc_2.remove(Item(val))\n    ...     res_1 = firstsrc_1 + secondsrc_1\n    ...     res_2 = firstsrc_2 + secondsrc_2\n    ...\n    >>> res_1\n    [8, 9, 10, 11, 12, 13, 14, 15]\n    >>> res_2\n    [8, 9, 10, 11, 12, 13, 14, 15]\n\n    >>> db.close() # cleanup\n\n\n========================\nPersistentReferenceProxy\n========================\n\nAs `ZODB.ConflictResolution.PersistentReference` doesn't get handled\nproperly in `set` due to lack of `__hash__` method, we define a class\nutilizing `__cmp__` method of contained items [#workaround]_.\n\n\nLet's make some stub persistent reference objects. Also make some\nobjects that have same oid to simulate different transaction states.\n\n    >>> from zc.queue.tests import StubPersistentReference\n    >>> pr1 = StubPersistentReference(1)\n    >>> pr2 = StubPersistentReference(2)\n    >>> pr3 = StubPersistentReference(3)\n    >>> pr_c1 = StubPersistentReference(1)\n    >>> pr_c2 = StubPersistentReference(2)\n    >>> pr_c3 = StubPersistentReference(3)\n\n    >>> pr1 == pr_c1\n    True\n    >>> pr2 == pr_c2\n    True\n    >>> pr3 == pr_c3\n    True\n    >>> id(pr1) == id(pr_c1)\n    False\n    >>> id(pr2) == id(pr_c2)\n    False\n    >>> id(pr3) == id(pr_c3)\n    False\n\n    >>> set1 = set((pr1, pr2))\n    >>> set1\n    set([SPR (1), SPR (2)])\n    >>> len(set1)\n    2\n    >>> set2 = set((pr_c1, pr_c3))\n    >>> set2\n    set([SPR (1), SPR (3)])\n    >>> len(set2)\n    2\n    >>> set_c1 = set((pr_c1, pr_c2))\n    >>> set_c1\n    set([SPR (1), SPR (2)])\n    >>> len(set_c1)\n    2\n\n`set` doesn't handle persistent reference objects properly. All\nfollowing set operations produce wrong results.\n\nDeduplication:\n\n    >>> set((pr1, pr_c1))\n    set([SPR (1), SPR (1)])\n    >>> set((pr2, pr_c2))\n    set([SPR (2), SPR (2)])\n    >>> set((pr1, pr_c1, pr2))\n    set([SPR (1), SPR (1), SPR (2)])\n    >>> set4 = set((pr1, pr2, pr3, pr_c1, pr_c2, pr_c3))\n    >>> len(set4)\n    6\n\nMinus operation:\n\n    >>> set3 = set1 - set2\n    >>> len(set3)\n    2\n    >>> set3\n    set([SPR (1), SPR (2)])\n\nContains:\n\n    >>> pr3 in set2\n    False\n\nIntersection:\n\n    >>> set1 & set2\n    set([])\n\nCompare:\n\n    >>> set1 == set_c1\n    False\n\nSo we made `PersistentReferenceProxy` wrapping `PersistentReference`\nto work with sets.\n\n    >>> from zc.queue._queue import PersistentReferenceProxy\n    >>> prp1 = PersistentReferenceProxy(pr1)\n    >>> prp2 = PersistentReferenceProxy(pr2)\n    >>> prp3 = PersistentReferenceProxy(pr3)\n    >>> prp_c1 = PersistentReferenceProxy(pr_c1)\n    >>> prp_c2 = PersistentReferenceProxy(pr_c2)\n    >>> prp_c3 = PersistentReferenceProxy(pr_c3)\n    >>> prp1 == prp_c1\n    True\n    >>> prp2 == prp_c2\n    True\n    >>> prp3 == prp_c3\n    True\n    >>> id(prp1) == id(prp_c1)\n    False\n    >>> id(prp2) == id(prp_c2)\n    False\n    >>> id(prp3) == id(prp_c3)\n    False\n\n    >>> set1 = set((prp1, prp2))\n    >>> set1\n    set([SPR (1), SPR (2)])\n    >>> len(set1)\n    2\n    >>> set2 = set((prp_c1, prp_c3))\n    >>> set2\n    set([SPR (1), SPR (3)])\n    >>> len(set2)\n    2\n    >>> set_c1 = set((prp_c1, prp_c2))\n    >>> set_c1\n    set([SPR (1), SPR (2)])\n    >>> len(set_c1)\n    2\n\n`set` handles persistent reference properly now. All following set\noperations produce correct results.\n\nDeduplication:\n\n    >>> set4 = set((prp1, prp2, prp3, prp_c1, prp_c2, prp_c3))\n    >>> len(set4)\n    3\n    >>> set((prp1, prp_c1))\n    set([SPR (1)])\n    >>> set((prp2, prp_c2))\n    set([SPR (2)])\n    >>> set((prp1, prp_c1, prp2))\n    set([SPR (1), SPR (2)])\n\nMinus operation:\n\n    >>> set3 = set1 - set2\n    >>> len(set3)\n    1\n    >>> set3\n    set([SPR (2)])\n    >>> set1 - set1\n    set([])\n    >>> set2 - set3\n    set([SPR (1), SPR (3)])\n    >>> set3 - set2\n    set([SPR (2)])\n\nContains:\n\n    >>> prp3 in set2\n    True\n    >>> prp1 in set2\n    True\n    >>> prp_c1 in set2\n    True\n    >>> prp2 not in set2\n    True\n\nIntersection:\n\n    >>> set1 & set2\n    set([SPR (1)])\n    >>> set1 & set_c1\n    set([SPR (1), SPR (2)])\n    >>> set2 & set3\n    set([])\n\nCompare:\n\n    >>> set1 == set_c1\n    True\n    >>> set1 == set2\n    False\n    >>> set1 == set4\n    False\n\n\n-----\n\n.. [#why] The queue's `pull` method is actually the interesting part in why\n    this constraint is used, and it becomes more so when you allow an\n    arbitrary pull.  By asserting that you do not support having equal\n    items in the queue at once, you can simply say that when you remove\n    equal objects in the current state and the contemporary, conflicting\n    state, it's a conflict error.  Ideally you don't enter another equal\n    item in that queue again, or else in fact this is still an\n    error-prone heuristic:\n\n      - start queue == [X];\n      - begin transactions A and B;\n      - B removes X and commits;\n      - transaction C adds X and Y and commits;\n      - transaction A removes X and tries to commit, and conflict resolution\n        code believes that it is ok to remove the new X from transaction C\n        because it looks like it was just an addition of Y).  Commit succeeds,\n        and should not.\n\n    If you don't assert that you can use equality to examine conflicts,\n    then you have to come up with another heuristic.  Given that the\n    conflict resolution code only gets three states to resolve, I don't\n    know of a reliable one.\n\n    Therefore, zc.queue has a policy of assuming that it can use\n    equality to distinguish items.  It's limiting, but the code can have\n    a better confidence of doing the right thing.\n\n    Also, FWIW, this is policy I want: for my use cases, it would be\n    possible to put in two items in a queue that handle the same issue.\n    With the right equality code, this can be avoided with the policy\n    the queue has now.\n\n.. [#caveats] Here are a few caveats about the state (as of this\n    writing) of ZODB conflict resolution in general.\n\n    The biggest is that, if you store persistent.Persistent subclass\n    objects in a queue (or any other collection with conflict resolution\n    code, such as a BTree), the collection will get a placeholder object\n    (ZODB.ConflictResolution.PersistentReference), rather than the real\n    contained object.  This object has __cmp__ method, but doesn't have\n    __hash__ method, The same oid will get different placeholder in the\n    different states because of different identity in memory (e.g. `id(obj)`)\n    for conflict resolution, which is wrong behavior in a queue.\n\n    Another is that, in ZEO, conflict resolution is currently done on\n    the server, so the ZEO server must have a copy of the classes\n    (software) necessary to instantiate any non-persistent object in the\n    collection.\n\n    A corollary to the above is that objects such as\n    zope.app.keyreference.persistent, which are not persistent\n    themselves but rely on a persistent object for their __cmp__, will\n    fail during conflict resolution.  A reasonable solution in the case\n    of zope.app.keyreference.persistent code is to have the object store\n    the information it needs to do the comparison on itself, so the\n    absence of the persistent object during conflict resolution is\n    unimportant.\n\n.. [#workaround] The reason why we defined\n    `PersistentReferenceProxy` is that there would be a significant risk\n    of unintended consequenses for some ZODB users if we add __hash__\n    method to PersistentReference.\n\n\n=======\nCHANGES\n=======\n\n2.0.0a1 (2013-03-01)\n====================\n\n- Added support for Python 3.3.\n\n- Replaced deprecated ``zope.interface.implements`` usage with equivalent\n  ``zope.interface.implementer`` decorator.\n\n- Dropped support for Python 2.4 and 2.5.\n\n- Fixed an issue where slicing a composite queue would fail due to a\n  programming error.\n  [malthe]\n\n\n1.3 (2012-01-11)\n================\n\n- Fixed a conflict resolution bug that didn't handle\n  `ZODB.ConflictResolution.PersistentReference` correctly.\n  Note that due to syntax we require Python 2.5 or higher now.\n\n\n1.2.1 (2011-12-17)\n==================\n\n- Fixed ImportError in setup.py.\n  [maurits]\n\n\n1.2 (2011-12-17)\n================\n\n- Fixed undefined ZODB.POSException.StorageTransactionError in tests.\n\n- Let tests pass with ZODB 3.8 and ZODB 3.9.\n\n- Added test extra to declare test dependency on ``zope.testing``.\n\n- Using Python's ``doctest`` module instead of deprecated\n  ``zope.testing.doctest``.\n\n- Clean up the generation of reST docs.\n\n\n1.1\n===\n\n- Fixed a conflict resolution bug in CompositeQueue\n\n- Renamed PersistentQueue to Queue, CompositePersistentQueue to\n  CompositeQueue. The old names are nominally deprecated, although no\n  warnings are generated and there are no current plans to eliminate\n  them.  The PersistentQueue class has more conservative conflict\n  resolution than it used to.  (The Queue class has the same conflict\n  resolution as the PersistentQueue used to have.)\n\n1.0.1\n=====\n\n- Minor buildout changes\n\n- Initial release to PyPI\n\n1.0\n===\n\n- Initial release to zope.org",
            "description_content_type": null,
            "docs_url": null,
            "download_url": "UNKNOWN",
            "downloads": {
                "last_day": -1,
                "last_month": -1,
                "last_week": -1
            },
            "home_page": "http://pypi.python.org/pypi/zc.queue",
            "keywords": "zope zope3",
            "license": "ZPL 2.1",
            "maintainer": null,
            "maintainer_email": null,
            "name": "zc.queue",
            "package_url": "https://pypi.org/project/zc.queue/",
            "platform": "UNKNOWN",
            "project_url": "https://pypi.org/project/zc.queue/",
            "project_urls": {
                "Download": "UNKNOWN",
                "Homepage": "http://pypi.python.org/pypi/zc.queue"
            },
            "release_url": "https://pypi.org/project/zc.queue/2.0.0a1/",
            "requires_dist": null,
            "requires_python": null,
            "summary": "Queues that are optimized for persistency via the ZODB.",
            "version": "2.0.0a1",
            "yanked": false,
            "yanked_reason": null
        },
        "last_serial": 2896833,
        "urls": [
            {
                "comment_text": "",
                "digests": {
                    "md5": "e17379d412be5fc44f9fe55c99d77537",
                    "sha256": "07a5af7f9897849c9dcb1bb7e53be115b52b3a242e2ca0681fb97a00f4e2330c"
                },
                "downloads": -1,
                "filename": "zc.queue-2.0.0a1.tar.gz",
                "has_sig": false,
                "md5_digest": "e17379d412be5fc44f9fe55c99d77537",
                "packagetype": "sdist",
                "python_version": "source",
                "requires_python": null,
                "size": 24336,
                "upload_time": "2013-03-01T21:44:36",
                "upload_time_iso_8601": "2013-03-01T21:44:36.379170Z",
                "url": "https://files.pythonhosted.org/packages/3a/6f/03cc4224aee0907f0f6697ead40c1a8f62dffbfe362c6fb84176fe611610/zc.queue-2.0.0a1.tar.gz",
                "yanked": false,
                "yanked_reason": null
            }
        ],
        "vulnerabilities": []
    }
}