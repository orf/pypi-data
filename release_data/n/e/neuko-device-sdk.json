{
    "1.0.4": {
        "info": {
            "author": "neuko.io",
            "author_email": "hello@neuko.io",
            "bugtrack_url": null,
            "classifiers": [
                "Development Status :: 5 - Production/Stable",
                "Intended Audience :: Developers",
                "License :: OSI Approved :: MIT License",
                "Programming Language :: Python :: 3.10",
                "Programming Language :: Python :: 3.6",
                "Programming Language :: Python :: 3.7",
                "Programming Language :: Python :: 3.8",
                "Programming Language :: Python :: 3.9",
                "Topic :: Software Development :: Libraries :: Application Frameworks"
            ],
            "description": "Device SDK for Python\n=====================\n\nThis document provides information about the Neuko SDK that can be\ninstalled as a dependency in an IoT device.\n\nPre-requisites\n--------------\n\n1. Neuko account (sign up\n   `here <https://auth.neuko.io/signup?client_id=30qirvopvpabg1njrdp4mt54tl&response_type=code&scope=email+openid+profile&redirect_uri=https://app.neuko.io/oauth>`__)\n2. Defined device type schema (refer\n   `documentation <https://neuko.io/docs/schema/>`__)\n3. Bootstrap certificates that can downloaded after define a device type\n   schema (step 2)\n\nDevice State\n------------\n\nDevice state is the condition of the hardware at any moment. Typically,\nthe state will be watched, executed and updated under certain\ncircumstances. You can imagine the state of a digital board as below:\n\n.. code:: json\n\n   {\n       \"digital_input\": {\n           \"pin_0\": true,\n           \"pin_1\": false\n       },\n       \"digital_output\": {\n           \"pin_0\": true,\n           \"pin_1\": true\n       }\n   }\n\nThe above example tells us that the digital board has 2 states: 1.\ndigital input 2. digital output\n\nAlso, each state has 2 attributes - pin 0 and pin 1.\n\nThe Neuko Python SDK works by managing the state\u2019s attributes of the\ndevice between actual physical and its virtual representation in cloud.\n\nPrior to that, the SDK supports provisioning of a new device during 1st\ntime connection.\n\nInstallation\n------------\n\nChecking minimum requirement\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nThe SDK requires Python 3.6 and above.\n\n.. code:: python\n\n   python --version\n\n.. _installation-1:\n\nInstallation\n~~~~~~~~~~~~\n\n.. code:: python\n\n   pip install neuko-device-sdk\n\nUsage\n-----\n\nImport package\n~~~~~~~~~~~~~~\n\n.. code:: python\n\n   from neuko.device.device import Device\n   from neuko.iot.bootstrap import BootstrapClient\n   from neuko.iot.neuko import NeukoClient\n\nExtend DeviceIdentifierStore class\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n.. code:: python\n\n   class DeviceIdentifierStoreObject(DeviceIdentifierStore):\n       def getAccountId(self) -> str:\n           return \"<Neuko Account Id>\"\n\n       def getProjectId(self) -> str:\n           return \"<Neuko Project Id>\"\n\n       def getDeviceSchemaId(self) -> str:\n           return \"<Device Serial Number / Id>\"\n\n       def getDeviceId(self) -> str:\n           return \"<Neuko Device Type Schema Id>\"\n\nExtend ConnectionStore class\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n.. code:: python\n\n   class ConnectionStoreObject(ConnectionStore):\n       async def getPerpetualConnectionSettings(self, deviceIdentifier: DeviceIdentifier) -> str:\n           fd = open(\"./my-secure-directory/neuko-device-connection-settings.json\", mode=\"r\")\n           raw = json.load(fd)\n           fd.close()\n           return raw\n\n       async def savePerpetualConnectionSettings(self, deviceIdentifier: DeviceIdentifier, settings: str) -> bool:\n           fd = open(\"./my-secure-directory/neuko-device-connection-settings.json\", mode=\"w\")\n           json.dump(settings, fd)\n           fd.close()\n           return True\n\n       async def deletePerpetualConnectionSettings(self, deviceIdentifier: DeviceIdentifier) -> bool:\n           return True\n\n       async def isPerpetualConnectionSettingsExists(self, deviceIdentifier: DeviceIdentifier) -> bool:\n           return False\n   }\n\nExtend CertificateStore class\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n.. code:: python\n\n   class CertificateStoreObject(CertificateStore):\n\n       async def getBootstrapCertificateAuthority(self, deviceIdentifier: DeviceIdentifier) -> str:\n           return \"./my-secure-directory/certificates/cert.ca.pem\"\n\n       async def getBootstrapChainCertificate(self, deviceIdentifier: DeviceIdentifier) -> str:\n           return \"./my-secure-directory/certificates/bootstrap-certificate.pem.crt\"\n\n       async def getBootstrapPrivateKey(self, deviceIdentifier: DeviceIdentifier) -> str:\n           return \"./my-secure-directory/certificates/bootstrap-private.pem.key\"\n\n       async def getPerpetualCertificateAuthority(self, deviceIdentifier: DeviceIdentifier) -> str:\n           fd = open(\"./my-secure-directory/certificates/cert.ca.pem\", mode=\"r\")\n           raw = fd.read()\n           fd.close()\n           return raw\n\n       async def getPerpetualChainCertificate(self, deviceIdentifier: DeviceIdentifier) -> str:\n           fd = open(\"./my-secure-directory/certificates/certificate.pem.crt\", mode=\"r\")\n           raw = fd.read()\n           fd.close()\n           return raw\n\n       async def getPerpetualPrivateKey(self, deviceIdentifier: DeviceIdentifier) -> str:\n           fd = open(\"./my-secure-directory/certificates/cert.ca.pem\", mode=\"r\")\n           raw = fd.read()\n           fd.close()\n           return raw\n\n       async def savePerpetualCertificateAuthority(self, deviceIdentifier: DeviceIdentifier, certificate: str) -> None:\n           fd = open(\"./my-secure-directory/certificates/cert.ca.pem\", mode=\"w\")\n           fd.write(certificate)\n           fd.close()\n\n       async def savePerpetualChainCertificate(self, deviceIdentifier: DeviceIdentifier, certificate: str) -> None:\n           fd = open(\"./my-secure-directory/certificates/certificate.pem.crt\"\", mode=\"w\")\n           fd.write(certificate)\n           fd.close()\n\n       async def savePerpetualPrivateKey(self, deviceIdentifier: DeviceIdentifier, certificate: str) -> None:\n           fd = open(\"./my-secure-directory/certificates/cert.ca.pem\", mode=\"w\")\n           fd.write(certificate)\n           fd.close()\n\nCreate Device class instance\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n.. code:: python\n\n   device = Device(DeviceIdentifierStoreObject(), ConnectionStoreObject(), CertificateStoreObject())\n   device.start_threadsafe()\n\nMethods\n-------\n\nstart()\n~~~~~~~\n\nThis function start the SDK or in other words starts the virtual/twin of\nthe device. The function also provisions the device with Neuko registry\nif it is yet to be registered. A provisioned device will stay in its\nperpetual state.\n\n**Important** Only called this function after you have registered (by\nuseEffect method) the handler to be invoked when any of the telemetric\nstate has any changed request.\n\nuseEffect(context, listener, stateName: str, attributeTree: str = \u201c*\u201c)\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nUse effect attaches a listener or function handler to any state\u2019s\nattributes. The parameters details are as below:\n\n1. context - Class or any object of context. (eg. this)\n\n2. Function that will be invoked when the value of interest attribute\n   changed. The function must return true if the process success.\n   Otherwise return false.\n\n3. stateName - the name of the state.\n\n4. attributeTree - Dot notation representing state attribute. For\n   example, if you have state as below\n\n.. code:: json\n\n   {\n       \"state_name_1\": {\n           \"attr_0\": true,\n           \"attr_1\": {\n               \"deep_attr_0\": false\n           }\n       }\n   }\n\nThe *deep_attr_0* tree is **attr_1.deep_attr_0**\n\nExample\n\n.. code:: python\n\n   def callback(data: TelemetricStateChangeParameter):\n       logging.debug(f'data: {data}')\n       return True\n\n   device.useEffect(self, callback, \"digital_input\", \"pin_0\")\n   device.useEffect(self, callback, \"digital_input\", \"pin_1\")\n\n   // or use wildcard to invoke the listener for any attribute\n   device.useEffect(self, callback, \"digital_input\", \"*\");\n\nupdateTelemetricState(stateName: string, value: object)\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nCall this function when the state of actual device changed. The function\nwill synchronize with its virtual/twin on cloud.\n\nExample\n\n.. code:: python\n\n   device.updateTelemetricState(\"digital_output\", {\n       \"pin_0\": false,\n       \"pin_1\": false,\n   })\n\n\n",
            "description_content_type": "text/markdown",
            "docs_url": null,
            "download_url": "",
            "downloads": {
                "last_day": -1,
                "last_month": -1,
                "last_week": -1
            },
            "home_page": "",
            "keywords": "iot,device,thing,cloud,mqtt,development,neuko",
            "license": "MIT",
            "maintainer": "",
            "maintainer_email": "",
            "name": "neuko-device-sdk",
            "package_url": "https://pypi.org/project/neuko-device-sdk/",
            "platform": null,
            "project_url": "https://pypi.org/project/neuko-device-sdk/",
            "project_urls": null,
            "release_url": "https://pypi.org/project/neuko-device-sdk/1.0.4/",
            "requires_dist": [
                "aiodns",
                "aiohttp",
                "cchardet",
                "paho-mqtt",
                "pydash",
                "python-dotenv",
                "transitions"
            ],
            "requires_python": "",
            "summary": "Neuko device SDK for Python hardware",
            "version": "1.0.4",
            "yanked": false,
            "yanked_reason": null
        },
        "last_serial": 13166404,
        "urls": [
            {
                "comment_text": "",
                "digests": {
                    "md5": "d5e3ebc0e8259786166f853ecee5904c",
                    "sha256": "5691d6f7a1551e7f177115e54913784f8a516a3bebb2217dcf97578025c386cc"
                },
                "downloads": -1,
                "filename": "neuko_device_sdk-1.0.4-py3-none-any.whl",
                "has_sig": false,
                "md5_digest": "d5e3ebc0e8259786166f853ecee5904c",
                "packagetype": "bdist_wheel",
                "python_version": "py3",
                "requires_python": null,
                "size": 31891,
                "upload_time": "2022-03-14T04:20:33",
                "upload_time_iso_8601": "2022-03-14T04:20:33.356890Z",
                "url": "https://files.pythonhosted.org/packages/98/cd/2c30ab514f178498d594be0ee9f02033808b2e171626cd0da32df0b4a51b/neuko_device_sdk-1.0.4-py3-none-any.whl",
                "yanked": false,
                "yanked_reason": null
            },
            {
                "comment_text": "",
                "digests": {
                    "md5": "63130759024fd8ceb168dccedeafd4e0",
                    "sha256": "dc382ab3bd155baefdd5f74c0dd27e090539dd98e70e48a6e856500b6106f41b"
                },
                "downloads": -1,
                "filename": "neuko-device-sdk-1.0.4.tar.gz",
                "has_sig": false,
                "md5_digest": "63130759024fd8ceb168dccedeafd4e0",
                "packagetype": "sdist",
                "python_version": "source",
                "requires_python": null,
                "size": 26858,
                "upload_time": "2022-03-14T04:20:35",
                "upload_time_iso_8601": "2022-03-14T04:20:35.706668Z",
                "url": "https://files.pythonhosted.org/packages/d3/93/1dd49238b316ffa1e598d0779b513ecb49d6f20fc79210b7a817ee01705e/neuko-device-sdk-1.0.4.tar.gz",
                "yanked": false,
                "yanked_reason": null
            }
        ],
        "vulnerabilities": []
    }
}