{
    "1.0.3": {
        "info": {
            "author": "giocip",
            "author_email": "giocip7@gmail.com",
            "bugtrack_url": null,
            "classifiers": [
                "License :: OSI Approved :: MIT License",
                "Operating System :: OS Independent",
                "Programming Language :: Python :: 3.10"
            ],
            "description": "# --- SUPREME PRECISION GENERAL PURPOSE ARITHMETIC-LOGIC CLASS  ---\r\n## _DESCRIPTION AND DOC_\r\n\r\nNum is a lightweight floating point numeric class for arbitrary precision results with always supreme precision.        \r\n\r\nEasy to use like school math and WITHOUT IEEE754 ISSUES or +0 AND -0 FAILURES, it can be deployed for\r\nweb e-commerce developing, accounting apps and general math programs included financial ones.\r\n\r\n## HOW TO USE (integer numeric strings (ex. '2.0') MUST BE SUFFIXED WITH .0):                        \r\n--- CALCULATOR MODE ---           \r\n           >>> from num7 import Num, Num as calc\r\nADDITION:          >>> calc.add('-5.3', '2.1')    # Num('-3.2')\r\nSUBTRACTION:       >>> calc.sub('-5.3', '2.1')    # Num('-7.4')\r\nMULTIPLICATION:    >>> calc.mul('-5.3', '2.1')    # Num('-11.13')\r\nDIVISION:          >>> calc.div('-5.3', '2.1')    # Num('-2.52380952380952380952380952380952380952380952380952380952380952380952380952380952')\r\nM+:                >>> M = calc('0.0'); M.inc('3.0'); M.inc('3.3'); M.inc('3.7'); print(M) # 10.0\r\nM-:                >>>                  M.dec('5.0'); M.dec('3.3'); M.dec('1.5'); print(M) # 0.2\r\nMC:                >>> M.clear(); print(M) # 0.0\r\nINT   DIV AND REM: >>> calc.divmod('5.0', '3.0')  # (Num('1.0'), Num('2.0')) => tuple \r\nFLOAT DIV AND REM: >>> calc.divmod('5.2', '3.1')  # (Num('1.0'), Num('2.1')) => tuple\r\nPOWER:             >>> calc.pow('-5.3', '2.0')    # Num('28.09')\r\nSQRT:              >>> calc.sqrt('2.0')           # Num('1.41421356237309504880168872420969807856967187537694807317667973799073247846210703')\r\nROUND:             >>> calc.sqrt('2.0').round(2)  # Num('1.41')\r\nABSOLUTE VALUE     >>> calc.abs('-3.0')           # Num('3.0')\r\nSUM:               >>> cart = ['19.32','18.37','15.13']; calc.sum(*cart)          # Num('52.82')\r\nMEAN:              >>> cart = ['19.32','18.37','15.13']; calc.mean(*cart).round() # Num('17.61')\r\nMIN:               >>> cart = ['19.32','18.37','15.13']; calc.min(cart)           # Num('15.13')\r\nMAX:               >>> cart = ['19.32','18.37','15.13']; calc.max(cart)           # Num('19.32')\r\nEXP:               >>> calc.mul('-5.3e1024', '2.1e1024').num2exp()                # '-1113E2046'\r\nREPL:              >>> a = calc('0.1'); b = calc('0.2'); print(calc.add(a, b))    # 0.3\r\n\r\nCODING:\r\n>>> from num7 import Num, Num as calc\r\n\r\n(=) assignment:\r\n>>> a = Num('3.0'); b = Num('5.0'); c = Num('0.0'); #\r\n>>> print('a =', a, 'b =', b, 'c =', c) # a = 3.0 b = 5.0 c = 0.0\r\n\r\n(+) adding:\r\n>>> R = a+b+c; print(R) # 8.0\r\n>>> a = Num('0.1'); b = Num('0.2'); c = Num('0.0'); print(a+b+c) # 0.3\r\n\r\n(-) subtracting:\r\n>>> a = Num('0.1'); b = Num('0.2'); c = Num('0.3');\r\n>>> print(a+b-c) # 0.0\r\n>>> R = Num('-3.99') - Num('-5.20') - Num('+3.01'); print(R) # -1.8\r\n\r\n(*) multiplying:\r\n>>> Num('-3.99') * Num('-5.20') * Num('+3.01') # -3.99 * (-5.20) * (+3.01 ) = Num('62.45148')    \r\n\r\n(/) dividing (80 decimal digits default gets only for division operation):\r\n>>> Num('3.0') / Num('5.7') # 3 : 5.7 = Num('0.52631578947368421052631578947368421052631578947368421052631578947368421052631578') \r\n\r\nDivision precision may be specified as parameter after numeric string as:\r\n                                                                128 decs\r\n>>> Num('3.0', 128) / Num('5.7', 128) # 3 : 5.7 = Num('0.52631578947368421052631578947368421052631578947368421052631578947368421052631578947368421052631578947368421052631578947368421052')\r\n\r\n(// % operators, divmod python3 built-in function) int division and remainder :\r\n>>> a = Num('5.0'); b = Num('2.0') #\r\n>>> Q = a // b; R = a % b; print('Quotient =', Q, 'Remainder =', R) # Quotient = 2.0 Remainder = 1.0\r\n>>> a = Num('15.0'); b = Num('4.0') #\r\n>>> Q, R = divmod(a, b); print('Quotient =', Q, 'Remainder =', R)   # Quotient = 3.0 Remainder = 3.0\r\n\r\n(divmod python3 built-in function) floating division and remainder:\r\n>>> a = Num('10.123456789'); b = Num('2.0') #\r\n>>> Q, R = divmod(a, b); print('Quotient =', Q, 'Remainder =', R)   # Quotient = 5.0 Remainder = 0.123456789\r\n\r\n(sqrt) square root function:\r\n>>> a = Num('123_456_789.1234567890123456789'); root = a.sqrt() # Num('11111.11106611111096998611053449930232404576951925017079015206589094347963821409843324')\r\n>>> print('result digits number tuple =>', root.len()) # result digits number tuple => (5, 80)\r\n\r\n(**) power operator and pow python3 built-in function:\r\n>>> a = Num('2.22123') ** 64; print(a) # 15204983311631674774944.6514720988866075755417446332131101580789367\r\n                                         9105748958794491681177995203669698667160837739445605536688871012507\r\n                                         1945418498486819681408058765704850273804729367340948014205522859407\r\n                                         6533821958836232769517779825179391210405799994330832050119578417313\r\n                                         5380826413054938730768027747418766018606636039075568645106645889100\r\n                                         039914241\r\n>>> print(a.len()) # (23, 320) digits len tuple\r\n>>> print(Num(Num.pi))  # 3.141592654\r\n>>> pow(Num(Num.pi), 8) # Num('9488.531025982131642534428505085353941520356351078169077371202330414440366336')\r\n\r\n\r\nlogic (in, not in, is, is not, <, <=, >, >=, !=, ==) and relational operators (and, or, not).\r\n\r\n(in):\r\n>>> L = [Num('0.1'), Num('1.0'), Num('5.5'), Num('-3.0'), Num('-2.9'), Num('-3.0001'), Num('2.2')]\r\n>>> Num('-3.0001') in L; Num('-3.00001') in L         #True False\r\n\r\n(not in):\r\n>>> Num('-3.0001') not in L; Num('-3.00001') not in L #False True\r\n\r\n(is, is not):\r\n>>> M = calc('0.0'); Num('0.0') is M # False\r\n>>> M = calc('0.0'); M.inc('0.1') is not M; M # True Num('0.1')\r\n>>> M; N = M; N.dec('0.1'); N is M; M; N # Num('0.1') True Num('0.0') Num('0.0')\r\n\r\n(< <= > >= != ==)\r\n>>> a = Num('0.0'); b = Num('0.1'); c = Num('-0.2')\r\n>>> a <  b; a <  c; b <  c #True  False False\r\n>>> a <= a; a <= c; b <= c #True  False False\r\n>>> a >  b; a >  c; b >  c #False True  True\r\n>>> a >= a; a >= c; b >= c #True  True  True\r\n>>> c == -2*b; a == c + 2*b ; a != a+b+c #True  True  True\r\n>>> a and b; a or b; not a     # Num('0.0') Num('0.1') True\r\n>>> True if a and b else False # False\r\n>>> True if a or  b else False # True\r\n\r\n(+ - unary operators)\r\n>>> Num('+2.5521') # Num('2.5521')\r\n>>> Num('-3.3321') # Num('-3.3321')\r\n>>> Num('+2.5521') + Num('-3.3321') # Num('-0.78')\r\n\r\n' advanced logic programming snippet '\r\n     LOOP EXAMPLE >>>        \r\nfrom num7 import Num, Num as calc\r\ni = Num(0)\r\nwhile i < Num('1.0'):\r\n    i.inc('0.1') #i += Num('0.1')\r\n    if i <= Num('0.5'):\r\n        continue\r\n    print(i) # 0.6, 0.7, 0.8, 0.9, 1.0\r\nwhile i:\r\n    i.dec('0.1') #i -= Num('0.1')\r\n    if i >= Num('0.5'):\r\n        continue\r\n    print(i) #0.4 0.3 0.2 0.1 0.0  \r\n\r\n     ROUNDING AND ACCOUNTING >>>\r\nfrom num7 import Num, Num as calc\r\np = Num('11.19')               #PRICE -Toslink cable for soundbar\r\npd = round(p.f_price_over(-7)) #PRICE DISCOUNTED 7%\r\nd = round(p - pd)              #DISCOUNT\r\np_noTAX = round(p.f_price_spinoff(22)) #COST ITEM WITHOUT TAX 22%\r\nTAX = round(p - p_noTAX)               #TAX 22%\r\nprint(F'price={p} PAYED={pd} discount={d} COST={p_noTAX} TAX={TAX}') #price=11.19 PAYED=10.41 discount=0.78 COST=9.17 TAX=2.02\r\n\r\n     PERFORMANCE EVALUATION AND SQUARENESS >>>\r\n#from sys import set_int_max_str_digits #PYTHON 3.11\r\nfrom num7 import Num, Num as calc\r\nfrom time import perf_counter\r\n#set_int_max_str_digits(1_000_000) #PYTHON 3.11\r\ndigits = 109\r\ntic = perf_counter() # Start Time\r\na = Num('-1.123456789'+'e-100')      #calculating division 10**100...      \r\ntoc = perf_counter() # End Time\r\nT1 = toc - tic\r\nprint(f\"a finished sec. {T1:1.6f}\")\r\n\r\ntic = perf_counter() # Start Time\r\nb = ('-1.123456789') >> Num('100.0') #calculating division 10**100... \r\ntoc = perf_counter() # End Time\r\nT2 = toc - tic\r\nprint(f\"b finished sec. {T2:1.6f}\")\r\nR = Num.f_perf_time(str(T1), str(T2))                                         # a finished sec. 0.000034  b finished sec. 0.002430 \r\nprint('PCT=>', R[0].round(), 'SCALE=>', R[1].round(), 'SQUARENESS=>', a == b) # PCT= -98.6 SCALE= -70.47 SQUARENESS=> True\r\n\r\n     SCIENTIFIC NOTATION AND HIGH PRECISION RESULTS >>>\r\nfrom num7 import Num, Num as calc\r\na = Num('1_000_000_000_000_000_000_000.0') #standard notation\r\nb = Num('1e21') #scientific notation\r\nSUM = a + b #SUM\r\nieee754 = float(a)+float(b) \r\nprint('SUM == ieee754', SUM == Num(str(ieee754)), ' SUM =>', SUM.num2exp()) #SUM == ieee754 True  SUM => 2e21\r\n\r\na = Num('1_000_000_000_000_000_000_000.0') #standard notation\r\nb = Num('1e21') #scientific notation\r\nMUL = a * b #MUL\r\nieee754 = float(a)*float(b) \r\nprint('MUL == ieee754', MUL == Num(str(ieee754)), ' MUL =>', MUL.num2exp()) #MUL == ieee754 True  MUL => 1e42\r\n\r\na = '1.23456789'\r\nb = '9.87654321'\r\nMUL = Num(a) * Num(b) #MUL\r\nieee754 = float(a)*float(b)\r\nprint('MUL == ieee754', MUL == Num(str(ieee754)), 'MUL =>', MUL, float(a)*float(b), '=> IEEE754 PRECISION FAILURE!') #MUL == ieee754 False MUL => 12.1932631112635269 12.193263111263525 => IEEE754 PRECISION FAILURE!\r\n\r\na = '1.23456789e320' #scientific notation\r\nb = '9.87654321e320'\r\nMUL = Num(a) * Num(b) #MUL\r\nieee754 = float(a)*float(b)\r\nprint('MUL == ieee754', MUL.str() == str(ieee754), 'MUL =>', MUL.num2exp(), float(a)*float(b), '=> IEEE754 inf FAILURE!') #MUL == ieee754 False MUL => 121932631112635269e624 inf => IEEE754 inf FAILURE!\r\n\r\na = '2e320' #scientific notation\r\nb = '3e-320'\r\nMUL = Num(a) * Num(b) #MUL\r\nieee754 = float(a)*float(b)\r\nprint('MUL == ieee754', MUL.str() == str(ieee754), 'MUL =>', MUL.num2exp(), ieee754, '=> IEEE754 inf FAILURE!') #MUL == ieee754 False MUL => 6.0 inf => IEEE754 inf FAILURE!\r\n\r\na = '1e200' #scientific notation\r\nb = '5e1200'\r\nT1 = Num(a, 1200) #ultra precision (over 80 digits default) floating point division must be specified!\r\nT2 = Num(b)\r\nDIV = T1 / T2 #DIV\r\nieee754 = float(a)/float(b)\r\nprint('DIV == ieee754', DIV.str() == str(ieee754), 'DIV =>', DIV.num2exp(), ieee754, '=> IEEE754 precision FAILURE!') #DIV == ieee754 False DIV => 2e-1001 0.0 => IEEE754 precision FAILURE!\r\n\r\n     FLOAT TO NUM CONVERSION LIST >>>\r\nfrom num7 import Num, Num as calc\r\nL = [1011, 0.0, 9.998412, 7.0, 0.123, -2.0123, 10, 6]\r\nLN= Num.float2num_list(L)\r\nprint(list(i.n for i in LN)) #['1011.0', '0.0', '9.998412', '7.0', '0.123', '-2.0123', '10.0', '6.0']\r\nprint(list(i for i in LN))   #[Num('1011.0'), Num('0.0'), Num('9.998412'), Num('7.0'), Num('0.123'), Num('-2.0123'), Num('10.0'), Num('6.0')]\r\n\r\n     SAVE NUMERIC LIST TO DISK FILE >>>\r\nNum.f_filewrite(L) #\r\n\r\n     READ NUMERIC LIST FROM DISK FILE (nums.txt default filename) >>>\r\nL = Num.f_fileread(); print(L) #[Num('1011.0'), Num('0.0'), Num('9.998412'), Num('7.0'), Num('0.123'), Num('-2.0123'), Num('10.0'), Num('6.0')]\r\n\r\n### FAQ \r\n\r\nQ. I usually try to add 0.1 to 0.2 in python3 with this code:\r\n       >>> print(0.1 + 0.2)\r\n   and the result is:\r\n       >>> 0.30000000000000004\r\n   How instead can it get exactly 0.3?\r\nA. Using Num class >>>\r\nfrom num7 import Num, Num as calc\r\nprint(Num('0.1') + Num('0.2'))  #calc.add('0.1', '0.2') #0.3\r\n\r\nQ. I'll get an arror when i usually type: \r\n       >>>  Num(0.1) #ValueError: Num.__init__ => float, type not valid: 0.1   \r\n   What is wrong?\r\nA. You must use quotes or string conversion with built-in str function:\r\n       >>> from num7 import Num, Num as calc\r\n       >>> Num('0.1')    #Num('0.1')\r\n       >>> Num(str(0.1)) #Num('0.1')\r\n\r\nQ. How can i convert a regular float to a Decimal?\r\nA. With Num.ieee754() method >>>\r\nfrom num7 import Num, Num as calc\r\na=0.1; b=0.2; \r\nc=a+b #0.30000000000000004 => PRECISION FAILURE!\r\nan = Num.ieee754(a); print(an)     #0.1000000000000000055511151231257827021181583404541015625\r\nbn = Num.ieee754(b); print(bn)     #0.200000000000000011102230246251565404236316680908203125\r\ncn = Num.ieee754(a+b);\r\nprint(cn, '=> PRECISION FAILURE!') #0.3000000000000000444089209850062616169452667236328125 => PRECISION FAILURE!\r\nT = calc.add(an, bn)\r\nprint(T, '=> OK.')                 #0.3000000000000000166533453693773481063544750213623046875 => OK.\r\n\r\nQ. I have two float variables in my code:\r\n        >>> a = 0.1; b = 0.2\r\n    How can i convert them in Num type?\r\nA. With Num.float2num method (or directly with str() bult-in function) >>>\r\nfrom num7 import Num, Num as calc\r\na = 0.1; b = 0.2 #\r\nan= Num.float2num(a); bn= Num.float2num(b) #an= Num(str(a)); bn= Num(str(b))   \r\nprint(an+bn, 'OK. VS', a+b, 'PRECISION FAILURE!') #0.3 OK. VS 0.30000000000000004 PRECISION FAILURE!\r\n\r\nQ. Can i do add or other math operations also with 10_000 digits after floating point?\r\nA. Yes, you can. >>>\r\nfrom num7 import Num, Num as calc\r\nprint((Num('1.123456789e-10_000') + Num('3.987654321e-10_000')).num2exp()) #511111111e-10008\r\nprint((Num('1.123456789e-10_000') - Num('3.987654321e-10_000')).num2exp()) #-2864197532e-10009\r\nprint((Num('1.123456789e-10_000') * Num('3.987654321e-10_000')).num2exp()) #4479957319112635269e-20018\r\nprint((Num('1.123456789e-10_000') / Num('3.987654321e-10_000'))) #0.28173374584742497292307298769992856660154820877213142969420392746224704666420356\r\n\r\n\r\n\r\n",
            "description_content_type": "text/markdown",
            "docs_url": null,
            "download_url": "",
            "downloads": {
                "last_day": -1,
                "last_month": -1,
                "last_week": -1
            },
            "home_page": "https://github.com/giocip/num7",
            "keywords": "",
            "license": "",
            "maintainer": "",
            "maintainer_email": "",
            "name": "num7",
            "package_url": "https://pypi.org/project/num7/",
            "platform": null,
            "project_url": "https://pypi.org/project/num7/",
            "project_urls": {
                "Homepage": "https://github.com/giocip/num7"
            },
            "release_url": "https://pypi.org/project/num7/1.0.3/",
            "requires_dist": null,
            "requires_python": "",
            "summary": "SUPREME PRECISION GENERAL PURPOSE ARITHMETIC-LOGIC CLASS",
            "version": "1.0.3",
            "yanked": false,
            "yanked_reason": null
        },
        "last_serial": 16047759,
        "urls": [
            {
                "comment_text": "",
                "digests": {
                    "md5": "eae6f665529599a97fedcbd68ec8d3c3",
                    "sha256": "a2da807d35dfcc25fb5e11f9f5533b72dfa287cc4dfb65709c4a979ab6db1939"
                },
                "downloads": -1,
                "filename": "num7-1.0.3-py3-none-any.whl",
                "has_sig": false,
                "md5_digest": "eae6f665529599a97fedcbd68ec8d3c3",
                "packagetype": "bdist_wheel",
                "python_version": "py3",
                "requires_python": null,
                "size": 18492,
                "upload_time": "2022-12-09T12:19:16",
                "upload_time_iso_8601": "2022-12-09T12:19:16.723043Z",
                "url": "https://files.pythonhosted.org/packages/71/fa/346dd8b0f2e4e9bcb103bf0a61f4e3ec77dee3bebf6f1d22e227928c8a23/num7-1.0.3-py3-none-any.whl",
                "yanked": false,
                "yanked_reason": null
            },
            {
                "comment_text": "",
                "digests": {
                    "md5": "f24bda4099cc5582271e849b29e3a3c7",
                    "sha256": "ffd05fcfd1bb6ac0e52cf5b16097929953a74cd4a9348deca5470eef4d76ef66"
                },
                "downloads": -1,
                "filename": "num7-1.0.3.tar.gz",
                "has_sig": false,
                "md5_digest": "f24bda4099cc5582271e849b29e3a3c7",
                "packagetype": "sdist",
                "python_version": "source",
                "requires_python": null,
                "size": 18608,
                "upload_time": "2022-12-09T12:19:18",
                "upload_time_iso_8601": "2022-12-09T12:19:18.837719Z",
                "url": "https://files.pythonhosted.org/packages/b4/52/dd7300e96e096e5a280206d182807f13448e2ca129ac4621ba8e79d77c05/num7-1.0.3.tar.gz",
                "yanked": false,
                "yanked_reason": null
            }
        ],
        "vulnerabilities": []
    }
}