{
    "2.0.0": {
        "info": {
            "author": "TB",
            "author_email": "tim.bleimehl@helmholtz-muenchen.de",
            "bugtrack_url": null,
            "classifiers": [],
            "description": "# Dict2graph\n\nTransfer python-dict/json data into a neo4j graph with the help of https://github.com/kaiserpreusse/graphio\n\ndict2graph also comes with some data transform capabilities.\n\n## About\n\n**Maintainer**: tim.bleimehl@dzd-ev.de\n\n**Licence**: MIT\n\n**issue tracker**: https://git.connect.dzd-ev.de/dzdtools/pythonmodules/-/issues?label_name%5B%5D=DZDdict2graph\n\n## Content\n\n[[_TOC_]]\n\n## Install\n\n**Stable**\n\nBRANCH: master\n\n`pip3 install git+https://git.connect.dzd-ev.de/dzdpythonmodules/dict2graph.git`\n\n**Dev**\n\nBRANCH: dict2graph-dev\n\n`pip3 install git+https://git.connect.dzd-ev.de/dzdpythonmodules/dict2graph.git@dev`\n\n## Usage\n\nWith dict2graph you can transfer python dicts into a neo4j graph out of the box. If you are not happy with the structure of the result, dict2graph comes with a bunch of transformation tools.\n\nThe recommended workflow is:\n\n- Load your dict (or a sample of your larger datasets) as it is, with dict2graph into a neo4j test instance\n- Inspect the result in neo4j\n- Tune the dict2graph config parameters\n- Wipe your neo4j test instance\n- Repeat the work flow with the changed config parameters until your happy with the result\n\n### Get started\n\nLets start with a simple example.\n\n#### Load dic as it is\n\n```python\nfrom dict2graph import Dict2graph\nfrom py2neo import Graph\n\ndic = {\n    \"Action\": {\n        \"id\": 1,\n        \"target\": \"El Oued\",\n        \"Entities\": [{\"id\": \"Isabelle Eberhardt\"}, {\"id\": \"Slim\u00e8ne Ehnni\"}],\n    }\n}\nd2g = Dict2graph()\nd2g.parse(dic)\nd2g.merge(Graph())\n```\n\nThis will result in following graph:\n\n![result-exmaple](doc/img/simple_example_result_1.png \"Result example 1\")\n\n#### Transform the model\n\nNow we can use some of the config variables to change the model to something that feels more inutitive as a graph model\n\nFirst we can remove the Collection Hub, which is needed by default to distinct nested lists. But as we can assure there are no nested list in our source data, we can disable them with `config_list_blocklist_collection_hubs`:\n\n```python\nfrom dict2graph import Dict2graph\nfrom py2neo import Graph\n\ndic = {\n    \"Action\": {\n        \"id\": 1,\n        \"target\": \"El Oued\",\n        \"Entities\": [{\"id\": \"Isabelle Eberhardt\"}, {\"id\": \"Slim\u00e8ne Ehnni\"}],\n    }\n}\nd2g = Dict2graph()\n# we can disable specific Collection Hubs by providing a list with it names or disable Collection hubs globaly by providing the string \"all\"\nd2g.config_list_blocklist_collection_hubs = [\"all\"]\nd2g.parse(dic)\nd2g.merge(Graph())\n```\n\nNow we directly connect our :Action to the :Entities\n\n![result-example2](doc/img/simple_example_result_2.png \"Result example 2\")\n\nAs a next step we could rename labels, relationship types and properties with the help of `config_dict_label_override`, `config_dict_reltype_override` and `config_dict_property_name_override` to something more suitable:\n\n```python\nfrom dict2graph import Dict2graph\nfrom py2neo import Graph\n\ndic = {\n    \"Action\": {\n        \"id\": 1,\n        \"target\": \"El Oued\",\n        \"Entities\": [{\"id\": \"Isabelle Eberhardt\"}, {\"id\": \"Slim\u00e8ne Ehnni\"}],\n    }\n}\nd2g = Dict2graph()\nd2g.config_list_blocklist_collection_hubs = [\"all\"]\nd2g.config_dict_label_override = {\"Action\":\"Voyage\", \"Entities\":\"Person\"}\nd2g.config_dict_reltype_override = {\"VOYAGE_HAS_PERSON\":\"TRAVELLER\"}\nd2g.config_dict_property_name_override = {\"Person\":{\"id\":\"Fullname\"}, \"Voyage\":{\"target\":\"destination\"}}\nd2g.parse(dic)\nd2g.merge(Graph())\n```\n\nThis results in a graph like:\n\n![result-example3](doc/img/simple_example_result_3.png \"Result example 3\")\n\nThere are a lot more possible ways to transform your data before pushing it to the neo4j graph. Browse the specifications to explore all capabilities...\n\n## Specifications\n\n### Methods\n\n**Dict2graph.parse(data,parent_label_name=None)**\n\n- Description: Transform dic data into multiple graphio.nodeset and graphio.relationset . You can apply `parse` multiple time on a Dict2graph instance\n- Parameters:\n\n  - data:\n    - Type: dict or string\n    - default: Non optional - no default\n    - notes: if using str it must containing valid dic. if using dict type it must not contain complex types\n  - parent_label_name\n    - Type: string\n    - default: None\n    - notes: Defines a parent label for top level dic data. e.g. `parent_label_name=None` on the dic `{\"name\":\"Isabelle Eberhardt\"}` will result in a node `(:name{name:\"Isabelle Eberhardt\"})` but with `parent_label_name=\"Person\"` the resulting node will be `(:Person{name:\"Isabelle Eberhardt\"})`\n\n- Example:\n\n```python\nfrom dict2graph import Dict2graph\nfrom py2neo import Graph\n\ndic = {\"name\": \"Isabelle Eberhardt\"}\nd2g = Dict2graph()\nd2g.parse(dic, \"Person\")\nd2g.merge(Graph())\n```\n\n**Dict2graph.create_indexes(graph)**\n\n- Description: Create indexes based on the primary properties (aka merging keys) on the dic data that is already loaded with `Dict2graph.parse()` but not yet in the database\n- Parameters:\n\n  - graph:\n    - Type: py2neo.Graph\n    - default: Non optional - no default\n    - notes: The graph object, where indexes, based on the already loaded dic, should be created\n\n- Example:\n\n```python\nfrom dict2graph import Dict2graph\nfrom py2neo import Graph\n\ndic = {\"name\": \"Isabelle Eberhardt\"}\nd2g = Dict2graph()\nd2g.parse(dic, \"Person\")\nd2g.create_indexes(Graph())\n# This will run a `CREATE INDEX ON :Person(name)`\n# Resulting in better Dict2graph.merge() perfomance on larger datasets\nd2g.merge(Graph())\n```\n\n**Dict2graph.create(graph)**\n\n- Description: Commit nodes and relationship based on the loaded dic to a neo4j Graph\n- Parameters:\n\n  - graph:\n    - Type: py2neo.Graph\n    - default: Non optional - no default\n    - notes: The target graph\n\n- Example:\n\n```python\nfrom dict2graph import Dict2graph\nfrom py2neo import Graph\n\ndic = {\"Person\":{\"name\": \"Isabelle Eberhardt\"})\nd2g = Dict2graph()\nd2g.parse(dic)\nd2g.create(Graph())\n```\n\n**Dict2graph.merge(graph)**\n\n- Description: merge nodes and relationship based on the loaded dic into a neo4j Graph\n- Parameters:\n\n  - graph:\n    - Type: py2neo.Graph\n    - default: Non optional - no default\n    - notes: The target graph\n\n- Example:\n\n```python\nfrom dict2graph import Dict2graph\nfrom py2neo import Graph\n\ndic = {\"Person\":{\"name\": \"Isabelle Eberhardt\"})\nd2g = Dict2graph()\nd2g.parse(dic)\nd2g.merge(Graph())\n```\n\n**Dict2graph.create_merge_depending(graph, default=\"create\")**\n\n- Description: Define which nodes and relations should be merged and which ones should be created. Use the config param `config_dict_create_merge_depending_scheme` to define a scheme\n- Parameters:\n\n  - graph:\n    - Type: py2neo.Graph\n    - default: Non optional - no default\n    - notes: The target graph\n  - default\n    - Type: str(\"create\"|\"merge\")\n    - default: \"create\"\n    - notes: None\n\n- Example:\n\n```python\nfrom dict2graph import Dict2graph\nfrom py2neo import Graph\n\nd2g = Dict2graph()\nd2g.config_dict_create_merge_depending_scheme = {\n    \"merge\": [\"Person\", \"ACTION_HAS_PERSON\"],\n    \"create\": [\"Action\"],\n}\n\n\njson1 = {\n    \"Action\": {\n        \"name\": \"Travel\",\n        \"timestamp\": \"1897-04-31\",\n        \"Person\": {\"name\": \"Isabelle Eberhardt\"},\n    },\n}\n\njson2 = {\n    \"Action\": {\n        \"name\": \"Sleep\",\n        \"timestamp\": \"1897-05-04\",\n        \"Person\": {\"name\": \"Isabelle Eberhardt\"},\n    },\n}\n\njson2repeat = {\n    \"Action\": {\n        \"name\": \"Sleep\",\n        \"timestamp\": \"1897-05-04\",\n        \"Person\": {\"name\": \"Isabelle Eberhardt\"},\n    },\n}\nd2g.parse(json1)\nd2g.parse(json2)\nd2g.parse(json2repeat)\nd2g.create_merge_depending(Graph())\n# This will create multiple :Action nodes but only one :Person node\n```\n\n**Dict2graph.clear()**\n\n- Description: delete nodes and relationships. this can can be helpful when loading multiple batches of dic.\n- Parameters: None\n\n- Example:\n\n```python\nfrom dict2graph import Dict2graph\nfrom py2neo import Graph\n\ndic = {\"Person\":{\"name\": \"Isabelle Eberhardt\"})\nd2g = Dict2graph()\nd2g.parse(dic)\nd2g.merge(Graph())\nd2g.clear()\ndic = {\"Person\":{\"name\": \"Sophie Blanchard\"})\nd2g.parse(dic)\nd2g.merge(Graph())\n```\n\n### Config Parameters\n\ndict2graph comes with a lot of parameters.\nAll parameters are defined as class variables of DZDdict2graph.Dict2graph\nEvery parameter variable name starts with `config_` followed by the type it accepts.\ne.g. `config_bool_capitalize_labels` only accepts a boolean value.\nHere is a list of all parameters:\n\n#### **config_bool_capitalize_labels**\n\n- Type: Bool\n- Default: `False`\n- Description: Will run [capitalize()](https://www.w3schools.com/python/ref_string_capitalize.asp) on every node label. `my_json_attr` will become 'My_json_attr'\n- Example Value: `True` or `False`\n- Example:\n\n```python\ndic = {\"perSon\": {\n        \"name\":\"Alexandrine Tinn\u00e9\"}}\nd2g = Dict2graph()\nd2g.config_bool_capitalize_labels = True\nd2g.parse(dic)\nd2g.create(Graph())\n# results in a node `:Person{name:\"Alexandrine Tinn\u00e9\"}`\n```\n\n#### **config_dict_property_casting**\n\n- Type: dict\n- Default: `{}`\n- Description: Will cast values to a certain type based for a certain and property\n- Example Value: `{\"MyNodeName\":{\"MyPropertyName\":str}}`\n- Example:\n\n```python\ndic = {\"Person\": {\n        \"name\":\"Eva Saxl\",\n        \"age\":\"34\"}}\nd2g = Dict2graph()\nd2g.config_dict_property_casting =  {\"Person\":{\"age\":int}}\nd2g.parse(dic)\nd2g.create(Graph())\n```\nResults in a node `(:Person{name:\"Eva Saxl\",age:34})`\n\n\n#### **config_dict_label_override**\n\n- Type: dict\n- Default: `{}`\n- Description: By default, dict2graph generates label names based on parent dic attributes. These can be overriden with `config_dict_label_override`. Optional you can attach extra node properties to the renamed nodes.\n- Example Value: `{\"JsonAttrName\":\"myOwnLabelname\", \"AnotherJsonAttr\":\"myOwnLabelname\", \"AndAnotherJsonAttr\":\"MyOtherLabelName\"}` or with extra properties `{\"JsonAttrName1\":{\"MyNewLabel\":{\"type\":1}},\"JsonAttrName2\":{\"MyNewLabel\":{\"type\":2}}}`\n- Example:\n\n```python\ndic = {\"Hacker\": {\n            \"name\": \"Jude Milhon\"},\n        \"Astronomer\":{\n            \"name\":\"Giordano Bruno\"\n        }}\nd2g = Dict2graph()\nd2g.config_dict_label_override = {\"Hacker\":{\"Person\":{\"profession\":\"Hacker\"}},{\"Astronomer\":{\"Person\":{\"profession\":\"Astronomer\"}}}\nd2g.parse(dic)\nd2g.create(Graph())\n# results in two nodes (:Person{name:\"Jude Milhon\",profession:\"Hacker\"}) and (:Person{name:\"Giordano Bruno\",profession:\"Astronomer\"})\n```\n\n#### **config_dict_reltype_override**\n\n- Type: dict\n- Default: `{}`\n- Description: By default, dict2graph generates relationship names based on parent primary label names with a `_HAS_` in between. These can be overriden with `config_dict_reltype_override`. Optional you can attach extra node properties to the renamed nodes.\n- Example Value: `{\"THING_HAS_OTHERTHING\":\"THING_CONNECTION\"}`\n- Example:\n\n```python\ndic = {\n    \"Person\": {\n        \"name\": \"Rudolf Manga Bell\",\n        \"Friendship\": {\"Person\": {\"name\": \"Ekandjoum Joseph\"}},\n    },\n}\nd2g = Dict2graph()\nd2g.config_dict_reltype_override = {\"PERSON_HAS_FRIENDSHIP\":\"FRIEND\",\"FRIENDSHIP_PERSON_HAS\":\"FRIEND\"}\nd2g.parse(dic)\nd2g.create(Graph())\n# results in the two `:Person` nodes having following edges`(:Person{name:\"Rudolf Manga Bell\"})-FRIEND->(:Friendship)-FRIEND->(:Person{name:\"Ekandjoum Joseph\"})`\n```\n\n#### **config_dict_property_name_override**\n\n- Type: dict\n- Default: `{}`\n- Description: Rename specific node properties for a specific label, which names are resulted from the dic attribute name\n- Example Value: `{\"LabelName\": {\"my_json_attr\":\"my_graph_prop\"}}`\n- Example:\n\n```python\ndic = {\"Person\": {\n            \"personname\": \"Sophie Germain\",\n            \"personjob\":\"Mathematician\"}\n        }\nd2g = Dict2graph()\nd2g.config_dict_property_name_override = {\"Person\": {\"personname\":\"name\",\"personjob\":\"profesion\"}}\nd2g.parse(dic)\nd2g.create(Graph())\n# results in a node `:Person{name:\"Sophie Germain\",profesion:\"Mathematician\"}`\n```\n\n\n#### **config_list_default_primarykeys**\n\n- Type: list of strings\n- Default: `[\"id\", \"_id\"]`\n- Description: Define which properties can be taken as merge keys by default, undepended of the nodes label\n- Example Value: `[\"id\", \"_id\", \"my_hash_id\"]`\n- Example:\n\n```python\ndic = {\"Person\": {\n            \"entity_id\": 1\n            \"lastName\": \"Sophie Germain\",\n            \"personjob\":\"Mathematician\"},\n        \"Thing\": {\"entity_id\":2,\"name\":\"Sword\"}\n        }\nd2g = Dict2graph()\nd2g.config_list_default_primarykeys = [\"entity_id\"]\nd2g.parse(dic)\nd2g.merge(Graph())\n# results in merging all nodes by its property `entity_id` without the need to define it for every label like you would need with `config_dict_primarykey_attr_by_label`\n```\n\n#### **config_dict_primarykey_attr_by_label**\n\n- Type: dict\n- Default: `{}`\n- Description: Define which properties can be taken into account as merge keys for a certain label\n- Example Value: `{\"MyLabel\":[\"MyPrimaryKeyProperty\"], \"MyOtherLabel\":[\"MyOtherPKProp\",\"MySecondOtherPK\"]}`\n- Example:\n\n```python\ndic = {\"Person\": {\n            \"person_id\": 1\n            \"lastName\": \"Sophie Germain\",\n            \"personjob\":\"Mathematician\"},\n        \"Thing\": {\"thing_id\":2,\"name\":\"Sword\"}\n        }\nd2g = Dict2graph()\nd2g.config_list_default_primarykeys = {\"Person\":[\"person_id\"],\"Thing\":[\"thing_id\"]}\nd2g.parse(dic)\nd2g.merge(Graph())\n# results in merging `:Person` nodes by `person_id` and `:Thing` nodes by `thing_id`\n```\n\n\n\n\n#### **config_dict_primarykey_generated_hashed_attrs_by_label**\n\n- Type: dict\n- Default: `{}`\n- Description: dict2graph can generate a hash property based on other properties. Allowed values are\n    * `AllAttributes` - Generate an ID based on nodes properties\n    * `InnerContent` - Generate an ID based on the Nodes properties and its children\n    * `OuterContent` - Generate an ID based on the Nodes properties and its parent node\n    * `AllContent` - Generate an ID based on the parent and children\n    * `[...]` - A list of node properties which should be taken into account to generate an ID\n    * `None` - Generate a random uuid \n\n- Example Value: `{\"Person\": \"AllAttributes\",\"Address\": [\"streetAddress\", \"postalCode\"],\"Children\":\"AllInnerContent\"}`\n- Example:\n\n```python\ndic = {\n    \"House\": {\n        \"Floor\": [\n            {\n                \"Level\": 2,\n                \"ground_floor\": False,\n                \"rooms\": [\n                    {\n                        \"name\": \"Sleeping Room\",\n                        \"habitant\": \"kids\",\n                        \"desc\": \"A room for kids\",\n                    }\n                ],\n            },\n            {\n                \"Level\": 1,\n                \"ground_floor\": True,\n                \"rooms\": [\n                    {\n                        \"name\": \"Sleeping Room\",\n                        \"habitant\": \"parents\",\n                        \"desc\": \"A room for parents\",\n                    }\n                ],\n            },\n        ]\n    }\n}\nd2g = Dict2graph()\nd2g.config_dict_primarykey_generated_hashed_attrs_by_label = {\"House\":\"InnerContent\",\"Floor\":\"AllAttributes\",\"rooms\":[\"name\",\"habitant\"]}\nd2g.parse(dic)\nd2g.merge(Graph())\n# results in a Node (:House{_id:\"a5f8990bd535822ac12a85487f638af5\"}), which hash is based on all children nodes\n# two nodes (:Floor{_id:\"a8351c9ab6f8073d57c0a4525c9e8579\",...}) and (:Floor{_id:\"83871439e32cddd65544e22573c70080\",...}) which \"_id\" propert hash is based on its attributes (Level and ground_floor in this case)\n# two nodes (:rooms{_id:\"ed92509396972cb79b92db57c4d8f314\",...}) and (:rooms{_id:\"ee62bb79583742c6b1f2ce0f3083d61b\",...}) which \"_id\" property is hashed from the property name and habitant\n```\n\n#### **config_str_primarykey_generated_attr_name**\n\n- Type: dict\n- Default: `\"_id\"`\n- Description: Define the property name for the generated id hash, produced by **config_dict_primarykey_generated_hashed_attrs_by_label**\n- Example Value: `\"hash_id\"` or `\"_my_id\"`\n- Example:\n\n```python\ndic = {\"Person\": {\n            \"Name\": \"Hypatia\"},\n        }\nd2g = Dict2graph()\nd2g.config_dict_primarykey_generated_hashed_attrs_by_label = {\"Person\":\"AllAttributes\"}\nd2g.config_str_primarykey_generated_attr_name = \"_hash_id\"\nd2g.parse(dic)\nd2g.merge(Graph())\n# results in a node (:Person{_hash_id:\"some-md5-hash-string\", Name:\"Hypatia\"})\n```\n\n\n\n#### **config_list_blocklist_collection_hubs** / **config_list_allowlist_collection_hubs**\n\n- Type: list\n- Default: `[]`\n- Description: Suppress the creation of certain collection hubs by label name. When using `config_list_blocklist_collection_hubs` only collection hubs with label names that are NOT in this list will be created. \n\nWhen using `config_list_allowlist_collection_hubs`, only collection hubs with a label name in this list will be created.\n\n**Hint** You can use `config_list_allowlist_collection_hubs` also to disable collection creation. Just insert a non occurring label name in the list (e.g. `[\"#IAM_NEVER_A_LABEL_NAME!\"]`)\n\n- Example Value: `[\"CollectionHub,OneMoreCollectionLabel\"]`\n- Example:\n\n```python\ndic = {\"Philosophers\":{\"Person\": [{\"name\": \"Hypatia\"}, {\"name\": \"Epikur\"}, {\"name\": \"Sokrates\"}]}}\nd2g = Dict2graph()\nd2g.config_list_blocklist_collection_hubs = [\"PhilosophersCollection\"]\nd2g.parse(dic)\nd2g.create(Graph())\n\n``` \n\nresults in three Nodes `(:Person{Name:\"Hypatia\"})`, `(:Person{Name:\"Epikur\"})`, `(:Person{Name:\"Sokrates\"})` directly connected to the parent node `(:Philosophers)` (instead of a intermediate collection hub node)\n\n\n#### **config_list_blocklist_reltypes** / **config_list_allowlist_reltypes**\n\n- Type: list\n- Default: `[]`\n- Description: Suppress the creation of certain relations by relation type name. When using `config_list_blocklist_reltypes` only relations with a type name that is NOT in this list will be created. \n\nWhen using `config_list_allowlist_reltypes`, only relations with a type name in this list will be created.\n\n- Example Value: `[\"MYNODE_HAS_OTHERNODE\"]`\n- Example:\n\n```python\ndic = {\n    \"Person\": {\n        \"name\": \"Rudolf Manga Bell\",\n        \"Friendship\": {\"Person\": {\"name\": \"Ekandjoum Joseph\"}},\n    }\nd2g = Dict2graph()\nd2g.config_list_blocklist_reltypes = [\"PERSON_HAS_FRIENDSHIP\"]\nd2g.parse(dic)\nd2g.create(Graph())\n```\nresults in two `:Person` nodes having no edge connecting them\n\n\n#### **config_list_blocklist_nodes** / **config_list_allowlist_nodes**\n\n\u26a0\ufe0f Draft: This option is work in progress and its behavior will change in a future release. Keep in mind when using this option\n\n- Type: list\n- Default: `[]`\n- Description: Suppress the creation of nodes (and their attached relations). Any relations to and from this node will be lost too.\n\nWhen using `config_list_blocklist_nodes` only nodes that are not in this list will be created\n\nWhen using `config_list_allowlist_nodes` only nodes that are in this list will be created\n\n- Example Value: `[\"MyNode\"]`\n- Example:\n\n```python\ndic = {\n    \"Person\": {\n        \"name\": \"Rudolf Manga Bell\",\n        \"Friendship\": {\"Person\": {\"name\": \"Ekandjoum Joseph\"}},\n    }}\nd2g = Dict2graph()\nd2g.config_list_blocklist_nodes = [\"Friendship\"]\nd2g.parse(dic)\nd2g.create(Graph())\n```\nresults only two Nodes `(:Person{name:\"Rudolf Manga Bell\"})` and `(:Person{name:\"Ekandjoum Joseph\"})`\n\n- Releated issues\n    - https://git.connect.dzd-ev.de/dzdtools/pythonmodules/-/issues/10\n\n#### **config_dict_blocklist_props** / **config_dict_allowlist_props**\n\n- Type: dict\n- Default: `{}`\n- Description: Suppress the addition of certain properties to a node. This is configured on a per node base.\n\nWhen using `config_dict_allowlist_props`, for a certain label, only these props will be attached to the node label.\n\nWhen using `config_dict_blocklist_props`, for a certain label, only other props will be attached to the node label.\n\n- Example Value: `{\"MyNodeLabel\":[\"myUnwantedProp1\",\"UnwantedProp2\"]}`\n- Example:\n\n```python\ndic = {\n    \"Person\": {\n        \"name\": \"Rudolf Manga Bell\",\n        \"internal_id\":\"Xsdsw2\",\n    }\nd2g = Dict2graph()\nd2g.config_dict_allowlist_props = {\"Person\":[\"name\"]}\nd2g.parse(dic)\nd2g.create(Graph())\n```\nresults in a node `(:Person{name:\"Rudolf Manga Bell\"}}`. The `internal_id` property is ditched\n\n\n\n#### **config_dict_in_between_node**\n\n\n\n\u26a0\ufe0f WIP - Can crash due to bug - https://git.connect.dzd-ev.de/dzdtools/pythonmodules/-/issues/11\n\n\n\n- Type: dict\n- Default: `{}`\n- Description: Creates an extra node between to nodes. **hint** It maybe makes sense to use **config_dict_primarykey_generated_hashed_attrs_by_label** with the `AllContent` option to make the extra node unique\n- Example Value: ` {\"MyNodeLabel\": {\"MYNODELABEL_HAS_OTHERNODELABEL\": \"ExtraNodeLabel\"}}`\n- Example:\n\n```python\n\ndic = {\n    \"Persons\": [\n        {\"Philosopher\": {\"name\": \"Hypatia\"}},\n        {\"Philosopher\": {\"name\": \"Epikur\"}},\n    ]\n}\nd2g = Dict2graph()\nd2g.config_list_allowlist_collection_hubs = [\"None\"]\nd2g.config_dict_in_between_node = {\n    \"Persons\": {\"PERSONS_HAS_PHILOSOPHER\": \"JobPhilosopher\"}\n}\nd2g.parse(dic)\nd2g.merge(Graph())\n```\n\nResults in extra nodes `:JobPhilosopher` between `:Persons` and `:Philosopher` and two new relations per node\n\n\n#### **config_dict_flip_nodes**\n\n\n\n\u26a0\ufe0f WIP - Untested\n\n\n\n- Type: dict\n- Default: `{}`\n- Description: Flips the sequence (as seen in the source dic tree) of two nodes. use this only on simple triples. Can cause weird effects on more complex dic trees\n- Example Value: `{\"LeadingNodeLabel\":\"NextNodeLabel\"}`\n- Example:\n\n```python\ndic = {\n    \"Article\": {\n        \"Title\": \"Super Duper Article\",\n        \"magazin\": {\"name\": \"Ant simulations\", \"issue\": {\"Year\": 2012, \"no\": 2,}},\n    }\n}\nd2g = Dict2graph()\nd2g.config_dict_flip_nodes = {\"magazin\": \"issue\"}\nd2g.parse(dic)\nd2g.merge(Graph())\n```\nResults in `(:Article)->(:issue)->(:magazin)` instead of `(:Article)->(:magazin)->(:issue)`\n\n#### **config_dict_hubbing**\n\n\n\n\u26a0\ufe0f WIP - This feature is still beta\n\n\n\n- Type: dict\n- Default: `{}`\n- Description: Hubbing is the process of connecting multiple chained nodes with a new hub node. Depeding on how the unique id of the hub is generated the merging behavior can differ. More on this [here](https://wiki.connect.dzd-ev.de/en/public/articles/graph-hubbing) \nThe parameter per label (aka start/root node) must be a dict of following keys. (optional multiple dicts, with following keys, can be packed into a list, if one root node has more than one hub attached)\n`hub_member_labels` - list - A list of nodes that should be hubbed\n`hub_id_from` - str - optional - default: lead - `lead` or `edge` . Decide on how to build the hubs unique ID\n- Example Value: `\"StartNodeLabel\": {\"hub_member_labels\": [\"FillNodeLabel\", \"EndNodeLabel\"], \"hub_id_from\": \"lead\"}` or `\"StartNodeLabel\": [{\"hub_member_labels\": [\"FillNodeLabel\", \"EndNodeLabel\"], \"hub_id_from\": \"lead\"},{\"hub_member_labels\": [\"FillNodeLabel2\", \"EndNodeLabel2\"], \"hub_id_from\": \"edge\"}]`\n- Example:\n\nlets imagine following data. We have articles written by authors. These Authors have written with an affiliation to an organisation\n\n```python\ndic = {\n    \"Article\": {\n        \"title\": \"Science Behind The Cyberpunk-Genres Awesomeness\",\n        \"Authors\": [\n            {\n                \"firstName\": \"Mike\",\n                \"lastName\": \"Pondsmith\",\n                \"affiliation\": [{\"name\": \"University 1\"}],\n            },\n        ],\n    }\n}\njson2 = {\n    \"Article\": {\n        \"title\": \"Transhumanism in Computergames\",\n        \"Authors\": [\n            {\n                \"firstName\": \"Mike\",\n                \"lastName\": \"Pondsmith\",\n                \"affiliation\": [{\"name\": \"University 1\"}, {\"name\": \"University 2\"}],\n            },\n        ],\n    }\n}\nd2g.config_list_allowlist_collection_hubs = [\"NONE\"]\nd2g.parse(dic)\nd2g.parse(json2)\nd2g.merge(Graph())\n```\n\nThis results in following graph:\n\n![result-exmaple](doc/img/example_before_hubbing.png \"example_hubbing_before\")\n\nThe issue here is, we can not determine to which organisations Mike Pondsmith was affiliated while writing one of the articles. Only that he was affiliaten to these organisations at any point.\n\nLets try this data again, but this time we do hubbing on the Article-Authors-affiliation triplets.\n\n```python\ndic = {\n    \"Article\": {\n        \"title\": \"Science Behind The Cyberpunks-Genre Awesomeness\",\n        \"Authors\": [\n            {\n                \"firstName\": \"Mike\",\n                \"lastName\": \"Pondsmith\",\n                \"affiliation\": [{\"name\": \"University 1\"}],\n            },\n        ],\n    }\n}\njson2 = {\n    \"Article\": {\n        \"title\": \"Transhumanism in Computergames\",\n        \"Authors\": [\n            {\n                \"firstName\": \"Mike\",\n                \"lastName\": \"Pondsmith\",\n                \"affiliation\": [{\"name\": \"University 1\"}, {\"name\": \"University 2\"}],\n            },\n        ],\n    }\n}\nd2g.config_list_allowlist_collection_hubs = [\"NONE\"]\n# hubbing config:\nd2g.config_dict_hubbing = {\n    \"Article\": {\n        \"hub_member_labels\": [\"Authors\", \"affiliation\"],\n        \"hub_label\": \"Contribution\",\n        \"hub_id_from\": \"edge\",\n    }\n}\nd2g.parse(dic)\nd2g.parse(json2)\nd2g.merge(Graph())\n```\n\nThis results in folowing graph:\n\n![result-exmaple](doc/img/example_after_hubbing.png \"example_hubbing_after\")\n\nWe can now see with which affiliation Mike created which article.\n\nWe defined `Article` as the root node for our hub and `Authors` and `affiliation` as the member nodes of the hub. the name of the hub label should be `Contribution`.\nThe id of the hub should be created based on the edge nodes (The nodes at the start and end of the chain); `Articles` and `affiliation` in this example, this enables to connect multiple `:Authors` with the same `:affiliation` to one hub\n\n> The alternative to `\"hub_id_from\": \"edge\"` would be `\"hub_id_from\": \"lead\"`. The hub id would be created from nodes with children (leading nodes); `Articles` and `Author`. This would make sense if few Authors would have many shared affiliatons. We assume its the other way around, thats why we use the `edge` option\n\nHubbing is great for larger datasets, when done correct, we can pack together many members to a few hubs and save a lot of relations. For smaller datasets building a triangles can be more appropriate and keep the resulting graph simpler.  \n\n> Triangle building is not yet implemented (see #12 for updates)\n\n#### **config_str_collection_hub_label**\n\n- Type: dict\n- Default: `\"{LIST_MEMBER_LABEL}Collection\"`\n- Description: Json lists will be translated to multiple nodes connected by a so called **Collection Hub** node. With `config_str_collection_hub_label` you can define the node label for the Collection Hub node. The string `{LIST_MEMBER_LABEL}` will be replaced by the list members node label (which is a the dic attribute containing the list).\n- Example Value: `\"{LIST_MEMBER_LABEL}_List\"` or `\"Hub4{LIST_MEMBER_LABEL}\"`\n- Example:\n\n```python\ndic = {\"Person\": [{\"name\": \"Hypatia\"}, {\"name\": \"Epikur\"}, {\"name\": \"Sokrates\"}]}\nd2g = Dict2graph()\nd2g.config_str_collection_hub_label = \"{LIST_MEMBER_LABEL}_Collection}\"\nd2g.parse(dic)\nd2g.create(Graph())\n# results in three Nodes (:Person{Name:\"Hypatia\"}), (:Person{Name:\"Epikur\"}), (:Person{Name:\"Sokrates\"}) connected to a node (:Person_Collection)\n```\n\n#### **config_list_collection_hub_extra_labels**\n\n- Type: list of strings\n- Default: `[\"CollectionHub\"]`\n- Description: Adds further labels to Collection Hubs. See **config_str_collection_hub_label** for more explanation\n- Example Value: `[\"CollectionHub,OneMoreCollectionLabel\"]`\n- Example:\n\n```python\ndic = {\"Person\": [{\"name\": \"Hypatia\"}, {\"name\": \"Epikur\"}, {\"name\": \"Sokrates\"}]}\nd2g = Dict2graph()\nd2g.config_str_collection_hub_label = \"{LIST_MEMBER_LABEL}_Collection}\"\nd2g.config_list_collection_hub_extra_labels = [\"ColHub\"]\nd2g.parse(dic)\nd2g.create(Graph())\n# results in three Nodes (:Person{Name:\"Hypatia\"}), (:Person{Name:\"Epikur\"}), (:Person{Name:\"Sokrates\"}) connected to a node (:Person_Collection:ColHub) which again will be connected to a Node (:Philosophers)\n```\n\n\n\n#### **config_bool_collection_hub_attach_list_members_label**\n\n- Type: bool\n- Default: `False`\n- Description: If set to True, Collection Hubs will get an additional label. This label will be the same as the list members primary label\n- Example Value: `False` or `True`\n- Example:\n\n```python\ndic = {\"Philosophers\": [{\"Person\":{\"name\": \"Hypatia\"}}, {\"Person\":{\"name\": \"Epikur\"}}, {\"Person\":{\"name\": \"Sokrates\"}}]}}\nd2g = Dict2graph()\nd2g.config_bool_collection_hub_attach_list_members_label = True\nd2g.parse(dic)\nd2g.create(Graph())\n# results in three Nodes (:Person{Name:\"Hypatia\"}), (:Person{Name:\"Epikur\"}), (:Person{Name:\"Sokrates\"}) connected to a node (:PersonCollection:CollectionHub:Person)\n```\n\n- OpenIssues:\n  - https://git.connect.dzd-ev.de/dzdtools/pythonmodules/-/issues/5\n\n#### **config_bool_collection_hub_only_when_len_min_2**\n\n- Type: bool\n- Default: `False`\n- Description: Skip Collection Hub / Reduce to normal 1 to 1 relation if list only contains one list member\n- Example Value: `False` or `True`\n- Example:\n\n```python\ndic = {\"Philosophers\": [{\"Person\":{\"name\": \"Hypatia\"}}]}}\nd2g = Dict2graph()\nd2g.config_bool_collection_hub_only_when_len_min_2 = True\nd2g.parse(dic)\nd2g.create(Graph())\n# results in two Nodes (:Person{Name:\"Hypatia\"}) and (:Philosophers) with a direct relation, instead of a CollectionHub\n```\n\n#### **config_list_deconstruction_limit_nodes**\n\n- Type: dict\n- Default: `{}`\n- Description: If set to a valid node name, the certain nodes will have no children, instead all children will be merged into the nodes attributes. Also knows as \"flatten\" a nested entity (https://rosettacode.org/wiki/Flatten_a_list)\nNested lists will be represented by the prop name with and index number attached\n- Example Value: `[myNodeLabel]`\n- Example:\n\n```python\ndic = {\"Person\": {\"firstname\": \"Dan\", \"lastname\": \"Cooper\", \"middlenames\": [\"D.\", \"B.\"]}}\nd2g = Dict2graph()\nd2g.config_list_deconstruction_limit_nodes = [\"middlenames\"]\nd2g.parse(dic)\nd2g.merge(Graph())\n```\nResults in one node `(:Person{\"middlenames_1\":\"B.\",\"middlenames_0\":\"D.\",\"firstname\":\"Dan\",\"lastname\":\"Cooper\"})` \ninstead of three nodes. \nThis would be the result **without** `config_list_deconstruction_limit_nodes*` : `(:Person{\"firstname\":\"Dan\",\"lastname\":\"Cooper\"}) -> (:middlename{\"middlenames\":\"B.\"}) & (:middlename{\"middlenames\":\"D.\"})` \n\n#### **config_dict_concat_list_attr**\n\n- Type: dict\n- Default: `{}`\n- Description: If set to True, Collection Hubs will get an additional label. This label will be the same as the list members primary label\n- Example Value: `{\"MyLabel\":[{\"MyListProperty\":\",\"}]}`\n- Example:\n\n```python\ndic = {\"Person\": {\"firstname\": \"Dan\", \"lastname\": \"Cooper\", \"middlenames\": [\"D.\", \"B.\"]}}\nd2g = Dict2graph()\nd2g.config_dict_concat_list_attr = {\"Person\": {\"middlenames\": \" \"}}\nd2g.parse(dic)\nd2g.merge(Graph())\n# results in one Node (:Person{middlenames:\"D. B.\",...}) instead of related extra nodes for every middlenames entry\n```\n\n#### **config_func_node_post_modifier** and **config_func_node_pre_modifier**\n\n\u26a0\ufe0f Warning: These are a very powerful configuration options. Use as a last resort if you cant find any other solution and if you know what you are doing. Test thoroughly against your data if using!\n\n- Type: function\n- Default: `None`\n- Description: provide a function which can manipulate the resulting nodes. `config_func_node_pre_modifier` will be run before the node will be populated with data and `config_func_node_post_modifier` will be run when the node is processed and populated with data\n- Example Value: `lambda node : node.add_label(\"FunnyLabel\")`\n- Example:\n\n```python\ndic = {\"House\": {\"Person\": {\"name\": \"Hypatia\"}}}\nd2g = Dict2graph()\ndef custom_pre_func(node):\n    if node is not None and node.__primarylabel__ == \"Person\":\n        node.add_label(\"ExtraPersonLabel\")\n    return node\ndef custom_post_func(node):\n    if (\n        node is not None\n        and node.__primarylabel__ == \"Person\"\n        and node[\"name\"] == \"Hypatia\"\n    ):\n        node[\"ExtraProp\"] = \"ExtraValue\"\n    return node\nd2g.config_func_node_post_modifier = custom_post_func\nd2g.config_func_node_pre_modifier = custom_pre_func\nd2g.parse(dic)\nd2g.merge(Graph())\n# results in two Nodes (:Person:ExtraPersonLabel{name:\"Hypatia\",ExtraProp:\"ExtraValue\"}) and (:House) with a relation named \"HOUSE_HAS_PERSON\"\n```\n\n#### **config_graphio_batch_size**\n\n- Type: int\n- Default: `10000`\n- Description: Value that will be passed through to `graphio.NodeSet.merge|create(batch_size)` and `graphio.RelationshipSet.merge|create(batch_size)` see https://graphio.readthedocs.io/en/latest/objects.html?highlight=batch#graphio.NodeSet.merge . It determines the commit interval when merging or creating nodes/relations. This can influence perfomance.\n- Example Value: `49634`\n- Example:\n\n```python\ndic = {\"Philosophers\":{\"Person\": [{\"name\": \"Hypatia\"}, {\"name\": \"Epikur\"}, {\"name\": \"Sokrates\"}]}}\nd2g = Dict2graph()\nd2g.config_graphio_batch_size = 2\nd2g.parse(dic)\nd2g.create(Graph())\n# This will push only 2 nodes at a time to the database. Which would be very inefficient when having larger datasets :)\n```\n\n#### **config_dict_create_merge_depending_scheme**\n\n- Type: dict\n- Default: `{\"create\": [], \"merge\": []}`\n- Description: Instead just merging or just creating with `config_dict_create_merge_depending_scheme` one can decide per type, which clause should be used. You have to use `Json2grahio.create_merge_depending()`. You can define node by primary label or relation by type name\n- Example Value: `{\"create\": [\"myLabel\",\"MYLABEL_HAS_OTHERLABEL\"], \"merge\": [\"AnotherLabel\"]}`\n- Example:\n\n```python\ndic = {\"Philosophers\":{\"Person\": [{\"name\": \"Hypatia\"}, {\"name\": \"Epikur\"}, {\"name\": \"Sokrates\"}]}}\nd2g = Dict2graph()\nd2g.config_dict_create_merge_depending_scheme = {\"create\": [\"Philosophers\"], \"merge\": [\"Person\"]}\nd2g.parse(dic)\n# with Dict2graph.create_merge_depending(default) you can define the default operation for nodes or relations not defined in config_dict_create_merge_depending_scheme\nd2g.create_merge_depending(Graph(),default=\"create\")\n# This will create :Philosophers node and merge :Person nodes\n```\n\n#### **config_dict_property_to_extra_node**\n\n- Type: dict\n- Default: `{}`\n- Description: Spin of an extra node based on a node property. Optional you can copy the property to a new node instead of moving it.\n- Example Value: `{\"MyLabel\": [\"MyProp1\",\"MyProp2\"],\"MyOtherLabel\":[\"MyOtherProp\"], \"MyLabelWithCopiedVal\":{\"Prop1\":\"copy\",\"prop2:\"move\",\"prop3\":\"move\"}}`\n- Example:\n\n```python\ndic = {\"Philosophers\":{\"Person\": [{\"name\": \"Hypatia\", \"period\":\"Late antiquity\"}, {\"name\": \"Epikur\",\"period\":\"Roman Republic\"}, {\"name\": \"Sokrates\",\"period\":\"Athenian democracy\"}]}}\nd2g = Dict2graph()\nd2g.config_dict_property_to_extra_node = {\"Person\":[\"period\"]}\nd2g.parse(dic)\nd2g.merge(Graph())\n# This will create extra nodes for \"period\" (e.g. (:period{perdiod:\"Late antiquity\"}) ) instead of attaching it as an property of :Person. The :period node will be connected to the :Person node\n```\n\n#### **config_dict_interfold_json_attr**\n\n- Type: dict\n- Default: `{}`\n- Description: Elevate the attributes of an sub dic object to its parent. (e.g. `{\"Parent\":{\"data\":{\"Familyname\":\"Gump\"}}}` will be transformed to `{\"Parent\":{\"Familyname\":\"Gump\"}`). This helps to populate a node with data from nested dic objects. Per dic-object/label you have two optional parameters:\n  1.  \"attrs\" is a list to define which attribute you want to elevate. If \"attrs\" is not declared all dic attributes will be elevated.\n  2.  \"combine_attr_names\" is a boolean value to define if you want to cmbine the parent object name with the child attrs name. This can help to distinguish the attributes and prevent name collisions\n- Example Value: `{\"dic-object-attr-aka-label\":{\"dic-object-attrs\":{\"combine_attr_names\":True}}` or `{\"dic-object-attr-aka-label\":{\"dic-object-attr\":None}}`\n- Example:\n\n```python\ndic = {\"Philosophers\":{\"Person\": [{\"id\":1,\"data\":{\"name\": \"Hypatia\"}},{\"id\":1,\"data\":{\"name\": \"Hypatia\"}},{\"id\":1,\"data\":{\"name\": \"Hypatia\"}}]}}\nd2g = Dict2graph()\nd2g.config_dict_interfold_json_attr = {\"Person\":{\"data\":{\"combine_attr_names\":False}}\nd2g.parse(dic)\nd2g.merge(Graph())\n# This will create :Person nodes with a \"name\" property. Without `config_dict_interfold_json_attr` it would result in :Person nodes with an extra child node :data (having the \"name\" property)\n```\n\n#### **config_dict_attr_name_to_reltype_instead_of_label**\n\n- Type: dict\n- Default: `{}`\n- Description: Force certain labels to override with new label (similar to `config_dict_label_override`), but save original label to relation type. \n- Example Value: `{\"oldLabel\":\"NewLabel\", \"otherOldLabel\":\"NewLabel\"}`\n- Exmaple\n\n```python\ndic = {\"Person\": {\"name\": \"Ben\", \"daughters\": [\"Kielyr\"], \"sons\": [\"Bodevan\"],}}\nd2g = Dict2graph()\nd2g.config_dict_attr_name_to_reltype_instead_of_label = {\n    \"daughters\": \"Child\",\n    \"sons\": \"Child\",\n}\n# Ditch collection hubs for children\nd2g.config_list_skip_collection_hubs = [\"ChildCollection\"]\nd2g.parse(dic)\nd2g.create(Graph())\n```\nResults in a graph like `(:Child)<-DAUGHTERS-(:Person)-SONS->(:Child)` instead of `(:daughters)<-PERSON_HAS_DAUGHTERS-(:Person)-PERSON_HAS_SONS->(:sons)`\n\n#### **config_dict_node_prop_to_rel_prop**\n\n- Type: dict\n- Default: `{}`\n- Description: Move certain node properties to one of the relations connected to the node. Per node label and property you can set a list of relationships the property should move to. \n- Example Value: `{\"MyNodeLabel\":{\"MyNodeLabelProperty\":[\"MYRELATION_HAS_NAME\"], \"myotherprop\":[\"MYOTHERREL\"]}`\n- Example\n\n```python\ndic = {\n    \"Person\": {\n        \"name\": \"Ben\",\n        \"child\": [\n            {\"type\": \"Son\", \"name\": \"Kielyr\"},\n            {\"type\": \"Daughter\", \"name\": \"Bodevan\"},\n        ],\n    }\n}\n\nd2g = Dict2graph()\nd2g.config_list_allowlist_collection_hubs = [\"None\"]\nd2g.config_dict_node_prop_to_rel_prop = {\"Person\": {\"type\":[\"PERSON_HAS_CHILD\"]}}\nd2g.config_dict_primarykey_attr_by_label = {\"child\": [\"name\"]}\nd2g.parse(dic)\nd2g.merge(Graph())\n```\nResults in a graph like  `(:child)<-[PERSON_HAS_CHILD{type:\"Son\"}-(:Person)-[PERSON_HAS_CHILD{type:\"Daugther\"}->(:child)`\n\n\n#### **config_list_throw_away_from_nodes**\n\n- Type: dict\n- Default: `{}`\n- Description: Ignore all data attached to certain node and node itself \n- Example Value: `[\"NodelabelIdontWant\",\"OtherLabel\"]`\n- Example\n\n\n```python\ndic = {\n    \"Philosophers\": {\n        \"Person\": [\n            {\n                \"id\": 1,\n                \"name\": \"Hypatia\",\n                \"unwanted_data\": {\"stuff\": \"we\", \"dont\": \"want\"},\n            },\n            {\"id\": 2, \"name\": \"Other\"},\n        ]\n    }\n}\nd2g = Dict2graph()\nd2g.config_list_throw_away_from_nodes = [\"unwanted_data\"]\nd2g.parse(dic)\nd2g.merge(Graph())\n```\nResults in a graph like  `(:Person{\"name\":\"Hypatia\",\"id\":1})<-(:Philosophers)->(:Person{\"name\":\"Other\",\"id\":2})`. note that `(:unwanted_data{\"stuff\": \"we\", \"dont\": \"want\"})` is missing\n\n\n#### **config_list_throw_away_nodes_with_no_or_empty_attrs**\n\n- Type: dict\n- Default: `{}`\n- Description: Throw away empty nodes of a certain label. Empty means; no attributes or all attributes have a `None` value\n- Example Value: `[\"NodelabelIdontWant\",\"OtherLabel\"]`\n- Example\n\n```python\ndic = {\"Person\": [{\"name\": \"Mahony\"}, {}]}\nd2g = Dict2graph()\nd2g.config_list_allowlist_collection_hubs = [None]\nd2g.config_list_throw_away_nodes_with_no_or_empty_attrs = [\"Person\"]\nd2g.parse(dic)\nd2g.merge(Graph())\n```\nThis will only insert only one person node `(:Person{\"name\": \"Mahony\"})` instead of another empty one `:Person{}`\n\n\n#### **config_list_throw_away_nodes_with_empty_key_attr**\n\n- Type: dict\n- Default: `{}`\n- Description: Throw away nodes with missing primary/merge property of a certain label. Empty means; no attributes or primary attributes have a `None` value\n- Example Value: `[\"NodelabelIdontWant\",\"OtherLabel\"]`\n- Example\n\n```python\ndic = {\"Person\": [{\"name\": \"Mahony\", \"age\": 23}, {\"age\": 25}]}\nd2g = Dict2graph()\nd2g.config_list_allowlist_collection_hubs = [None]\nd2g.config_dict_primarykey_attr_by_label = {\"Person\": [\"name\"]}\nd2g.config_list_throw_away_nodes_with_empty_key_attr = [\"Person\"]\nd2g.parse(dic)\nd2g.merge(Graph())\n```\n This will only insert one person node `(:Person{\"name\": \"Mahony\", \"age\": 23})` instead of another additional node with only the age `(:Person{\"age\": 25})` (or actually throwing an py2neo error, because of the missing merge key)\n\n\n### More Examples\n\nA collection of use cases and examples\n\n**Use config_dict_interfold_json_attr for skipping in-between nodes**\n\n```python\nfrom dict2graph import Dict2graph\nfrom py2neo import Graph\n\ndic = {\n    \"Person\": {\n        \"name\": \"Rudolf Manga Bell\",\n        \"Friend\": {\"Person\": {\"name\": \"Ekandjoum Joseph\"}},\n    },\n}\nd2g = Dict2graph()\nd2g.parse(dic)\nd2g.create(Graph())\n```\n\nresults in (:Person)<--(:Friend)-->(:Person)\n\nThe :Friend node is kind of unecessary and can be replaced with a direct relationship.\nThe desired graph would be (:Person)<-FRIEND_WITH->(:Person).\nThis can be achieved with:\n\n```python\nfrom dict2graph import Dict2graph\nfrom py2neo import Graph\n\ndic = {\n    \"Person\": {\n        \"name\": \"Rudolf Manga Bell\",\n        \"Friend\": {\"Person\": {\"name\": \"Ekandjoum Joseph\"}},\n    },\n}\nd2g = Dict2graph()\nd2g.config_dict_interfold_json_attr = {\"Person\": {\"Friend\": None}}\nd2g.config_dict_reltype_override = {\"PERSON_HAS_PERSON\": \"FRIEND_WITH\"}\nd2g.parse(dic)\nd2g.create(Graph())\n```\n\n## Other Options\n\n**set_insert_failed_callback**\n\n- Type: function\n- Default: `None`\n- Description: callback function if merging or creating of a certain nodeset/relationship set fails. parameters are setname and error. setname will be the Reltype or Nodeset primary label.\n- Example:\n```python\ndef cb(setname,e,setcontent):\n    if e in (TransactionError, TransientError):\n        print(\"Lock failure for inserting label or reltype named '{}'\".format(setname))\n        dump_to_file(setcontent)\n    else:    \n        raise e\n\nd2g = Dict2graph()\nd2g.set_insert_failed_callback = cb\n```\n\n\n\n**max_retries_on_insert_errors**\n\n`int`\n\nwhen insert failes due to lock error retry n times\n\n**max_retry_wait_time_sec**\n\n`int`\n\nwhen retrieing due to failed insert wait a random time from 1 second to `max_retry_wait_time_sec` seconds\n\n**disable_config_sanity_check**\n\n`True` or `False`\n\nwhen calling `Dict2graph.parse` a basic config check will be done. Can be disabled when config has proven. Could improve perfomance (but not really ATM, as the check is very basic and simple (aka fast))\n\n\n",
            "description_content_type": "text/markdown",
            "docs_url": null,
            "download_url": "",
            "downloads": {
                "last_day": -1,
                "last_month": -1,
                "last_week": -1
            },
            "home_page": "https://git.connect.dzd-ev.de/dzdpythonmodules/dict2graph",
            "keywords": "",
            "license": "MIT",
            "maintainer": "",
            "maintainer_email": "",
            "name": "dict2graph",
            "package_url": "https://pypi.org/project/dict2graph/",
            "platform": "",
            "project_url": "https://pypi.org/project/dict2graph/",
            "project_urls": {
                "Homepage": "https://git.connect.dzd-ev.de/dzdpythonmodules/dict2graph"
            },
            "release_url": "https://pypi.org/project/dict2graph/2.0.0/",
            "requires_dist": [
                "py2neo",
                "graphio",
                "linetimer"
            ],
            "requires_python": ">=3.9",
            "summary": "Class to extract, transform and load (ETL) dicts/json to a Neo4j graph",
            "version": "2.0.0",
            "yanked": false,
            "yanked_reason": null
        },
        "last_serial": 12235488,
        "urls": [
            {
                "comment_text": "",
                "digests": {
                    "md5": "5278216d0b6656991ffbca4b4b7ef0fa",
                    "sha256": "c54399bed14729c013813848745734db1df0a994cbe2f98353afb6c1a4489e9b"
                },
                "downloads": -1,
                "filename": "dict2graph-2.0.0-py3-none-any.whl",
                "has_sig": false,
                "md5_digest": "5278216d0b6656991ffbca4b4b7ef0fa",
                "packagetype": "bdist_wheel",
                "python_version": "py3",
                "requires_python": ">=3.9",
                "size": 24887,
                "upload_time": "2021-12-07T15:49:58",
                "upload_time_iso_8601": "2021-12-07T15:49:58.208892Z",
                "url": "https://files.pythonhosted.org/packages/2b/c5/5f5638045f1bd5ee4b093f8c18f486c57debcda6ad0cd9237839261788ae/dict2graph-2.0.0-py3-none-any.whl",
                "yanked": false,
                "yanked_reason": null
            },
            {
                "comment_text": "",
                "digests": {
                    "md5": "9753b6d01c5e1dcda0c1ce327cb4fcd1",
                    "sha256": "6f7dba77586af947094f0f725ebfde497e4e7911c9138642554acdd65cffbcca"
                },
                "downloads": -1,
                "filename": "dict2graph-2.0.0.tar.gz",
                "has_sig": false,
                "md5_digest": "9753b6d01c5e1dcda0c1ce327cb4fcd1",
                "packagetype": "sdist",
                "python_version": "source",
                "requires_python": ">=3.9",
                "size": 259185,
                "upload_time": "2021-12-07T15:50:00",
                "upload_time_iso_8601": "2021-12-07T15:50:00.264890Z",
                "url": "https://files.pythonhosted.org/packages/6c/66/bfd6dffd7ee7040698ed85561aa20e99af6e48351bfa146d38e5d57889a2/dict2graph-2.0.0.tar.gz",
                "yanked": false,
                "yanked_reason": null
            }
        ],
        "vulnerabilities": []
    }
}