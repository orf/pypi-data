{
    "1.10.0": {
        "info": {
            "author": "Amazon Web Services",
            "author_email": "aws-cryptools@amazon.com",
            "bugtrack_url": null,
            "classifiers": [
                "Development Status :: 5 - Production/Stable",
                "Intended Audience :: Developers",
                "License :: OSI Approved :: Apache Software License",
                "Natural Language :: English",
                "Programming Language :: Python",
                "Programming Language :: Python :: 2",
                "Programming Language :: Python :: 2.7",
                "Programming Language :: Python :: 3",
                "Programming Language :: Python :: 3.4",
                "Programming Language :: Python :: 3.5",
                "Programming Language :: Python :: 3.6",
                "Programming Language :: Python :: 3.7",
                "Programming Language :: Python :: 3.8",
                "Programming Language :: Python :: 3.9",
                "Programming Language :: Python :: Implementation :: CPython",
                "Topic :: Security",
                "Topic :: Security :: Cryptography"
            ],
            "description_content_type": "",
            "docs_url": null,
            "download_url": "",
            "downloads": {
                "last_day": -1,
                "last_month": -1,
                "last_week": -1
            },
            "home_page": "https://github.com/aws/aws-encryption-sdk-python",
            "keywords": "aws-encryption-sdk aws kms encryption",
            "license": "Apache License 2.0",
            "maintainer": "Amazon Web Services",
            "maintainer_email": "",
            "name": "aws-encryption-sdk",
            "package_url": "https://pypi.org/project/aws-encryption-sdk/",
            "platform": null,
            "project_url": "https://pypi.org/project/aws-encryption-sdk/",
            "project_urls": {
                "Homepage": "https://github.com/aws/aws-encryption-sdk-python"
            },
            "release_url": "https://pypi.org/project/aws-encryption-sdk/1.10.0/",
            "requires_dist": [
                "boto3 (>=1.10.0)",
                "cryptography (<=3.3.2,>=2.5.0)",
                "attrs (>=17.4.0)",
                "wrapt (>=1.10.11)"
            ],
            "requires_python": "",
            "summary": "AWS Encryption SDK implementation for Python",
            "version": "1.10.0",
            "yanked": false,
            "yanked_reason": null
        },
        "last_serial": 14939260,
        "urls": [
            {
                "comment_text": "",
                "digests": {
                    "md5": "5cc23df3a9d649b2ef5e869ef6181841",
                    "sha256": "1d6e2fa561b5ad508900fac1bd83d29b37a048afe6ca791777d4800e615a658c"
                },
                "downloads": -1,
                "filename": "aws_encryption_sdk-1.10.0-py2.py3-none-any.whl",
                "has_sig": false,
                "md5_digest": "5cc23df3a9d649b2ef5e869ef6181841",
                "packagetype": "bdist_wheel",
                "python_version": "py2.py3",
                "requires_python": null,
                "size": 92291,
                "upload_time": "2022-06-21T20:36:19",
                "upload_time_iso_8601": "2022-06-21T20:36:19.935748Z",
                "url": "https://files.pythonhosted.org/packages/f6/dd/dd0afa59cdb9a84d66a7aff54603026b2a3d0399b96097f58d0873116ee2/aws_encryption_sdk-1.10.0-py2.py3-none-any.whl",
                "yanked": false,
                "yanked_reason": null
            },
            {
                "comment_text": "",
                "digests": {
                    "md5": "7edd2c812d3c38f58523be7269e26456",
                    "sha256": "b41bf354f677fcd08cf89aeda2b3730a6c2185172d20ff89dca652a5e7f8b070"
                },
                "downloads": -1,
                "filename": "aws-encryption-sdk-1.10.0.tar.gz",
                "has_sig": false,
                "md5_digest": "7edd2c812d3c38f58523be7269e26456",
                "packagetype": "sdist",
                "python_version": "source",
                "requires_python": null,
                "size": 157364,
                "upload_time": "2022-06-21T20:36:23",
                "upload_time_iso_8601": "2022-06-21T20:36:23.211370Z",
                "url": "https://files.pythonhosted.org/packages/7e/be/7367db04f238d53e1a2eb42f79a0a85734386f44a4c03b4827f8e7256219/aws-encryption-sdk-1.10.0.tar.gz",
                "yanked": false,
                "yanked_reason": null
            }
        ],
        "vulnerabilities": [
            {
                "aliases": [
                    "CVE-2020-8897"
                ],
                "details": "Authors: Thai \"[thaidn](https://twitter.com/xorninja)\" Duong\n\n# Summary\n\nThe following security vulnerabilities was discovered and reported to Amazon, affecting AWS KMS and all versions of [AWS Encryption SDKs](https://docs.aws.amazon.com/encryption-sdk/latest/developer-guide/introduction.html) prior to version 2.0.0:\n\n* **Information leakage**: an attacker can create ciphertexts that would leak the user\u2019s AWS account ID, encryption context, user agent, and IP address upon decryption\n* **Ciphertext forgery**: an attacker can create ciphertexts that are accepted by other users\n* **Robustness**: an attacker can create ciphertexts that decrypt to different plaintexts for different users\n\nThe first two bugs are somewhat surprising because they show that the ciphertext format can lead to vulnerabilities. These bugs (and the infamous [alg: \"None\"](https://auth0.com/blog/critical-vulnerabilities-in-json-web-token-libraries/) bugs in JWT) belong to a class of vulnerabilities called **in-band protocol negotiation**. This is the second time we\u2019ve found in-band protocol negotiation vulnerabilities in AWS cryptography libraries; see this [bug](https://github.com/google/security-research/security/advisories/GHSA-7f33-f4f5-xwgw) in S3 Crypto SDK discovered by my colleague Sophie Schmieg.\n\nIn JWT and S3 SDK the culprit is the algorithm field\u2014here it is the key ID. Because the key ID is used to determine which decryption key to use, it can\u2019t be meaningfully authenticated despite being under the attacker\u2019s control. If the key ID is a URL indicating where to fetch the key, the attacker can replace it with their own URL, and learn side-channel information such as the timing and machines on which the decryption happens (this can also lead to [SSRF](https://portswigger.net/web-security/ssrf) issues, but that\u2019s another topic for another day).\n\nIn AWS, the key ID is a unique [Amazon Resource Name](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html). If an attacker were to capture a ciphertext from a user and replace its key ID with their own, the victim\u2019s AWS account ID, encryption context, user agent, and IP address would be logged to the attacker\u2019s AWS account whenever the victim attempted to decrypt the modified ciphertext.\n\nThe last bug shows that the non-committing property of AES-GCM (and other AEAD ciphers such as [AES-GCM-SIV](https://keymaterial.net/2020/09/07/invisible-salamanders-in-aes-gcm-siv/) or (X)ChaCha20Poly1305) is especially problematic in multi-recipient settings. These ciphers have a property that can cause nonidentical plaintexts when decrypting a single ciphertext with two different keys! For example, you can send a single encrypted email to Alice and Bob which, upon decryption, reads \u201cattack\u201d to Alice and \u201cretreat\u201d to Bob. The AWS Encryption SDKs are vulnerable to this attack because they allow a single ciphertext to be generated for multiple recipients, with each decrypting using a different key. I believe this kind of problem is prevalent. I briefly looked at [JWE](https://tools.ietf.org/html/rfc7516) and I think it is vulnerable.\n\n# Mitigations\n\nAmazon has fixed these bugs in release 2.0.0 of the SDKs. A new major version was required because, unfortunately, the fix for the last bug requires a breaking change from earlier versions. All users are recommended to upgrade. More details about Amazon\u2019s mitigations can be found in [their announcement](https://aws.amazon.com/blogs/security/improved-client-side-encryption-explicit-keyids-and-key-commitment/).\n\nWe\u2019re collaborating with Shay Gueron on a paper regarding fast committing AEADs.\n\n# Vulnerabilities\n\n## Information Leakage\n\nThe [Encrypt](https://docs.aws.amazon.com/kms/latest/APIReference/API_Encrypt.html) API in AWS KMS encrypts plaintext into ciphertext by using a customer master key (CMK). The ciphertext format is undocumented, but it contains metadata that specifies the CMK and the encryption algorithm. I reverse-engineered the format and found the location of the CMK. Externally the CMK is identified by its key ARN, but within a ciphertext it is represented by an internal ID, which remained stable during my testing.\n\nWhen I replaced the internal ID of a CMK in a ciphertext with the internal ID of another CMK, I found that AWS KMS attempted to decrypt the ciphertext with the new CMK. The encryption failed and the failure event\u2014including the AWS Account ID, the user agent and the IP address of the caller\u2014was logged to Cloud Trail in the account that owned the replacement CMK.\n\nThis enables the following attack:\n* The attacker creates a CMK that has a key policy that allows access from everyone. This requires no prior knowledge about the victim.\n* The attacker intercepts a ciphertext from the victim, and replaces its CMK with their CMK.\n* Whenever the victim attempts to decrypt the modified ciphertext, the attacker learns the timing of such actions, the victim\u2019s AWS Account ID, user agent, encryption context, and IP address.\n\nThis attack requires the victim to have an IAM policy that allows them to access the attacker\u2019s CMK. I found that this practice was allowed by the AWS Visual Policy Editor, but I don\u2019t know whether it is common.\n\nThe AWS Encryption SDKs also succumb to this attack. The SDKs implement envelope encryption: encrypting data with a data encryption key (DEK) and then wrapping the DEK with a CMK using the Encrypt API in AWS KMS. The wrapped DEK is stored as part of the final ciphertext (format is defined [here](https://docs.aws.amazon.com/encryption-sdk/latest/developer-guide/message-format.html)). The attacker can mount this attack by replacing the CMK in the wrapped DEK with their own.\n\n```\n{\n    \"eventVersion\": \"1.05\",\n    \"userIdentity\": {\n        \"type\": \"AWSAccount\",\n        \"principalId\": \"<redacted this is the principal ID of the victim>\",\n        \"accountId\": \"<redacted - this is the AWS account ID of the victim>\"\n    },\n    \"eventTime\": \"2020-06-21T21:05:04Z\",\n    \"eventSource\": \"kms.amazonaws.com\",\n    \"eventName\": \"Decrypt\",\n    \"awsRegion\": \"us-west-2\",\n    \"sourceIPAddress\": \"<redacted - this is the IP address of the victim>\",\n    \"userAgent\": \"<redacted - this is the user agent of the victim>\",\n    \"errorCode\": \"InvalidCiphertextException\",\n    \"requestParameters\": {\n        // The encryption context might include other data from the victim\n        \"encryptionContext\": {\n            \"aws-crypto-public-key\": \"AzfNOGOnNYFmpHspKrAm1L6XtRybONkmkhmB/IriKSA7b2NsV4MEPMph9yX2KTPKWw==\"\n        },\n        \"encryptionAlgorithm\": \"SYMMETRIC_DEFAULT\"\n    },\n    \"responseElements\": null,\n    \"requestID\": \"aeced8e8-75a2-42c3-96ac-d1fa2a1c5ee6\",\n    \"eventID\": \"780a0a6e-4ad8-43d4-a426-75d05022f870\",\n    \"readOnly\": true,\n    \"resources\": [\n        {\n            \"accountId\": \"<redacted - this is the account ID of the attacker>\",\n            \"type\": \"AWS::KMS::Key\",\n            \"ARN\": <redacted - this is the key ARN of the attacker>\n        }\n    ],\n    \"eventType\": \"AwsApiCall\",\n    \"recipientAccountId\": \"<redacted - this is the account ID of the attacker>\",\n    \"sharedEventID\": \"033e147c-8a36-42f5-9d6c-9e071eb752b7\"\n}\n```\n**Figure 1: A failure event logged to the attacker\u2019s Cloud Trail when the victim attempted to decrypt a modified ciphertext containing the attacker\u2019s CMK.**\n\n## Ciphertext Forgery\n\nThe [Decrypt](https://docs.aws.amazon.com/kms/latest/APIReference/API_Decrypt.html) API in AWS KMS doesn\u2019t require the caller to specify the CMK. This parameter is required only when the ciphertext was encrypted under an asymmetric CMK. Otherwise, AWS KMS uses the metadata that it adds to the ciphertext blob to determine which CMK was used to encrypt the ciphertext.\n\nThis leads to the following attack:\n* The attacker creates a CMK that has a key policy that allows access from everyone. This requires no prior knowledge about the victim.\n* The attacker generates a ciphertext by calling the Encrypt API with their key.\n* The attacker intercepts a ciphertext from the victim, and replaces it entirely with their ciphertext.\n* The victim successfully decrypts the ciphertext, as if it was encrypted under their own key. The attacker also learns when this happened, the victim\u2019s AWS Account ID, user agent, encryption context, and IP address.\n\nSimilar to the information leakage attack, this attack also requires the victim to have an IAM policy that allows them to access the attacker\u2019s CMK.\n\nThe AWS Encryption SDKs also succumb to this attack. They don\u2019t specify the CMK when they call the Decrypt API to unwrap the DEK.\n\n## Robustness\n\nThe AWS Encryption SDKs allow a single ciphertext to be generated for multiple recipients, with each decrypting using a different key. To that end, it wraps the DEK multiple times, each under a different CMK. The wrapped DEKs can be combined to form a single ciphertext which can be sent to multiple recipients who can use their own credentials to decrypt it. It\u2019s reasonable to expect that all recipients should decrypt the ciphertext to an identical plaintext. However, because of the use of AES-GMAC and AES-GCM, it\u2019s possible to create a ciphertext that decrypts to two valid yet different plaintexts for two different users. In other words, the AWS Encryption SDKs are [not](https://eprint.iacr.org/2008/440.pdf) [robust](https://eprint.iacr.org/2019/016.pdf).\n\nThe encryption of a message under two CMKs can be summarized as follows:\n* A DEK is randomly generated, and two wrapped DEKs are produced by calling the Encrypt API using the two CMKs\n* A per-message AES-GCM key (K) is derived using HKDF from the DEK, a randomly generated message ID, and a fixed algorithm ID.\n* A header is formed from the wrapped DEKs, the encryption context, and other metadata. A header authentication tag is computed on the header using AES-GMAC with K and a zero IV.\n* The message is encrypted using AES-GCM with K, a non-zero IV, and fixed associated additional data. This produces a message authentication tag.\n* The ciphertext consists of the header, the header authentication tag, the encrypted message, and the message authentication tag.\n\n(There\u2019s also a self-signed digital signature that is irrelevant to this discussion).\n\nIn order to decrypt a ciphertext, the AWS Encryption SDKs loops over the list of wrapped DEKs and returns the first one that it can successfully unwrap. The attacker therefore can wrap a unique DEK for each recipient. Next, the attacker exploits the non-committing property of GMAC to produce two messages that have the same GMAC tag under two different keys. The attacker has to do this twice, one for the header authentication tag and one for the message authentication tag.\n\n```\nGiven a data blob B of one 128-bit block B_1, a GMAC tag is computed as follows:\n\nB_1 * H^2 + B_len * H + J\n\nwhere H and J depends on the key and B_len depends on the length of B.\n\nTo find a message that can produce the same tag under two different keys, one\ncan add append to B a new block B_2 whose value can be deduced by solving\nan algebraic equation. That is, we want to find B_2 such that:\n\nB_1 * H^3 + B_2 * H^2 + B_len * H + J = B_1 * H\u2019^3 + B_2 * H\u2019^2 + B_len * H\u2019 + J\u2019\n\nwhere H\u2019 and J\u2019 are the corresponding H and J of the other key.\n\nB_2 is the only unknown value in this equation, thus it can be computed using\nfinite field arithmetics of GF(2^128):\n\nB_2 = [B_1 * (H^3+H\u2019^3) + B_len * (H + H\u2019) + J + J\u2019] * (H^2 + H\u2019^2)^-1.\n```\n**Figure 2: How to find a message that has the same GMAC tag under two different keys.**\n\nThe overall attack works as follows:\n* The attacker generates a random DEK, derives a per-message key K, and encrypts message M with it using AES in counter mode. This generates a ciphertext C.\n* The attacker generates another random DEK\u2019, derives a per-message key K\u2019, and performs trial decryption of C until the decrypted message M\u2019 has desirable properties. For example, if the attacker wants the first bit of M\u2019 different from that of M, this process should only take a few attempts.\n* The attacker finds a block C* such that the GMAC of C\u2019 = C || C* under K and K\u2019 are identical. Denote this tag C\u2019_tag.\n* The attacker wraps DEK and DEK\u2019 under two recipients\u2019 CMK.\n* The attacker forms a header H and adds a block H* to the encryption context such that the new H\u2019 has the same authentication tag H\u2019_tag under K and K\u2019.\n* The attacker output H\u2019, H\u2019_tag, C\u2019, C\u2019_tag.\n\nThis attack is similar to the one discovered in [Facebook Messenger](https://eprint.iacr.org/2019/016.pdf).\n\n# Acknowledgement\n\nI\u2019m grateful to Jen Barnason for carefully editing this advisory. I will never publish anything without her approval! I want to thank my friend and coworker Sophie \u201cQueen of Hashing\u201d Schmieg for wonderful discussions and for showing me how the arithmetic in GF(2^128) works. I want to thank Jonathan Bannet for asking the questions that led to this work.",
                "fixed_in": [
                    "2.0.0"
                ],
                "id": "GHSA-wqgp-vphw-hphf",
                "link": "https://osv.dev/vulnerability/GHSA-wqgp-vphw-hphf",
                "source": "osv",
                "summary": null,
                "withdrawn": null
            }
        ]
    },
    "1.10.1": {
        "info": {
            "author": "Amazon Web Services",
            "author_email": "aws-cryptools@amazon.com",
            "bugtrack_url": null,
            "classifiers": [
                "Development Status :: 5 - Production/Stable",
                "Intended Audience :: Developers",
                "License :: OSI Approved :: Apache Software License",
                "Natural Language :: English",
                "Programming Language :: Python",
                "Programming Language :: Python :: 2",
                "Programming Language :: Python :: 2.7",
                "Programming Language :: Python :: 3",
                "Programming Language :: Python :: 3.4",
                "Programming Language :: Python :: 3.5",
                "Programming Language :: Python :: 3.6",
                "Programming Language :: Python :: 3.7",
                "Programming Language :: Python :: 3.8",
                "Programming Language :: Python :: 3.9",
                "Programming Language :: Python :: Implementation :: CPython",
                "Topic :: Security",
                "Topic :: Security :: Cryptography"
            ],
            "description_content_type": "",
            "docs_url": null,
            "download_url": "",
            "downloads": {
                "last_day": -1,
                "last_month": -1,
                "last_week": -1
            },
            "home_page": "https://github.com/aws/aws-encryption-sdk-python",
            "keywords": "aws-encryption-sdk aws kms encryption",
            "license": "Apache License 2.0",
            "maintainer": "Amazon Web Services",
            "maintainer_email": "",
            "name": "aws-encryption-sdk",
            "package_url": "https://pypi.org/project/aws-encryption-sdk/",
            "platform": null,
            "project_url": "https://pypi.org/project/aws-encryption-sdk/",
            "project_urls": {
                "Homepage": "https://github.com/aws/aws-encryption-sdk-python"
            },
            "release_url": "https://pypi.org/project/aws-encryption-sdk/1.10.1/",
            "requires_dist": [
                "boto3 (>=1.10.0)",
                "cryptography (<=3.3.2,>=2.5.0)",
                "attrs (>=17.4.0)",
                "wrapt (>=1.10.11)"
            ],
            "requires_python": "",
            "summary": "AWS Encryption SDK implementation for Python",
            "version": "1.10.1",
            "yanked": false,
            "yanked_reason": null
        },
        "last_serial": 14939260,
        "urls": [
            {
                "comment_text": "",
                "digests": {
                    "md5": "6322a2b22676c27f4608c01d386c2333",
                    "sha256": "b1d9d05ed95b88bdaabbf15d3b12d9583ebe233daa63eee9c0a0fc0cc4867883"
                },
                "downloads": -1,
                "filename": "aws_encryption_sdk-1.10.1-py2.py3-none-any.whl",
                "has_sig": false,
                "md5_digest": "6322a2b22676c27f4608c01d386c2333",
                "packagetype": "bdist_wheel",
                "python_version": "py2.py3",
                "requires_python": null,
                "size": 92409,
                "upload_time": "2022-08-30T19:24:53",
                "upload_time_iso_8601": "2022-08-30T19:24:53.580876Z",
                "url": "https://files.pythonhosted.org/packages/a6/c0/a68ecd5508165be97e9688f49ac2c24c7648360fac736355ec85204e957f/aws_encryption_sdk-1.10.1-py2.py3-none-any.whl",
                "yanked": false,
                "yanked_reason": null
            },
            {
                "comment_text": "",
                "digests": {
                    "md5": "ea7794a1013096681d2761e5aa89dce8",
                    "sha256": "0ebfa4aeaa5f89fe537d3d8bba898c6e2563be9f26668021939683cdeb42958a"
                },
                "downloads": -1,
                "filename": "aws-encryption-sdk-1.10.1.tar.gz",
                "has_sig": false,
                "md5_digest": "ea7794a1013096681d2761e5aa89dce8",
                "packagetype": "sdist",
                "python_version": "source",
                "requires_python": null,
                "size": 157608,
                "upload_time": "2022-08-30T19:24:58",
                "upload_time_iso_8601": "2022-08-30T19:24:58.052202Z",
                "url": "https://files.pythonhosted.org/packages/af/a8/ca84ff4b55ae5d4c2cdfbbc9413b2feffb05acd56db58c31cbb82700c4b3/aws-encryption-sdk-1.10.1.tar.gz",
                "yanked": false,
                "yanked_reason": null
            }
        ],
        "vulnerabilities": []
    },
    "1.2.0": {
        "info": {
            "author": "Amazon Web Services",
            "author_email": "",
            "bugtrack_url": null,
            "classifiers": [
                "Development Status :: 5 - Production/Stable",
                "Intended Audience :: Developers",
                "License :: OSI Approved :: Apache Software License",
                "Natural Language :: English",
                "Programming Language :: Python",
                "Programming Language :: Python :: 2",
                "Programming Language :: Python :: 2.7",
                "Programming Language :: Python :: 3",
                "Programming Language :: Python :: 3.4",
                "Programming Language :: Python :: Implementation :: CPython",
                "Topic :: Security",
                "Topic :: Security :: Cryptography"
            ],
            "description_content_type": null,
            "docs_url": null,
            "download_url": "",
            "downloads": {
                "last_day": -1,
                "last_month": -1,
                "last_week": -1
            },
            "home_page": "https://github.com/awslabs/aws-encryption-sdk-python",
            "keywords": "aws-encryption-sdk aws kms encryption",
            "license": "Apache License 2.0",
            "maintainer": "",
            "maintainer_email": "",
            "name": "aws-encryption-sdk",
            "package_url": "https://pypi.org/project/aws-encryption-sdk/",
            "platform": "UNKNOWN",
            "project_url": "https://pypi.org/project/aws-encryption-sdk/",
            "project_urls": {
                "Homepage": "https://github.com/awslabs/aws-encryption-sdk-python"
            },
            "release_url": "https://pypi.org/project/aws-encryption-sdk/1.2.0/",
            "requires_dist": [
                "attrs (>=16.3.0)",
                "boto3 (>=1.4.4)",
                "cryptography (>=1.4.0)"
            ],
            "requires_python": "",
            "summary": "AWS Encryption SDK implementation for Python",
            "version": "1.2.0",
            "yanked": false,
            "yanked_reason": null
        },
        "last_serial": 14939260,
        "urls": [
            {
                "comment_text": "",
                "digests": {
                    "md5": "c9840e1173b91395200a2d10193bee6a",
                    "sha256": "8341f000174613772397c5ebd2a248e41757cd8ae5aa70886f9c804db8940c52"
                },
                "downloads": -1,
                "filename": "aws_encryption_sdk-1.2.0-py2.py3-none-any.whl",
                "has_sig": false,
                "md5_digest": "c9840e1173b91395200a2d10193bee6a",
                "packagetype": "bdist_wheel",
                "python_version": "py2.py3",
                "requires_python": null,
                "size": 51925,
                "upload_time": "2017-03-21T22:06:12",
                "upload_time_iso_8601": "2017-03-21T22:06:12.839117Z",
                "url": "https://files.pythonhosted.org/packages/5e/5b/d27ccb9de3ac54cd13487174a734f66b9283c78f2ffa52cfc2e3749e6c58/aws_encryption_sdk-1.2.0-py2.py3-none-any.whl",
                "yanked": false,
                "yanked_reason": null
            },
            {
                "comment_text": "",
                "digests": {
                    "md5": "254255a8941c733080915a542f551eaf",
                    "sha256": "7de79298aa1e56f26b9c1ea3874f52aa0b051790ccb6ca96d3d7bb64b766f486"
                },
                "downloads": -1,
                "filename": "aws-encryption-sdk-1.2.0.tar.gz",
                "has_sig": false,
                "md5_digest": "254255a8941c733080915a542f551eaf",
                "packagetype": "sdist",
                "python_version": "source",
                "requires_python": null,
                "size": 39336,
                "upload_time": "2017-03-21T22:06:14",
                "upload_time_iso_8601": "2017-03-21T22:06:14.987848Z",
                "url": "https://files.pythonhosted.org/packages/85/3f/3ccb860d615e238b7ca391153dcfd98478af94d94d37f3dd6f4b64f021ef/aws-encryption-sdk-1.2.0.tar.gz",
                "yanked": false,
                "yanked_reason": null
            }
        ],
        "vulnerabilities": [
            {
                "aliases": [
                    "CVE-2020-8897"
                ],
                "details": "A weak robustness vulnerability exists in the AWS Encryption SDKs for Java, Python, C and Javalcript prior to versions 2.0.0. Due to the non-committing property of AES-GCM (and other AEAD ciphers such as AES-GCM-SIV or (X)ChaCha20Poly1305) used by the SDKs to encrypt messages, an attacker can craft a unique cyphertext which will decrypt to multiple different results, and becomes especially relevant in a multi-recipient setting. We recommend users update their SDK to 2.0.0 or later.",
                "fixed_in": [
                    "2.0.0"
                ],
                "id": "PYSEC-2020-261",
                "link": "https://osv.dev/vulnerability/PYSEC-2020-261",
                "source": "osv",
                "summary": null,
                "withdrawn": null
            },
            {
                "aliases": [
                    "CVE-2020-8897"
                ],
                "details": "Authors: Thai \"[thaidn](https://twitter.com/xorninja)\" Duong\n\n# Summary\n\nThe following security vulnerabilities was discovered and reported to Amazon, affecting AWS KMS and all versions of [AWS Encryption SDKs](https://docs.aws.amazon.com/encryption-sdk/latest/developer-guide/introduction.html) prior to version 2.0.0:\n\n* **Information leakage**: an attacker can create ciphertexts that would leak the user\u2019s AWS account ID, encryption context, user agent, and IP address upon decryption\n* **Ciphertext forgery**: an attacker can create ciphertexts that are accepted by other users\n* **Robustness**: an attacker can create ciphertexts that decrypt to different plaintexts for different users\n\nThe first two bugs are somewhat surprising because they show that the ciphertext format can lead to vulnerabilities. These bugs (and the infamous [alg: \"None\"](https://auth0.com/blog/critical-vulnerabilities-in-json-web-token-libraries/) bugs in JWT) belong to a class of vulnerabilities called **in-band protocol negotiation**. This is the second time we\u2019ve found in-band protocol negotiation vulnerabilities in AWS cryptography libraries; see this [bug](https://github.com/google/security-research/security/advisories/GHSA-7f33-f4f5-xwgw) in S3 Crypto SDK discovered by my colleague Sophie Schmieg.\n\nIn JWT and S3 SDK the culprit is the algorithm field\u2014here it is the key ID. Because the key ID is used to determine which decryption key to use, it can\u2019t be meaningfully authenticated despite being under the attacker\u2019s control. If the key ID is a URL indicating where to fetch the key, the attacker can replace it with their own URL, and learn side-channel information such as the timing and machines on which the decryption happens (this can also lead to [SSRF](https://portswigger.net/web-security/ssrf) issues, but that\u2019s another topic for another day).\n\nIn AWS, the key ID is a unique [Amazon Resource Name](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html). If an attacker were to capture a ciphertext from a user and replace its key ID with their own, the victim\u2019s AWS account ID, encryption context, user agent, and IP address would be logged to the attacker\u2019s AWS account whenever the victim attempted to decrypt the modified ciphertext.\n\nThe last bug shows that the non-committing property of AES-GCM (and other AEAD ciphers such as [AES-GCM-SIV](https://keymaterial.net/2020/09/07/invisible-salamanders-in-aes-gcm-siv/) or (X)ChaCha20Poly1305) is especially problematic in multi-recipient settings. These ciphers have a property that can cause nonidentical plaintexts when decrypting a single ciphertext with two different keys! For example, you can send a single encrypted email to Alice and Bob which, upon decryption, reads \u201cattack\u201d to Alice and \u201cretreat\u201d to Bob. The AWS Encryption SDKs are vulnerable to this attack because they allow a single ciphertext to be generated for multiple recipients, with each decrypting using a different key. I believe this kind of problem is prevalent. I briefly looked at [JWE](https://tools.ietf.org/html/rfc7516) and I think it is vulnerable.\n\n# Mitigations\n\nAmazon has fixed these bugs in release 2.0.0 of the SDKs. A new major version was required because, unfortunately, the fix for the last bug requires a breaking change from earlier versions. All users are recommended to upgrade. More details about Amazon\u2019s mitigations can be found in [their announcement](https://aws.amazon.com/blogs/security/improved-client-side-encryption-explicit-keyids-and-key-commitment/).\n\nWe\u2019re collaborating with Shay Gueron on a paper regarding fast committing AEADs.\n\n# Vulnerabilities\n\n## Information Leakage\n\nThe [Encrypt](https://docs.aws.amazon.com/kms/latest/APIReference/API_Encrypt.html) API in AWS KMS encrypts plaintext into ciphertext by using a customer master key (CMK). The ciphertext format is undocumented, but it contains metadata that specifies the CMK and the encryption algorithm. I reverse-engineered the format and found the location of the CMK. Externally the CMK is identified by its key ARN, but within a ciphertext it is represented by an internal ID, which remained stable during my testing.\n\nWhen I replaced the internal ID of a CMK in a ciphertext with the internal ID of another CMK, I found that AWS KMS attempted to decrypt the ciphertext with the new CMK. The encryption failed and the failure event\u2014including the AWS Account ID, the user agent and the IP address of the caller\u2014was logged to Cloud Trail in the account that owned the replacement CMK.\n\nThis enables the following attack:\n* The attacker creates a CMK that has a key policy that allows access from everyone. This requires no prior knowledge about the victim.\n* The attacker intercepts a ciphertext from the victim, and replaces its CMK with their CMK.\n* Whenever the victim attempts to decrypt the modified ciphertext, the attacker learns the timing of such actions, the victim\u2019s AWS Account ID, user agent, encryption context, and IP address.\n\nThis attack requires the victim to have an IAM policy that allows them to access the attacker\u2019s CMK. I found that this practice was allowed by the AWS Visual Policy Editor, but I don\u2019t know whether it is common.\n\nThe AWS Encryption SDKs also succumb to this attack. The SDKs implement envelope encryption: encrypting data with a data encryption key (DEK) and then wrapping the DEK with a CMK using the Encrypt API in AWS KMS. The wrapped DEK is stored as part of the final ciphertext (format is defined [here](https://docs.aws.amazon.com/encryption-sdk/latest/developer-guide/message-format.html)). The attacker can mount this attack by replacing the CMK in the wrapped DEK with their own.\n\n```\n{\n    \"eventVersion\": \"1.05\",\n    \"userIdentity\": {\n        \"type\": \"AWSAccount\",\n        \"principalId\": \"<redacted this is the principal ID of the victim>\",\n        \"accountId\": \"<redacted - this is the AWS account ID of the victim>\"\n    },\n    \"eventTime\": \"2020-06-21T21:05:04Z\",\n    \"eventSource\": \"kms.amazonaws.com\",\n    \"eventName\": \"Decrypt\",\n    \"awsRegion\": \"us-west-2\",\n    \"sourceIPAddress\": \"<redacted - this is the IP address of the victim>\",\n    \"userAgent\": \"<redacted - this is the user agent of the victim>\",\n    \"errorCode\": \"InvalidCiphertextException\",\n    \"requestParameters\": {\n        // The encryption context might include other data from the victim\n        \"encryptionContext\": {\n            \"aws-crypto-public-key\": \"AzfNOGOnNYFmpHspKrAm1L6XtRybONkmkhmB/IriKSA7b2NsV4MEPMph9yX2KTPKWw==\"\n        },\n        \"encryptionAlgorithm\": \"SYMMETRIC_DEFAULT\"\n    },\n    \"responseElements\": null,\n    \"requestID\": \"aeced8e8-75a2-42c3-96ac-d1fa2a1c5ee6\",\n    \"eventID\": \"780a0a6e-4ad8-43d4-a426-75d05022f870\",\n    \"readOnly\": true,\n    \"resources\": [\n        {\n            \"accountId\": \"<redacted - this is the account ID of the attacker>\",\n            \"type\": \"AWS::KMS::Key\",\n            \"ARN\": <redacted - this is the key ARN of the attacker>\n        }\n    ],\n    \"eventType\": \"AwsApiCall\",\n    \"recipientAccountId\": \"<redacted - this is the account ID of the attacker>\",\n    \"sharedEventID\": \"033e147c-8a36-42f5-9d6c-9e071eb752b7\"\n}\n```\n**Figure 1: A failure event logged to the attacker\u2019s Cloud Trail when the victim attempted to decrypt a modified ciphertext containing the attacker\u2019s CMK.**\n\n## Ciphertext Forgery\n\nThe [Decrypt](https://docs.aws.amazon.com/kms/latest/APIReference/API_Decrypt.html) API in AWS KMS doesn\u2019t require the caller to specify the CMK. This parameter is required only when the ciphertext was encrypted under an asymmetric CMK. Otherwise, AWS KMS uses the metadata that it adds to the ciphertext blob to determine which CMK was used to encrypt the ciphertext.\n\nThis leads to the following attack:\n* The attacker creates a CMK that has a key policy that allows access from everyone. This requires no prior knowledge about the victim.\n* The attacker generates a ciphertext by calling the Encrypt API with their key.\n* The attacker intercepts a ciphertext from the victim, and replaces it entirely with their ciphertext.\n* The victim successfully decrypts the ciphertext, as if it was encrypted under their own key. The attacker also learns when this happened, the victim\u2019s AWS Account ID, user agent, encryption context, and IP address.\n\nSimilar to the information leakage attack, this attack also requires the victim to have an IAM policy that allows them to access the attacker\u2019s CMK.\n\nThe AWS Encryption SDKs also succumb to this attack. They don\u2019t specify the CMK when they call the Decrypt API to unwrap the DEK.\n\n## Robustness\n\nThe AWS Encryption SDKs allow a single ciphertext to be generated for multiple recipients, with each decrypting using a different key. To that end, it wraps the DEK multiple times, each under a different CMK. The wrapped DEKs can be combined to form a single ciphertext which can be sent to multiple recipients who can use their own credentials to decrypt it. It\u2019s reasonable to expect that all recipients should decrypt the ciphertext to an identical plaintext. However, because of the use of AES-GMAC and AES-GCM, it\u2019s possible to create a ciphertext that decrypts to two valid yet different plaintexts for two different users. In other words, the AWS Encryption SDKs are [not](https://eprint.iacr.org/2008/440.pdf) [robust](https://eprint.iacr.org/2019/016.pdf).\n\nThe encryption of a message under two CMKs can be summarized as follows:\n* A DEK is randomly generated, and two wrapped DEKs are produced by calling the Encrypt API using the two CMKs\n* A per-message AES-GCM key (K) is derived using HKDF from the DEK, a randomly generated message ID, and a fixed algorithm ID.\n* A header is formed from the wrapped DEKs, the encryption context, and other metadata. A header authentication tag is computed on the header using AES-GMAC with K and a zero IV.\n* The message is encrypted using AES-GCM with K, a non-zero IV, and fixed associated additional data. This produces a message authentication tag.\n* The ciphertext consists of the header, the header authentication tag, the encrypted message, and the message authentication tag.\n\n(There\u2019s also a self-signed digital signature that is irrelevant to this discussion).\n\nIn order to decrypt a ciphertext, the AWS Encryption SDKs loops over the list of wrapped DEKs and returns the first one that it can successfully unwrap. The attacker therefore can wrap a unique DEK for each recipient. Next, the attacker exploits the non-committing property of GMAC to produce two messages that have the same GMAC tag under two different keys. The attacker has to do this twice, one for the header authentication tag and one for the message authentication tag.\n\n```\nGiven a data blob B of one 128-bit block B_1, a GMAC tag is computed as follows:\n\nB_1 * H^2 + B_len * H + J\n\nwhere H and J depends on the key and B_len depends on the length of B.\n\nTo find a message that can produce the same tag under two different keys, one\ncan add append to B a new block B_2 whose value can be deduced by solving\nan algebraic equation. That is, we want to find B_2 such that:\n\nB_1 * H^3 + B_2 * H^2 + B_len * H + J = B_1 * H\u2019^3 + B_2 * H\u2019^2 + B_len * H\u2019 + J\u2019\n\nwhere H\u2019 and J\u2019 are the corresponding H and J of the other key.\n\nB_2 is the only unknown value in this equation, thus it can be computed using\nfinite field arithmetics of GF(2^128):\n\nB_2 = [B_1 * (H^3+H\u2019^3) + B_len * (H + H\u2019) + J + J\u2019] * (H^2 + H\u2019^2)^-1.\n```\n**Figure 2: How to find a message that has the same GMAC tag under two different keys.**\n\nThe overall attack works as follows:\n* The attacker generates a random DEK, derives a per-message key K, and encrypts message M with it using AES in counter mode. This generates a ciphertext C.\n* The attacker generates another random DEK\u2019, derives a per-message key K\u2019, and performs trial decryption of C until the decrypted message M\u2019 has desirable properties. For example, if the attacker wants the first bit of M\u2019 different from that of M, this process should only take a few attempts.\n* The attacker finds a block C* such that the GMAC of C\u2019 = C || C* under K and K\u2019 are identical. Denote this tag C\u2019_tag.\n* The attacker wraps DEK and DEK\u2019 under two recipients\u2019 CMK.\n* The attacker forms a header H and adds a block H* to the encryption context such that the new H\u2019 has the same authentication tag H\u2019_tag under K and K\u2019.\n* The attacker output H\u2019, H\u2019_tag, C\u2019, C\u2019_tag.\n\nThis attack is similar to the one discovered in [Facebook Messenger](https://eprint.iacr.org/2019/016.pdf).\n\n# Acknowledgement\n\nI\u2019m grateful to Jen Barnason for carefully editing this advisory. I will never publish anything without her approval! I want to thank my friend and coworker Sophie \u201cQueen of Hashing\u201d Schmieg for wonderful discussions and for showing me how the arithmetic in GF(2^128) works. I want to thank Jonathan Bannet for asking the questions that led to this work.",
                "fixed_in": [
                    "2.0.0"
                ],
                "id": "GHSA-wqgp-vphw-hphf",
                "link": "https://osv.dev/vulnerability/GHSA-wqgp-vphw-hphf",
                "source": "osv",
                "summary": null,
                "withdrawn": null
            },
            {
                "aliases": [],
                "details": "### Impact\n\nThis advisory addresses several LOW severity issues with streaming signed messages and restricting processing of certain types of invalid messages. \n\nThis ESDK supports a streaming mode where callers may stream the plaintext of signed messages before the ECDSA signature is validated. In addition to these signatures, the ESDK uses AES-GCM encryption and all plaintext is verified before being released to a caller. There is no impact on the integrity of the ciphertext or decrypted plaintext, however some callers may rely on the the ECDSA signature for non-repudiation. Without validating the ECDSA signature, an actor with trusted KMS permissions to decrypt a message may also be able to encrypt messages. This update introduces a new API for callers who wish to stream only unsigned messages. \n\nFor customers who process ESDK messages from untrusted sources, this update also introduces a new configuration to limit the number of Encrypted Data Keys (EDKs) that the ESDK will attempt to process per message. This configuration provides customers with a way to limit the number of AWS KMS Decrypt API calls that the ESDK will make per message. This setting will reject messages with more EDKs than the configured limit.\n\nFinally, this update adds early rejection of invalid messages with certain invalid combinations of algorithm suite and header data.\n\n### Patches\n\nFixed in versions 1.9 and 2.2. We recommend that all users upgrade to address these issues.\n\nCustomers leveraging the ESDK\u2019s streaming features have several options to protect signature validation. One is to ensure that client code reads to the end of the stream before using released plaintext. With this release, using the new API for streaming and falling back to the non-streaming decrypt API for signed messages prevents using any plaintext from signed data before the signature is validated. See https://docs.aws.amazon.com/encryption-sdk/latest/developer-guide/about-versions.html#version2.2.x\n\nUsers processing ESDK messages from untrusted sources should use the new maximum encrypted data keys parameter. See https://docs.aws.amazon.com/encryption-sdk/latest/developer-guide/about-versions.html#version2.2.x\n\n### Workarounds\n\nNone\n\n### For more information\n\nhttps://docs.aws.amazon.com/encryption-sdk/latest/developer-guide/concepts.html#digital-sigs\n\nhttps://docs.aws.amazon.com/encryption-sdk/latest/developer-guide/about-versions.html#version2.2.x\n",
                "fixed_in": [
                    "1.9.0",
                    "2.2.0"
                ],
                "id": "GHSA-x5h4-9gqw-942j",
                "link": "https://osv.dev/vulnerability/GHSA-x5h4-9gqw-942j",
                "source": "osv",
                "summary": null,
                "withdrawn": null
            }
        ]
    },
    "1.2.2": {
        "info": {
            "author": "Amazon Web Services",
            "author_email": "",
            "bugtrack_url": null,
            "classifiers": [
                "Development Status :: 5 - Production/Stable",
                "Intended Audience :: Developers",
                "License :: OSI Approved :: Apache Software License",
                "Natural Language :: English",
                "Programming Language :: Python",
                "Programming Language :: Python :: 2",
                "Programming Language :: Python :: 2.7",
                "Programming Language :: Python :: 3",
                "Programming Language :: Python :: 3.4",
                "Programming Language :: Python :: Implementation :: CPython",
                "Topic :: Security",
                "Topic :: Security :: Cryptography"
            ],
            "description_content_type": null,
            "docs_url": null,
            "download_url": "",
            "downloads": {
                "last_day": -1,
                "last_month": -1,
                "last_week": -1
            },
            "home_page": "https://github.com/awslabs/aws-encryption-sdk-python",
            "keywords": "aws-encryption-sdk aws kms encryption",
            "license": "Apache License 2.0",
            "maintainer": "",
            "maintainer_email": "",
            "name": "aws-encryption-sdk",
            "package_url": "https://pypi.org/project/aws-encryption-sdk/",
            "platform": "UNKNOWN",
            "project_url": "https://pypi.org/project/aws-encryption-sdk/",
            "project_urls": {
                "Homepage": "https://github.com/awslabs/aws-encryption-sdk-python"
            },
            "release_url": "https://pypi.org/project/aws-encryption-sdk/1.2.2/",
            "requires_dist": [
                "attrs (==16.3.0)",
                "boto3 (>=1.4.4)",
                "cryptography (>=1.4.0)"
            ],
            "requires_python": "",
            "summary": "AWS Encryption SDK implementation for Python",
            "version": "1.2.2",
            "yanked": false,
            "yanked_reason": null
        },
        "last_serial": 14939260,
        "urls": [
            {
                "comment_text": "",
                "digests": {
                    "md5": "5094493583bdfafe40ce70e677210bc8",
                    "sha256": "a2e757b944a8eb55b853eac3ae75d2b77a4dd91bbf4b90a3bc6918fa5100417e"
                },
                "downloads": -1,
                "filename": "aws_encryption_sdk-1.2.2-py2.py3-none-any.whl",
                "has_sig": false,
                "md5_digest": "5094493583bdfafe40ce70e677210bc8",
                "packagetype": "bdist_wheel",
                "python_version": "py2.py3",
                "requires_python": null,
                "size": 51934,
                "upload_time": "2017-05-23T18:16:48",
                "upload_time_iso_8601": "2017-05-23T18:16:48.022674Z",
                "url": "https://files.pythonhosted.org/packages/73/2b/1dbab89e8cb8f1836f4f8bf6ed63abe847cf949381f212e3b7976417f8e7/aws_encryption_sdk-1.2.2-py2.py3-none-any.whl",
                "yanked": false,
                "yanked_reason": null
            }
        ],
        "vulnerabilities": [
            {
                "aliases": [
                    "CVE-2020-8897"
                ],
                "details": "A weak robustness vulnerability exists in the AWS Encryption SDKs for Java, Python, C and Javalcript prior to versions 2.0.0. Due to the non-committing property of AES-GCM (and other AEAD ciphers such as AES-GCM-SIV or (X)ChaCha20Poly1305) used by the SDKs to encrypt messages, an attacker can craft a unique cyphertext which will decrypt to multiple different results, and becomes especially relevant in a multi-recipient setting. We recommend users update their SDK to 2.0.0 or later.",
                "fixed_in": [
                    "2.0.0"
                ],
                "id": "PYSEC-2020-261",
                "link": "https://osv.dev/vulnerability/PYSEC-2020-261",
                "source": "osv",
                "summary": null,
                "withdrawn": null
            },
            {
                "aliases": [
                    "CVE-2020-8897"
                ],
                "details": "Authors: Thai \"[thaidn](https://twitter.com/xorninja)\" Duong\n\n# Summary\n\nThe following security vulnerabilities was discovered and reported to Amazon, affecting AWS KMS and all versions of [AWS Encryption SDKs](https://docs.aws.amazon.com/encryption-sdk/latest/developer-guide/introduction.html) prior to version 2.0.0:\n\n* **Information leakage**: an attacker can create ciphertexts that would leak the user\u2019s AWS account ID, encryption context, user agent, and IP address upon decryption\n* **Ciphertext forgery**: an attacker can create ciphertexts that are accepted by other users\n* **Robustness**: an attacker can create ciphertexts that decrypt to different plaintexts for different users\n\nThe first two bugs are somewhat surprising because they show that the ciphertext format can lead to vulnerabilities. These bugs (and the infamous [alg: \"None\"](https://auth0.com/blog/critical-vulnerabilities-in-json-web-token-libraries/) bugs in JWT) belong to a class of vulnerabilities called **in-band protocol negotiation**. This is the second time we\u2019ve found in-band protocol negotiation vulnerabilities in AWS cryptography libraries; see this [bug](https://github.com/google/security-research/security/advisories/GHSA-7f33-f4f5-xwgw) in S3 Crypto SDK discovered by my colleague Sophie Schmieg.\n\nIn JWT and S3 SDK the culprit is the algorithm field\u2014here it is the key ID. Because the key ID is used to determine which decryption key to use, it can\u2019t be meaningfully authenticated despite being under the attacker\u2019s control. If the key ID is a URL indicating where to fetch the key, the attacker can replace it with their own URL, and learn side-channel information such as the timing and machines on which the decryption happens (this can also lead to [SSRF](https://portswigger.net/web-security/ssrf) issues, but that\u2019s another topic for another day).\n\nIn AWS, the key ID is a unique [Amazon Resource Name](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html). If an attacker were to capture a ciphertext from a user and replace its key ID with their own, the victim\u2019s AWS account ID, encryption context, user agent, and IP address would be logged to the attacker\u2019s AWS account whenever the victim attempted to decrypt the modified ciphertext.\n\nThe last bug shows that the non-committing property of AES-GCM (and other AEAD ciphers such as [AES-GCM-SIV](https://keymaterial.net/2020/09/07/invisible-salamanders-in-aes-gcm-siv/) or (X)ChaCha20Poly1305) is especially problematic in multi-recipient settings. These ciphers have a property that can cause nonidentical plaintexts when decrypting a single ciphertext with two different keys! For example, you can send a single encrypted email to Alice and Bob which, upon decryption, reads \u201cattack\u201d to Alice and \u201cretreat\u201d to Bob. The AWS Encryption SDKs are vulnerable to this attack because they allow a single ciphertext to be generated for multiple recipients, with each decrypting using a different key. I believe this kind of problem is prevalent. I briefly looked at [JWE](https://tools.ietf.org/html/rfc7516) and I think it is vulnerable.\n\n# Mitigations\n\nAmazon has fixed these bugs in release 2.0.0 of the SDKs. A new major version was required because, unfortunately, the fix for the last bug requires a breaking change from earlier versions. All users are recommended to upgrade. More details about Amazon\u2019s mitigations can be found in [their announcement](https://aws.amazon.com/blogs/security/improved-client-side-encryption-explicit-keyids-and-key-commitment/).\n\nWe\u2019re collaborating with Shay Gueron on a paper regarding fast committing AEADs.\n\n# Vulnerabilities\n\n## Information Leakage\n\nThe [Encrypt](https://docs.aws.amazon.com/kms/latest/APIReference/API_Encrypt.html) API in AWS KMS encrypts plaintext into ciphertext by using a customer master key (CMK). The ciphertext format is undocumented, but it contains metadata that specifies the CMK and the encryption algorithm. I reverse-engineered the format and found the location of the CMK. Externally the CMK is identified by its key ARN, but within a ciphertext it is represented by an internal ID, which remained stable during my testing.\n\nWhen I replaced the internal ID of a CMK in a ciphertext with the internal ID of another CMK, I found that AWS KMS attempted to decrypt the ciphertext with the new CMK. The encryption failed and the failure event\u2014including the AWS Account ID, the user agent and the IP address of the caller\u2014was logged to Cloud Trail in the account that owned the replacement CMK.\n\nThis enables the following attack:\n* The attacker creates a CMK that has a key policy that allows access from everyone. This requires no prior knowledge about the victim.\n* The attacker intercepts a ciphertext from the victim, and replaces its CMK with their CMK.\n* Whenever the victim attempts to decrypt the modified ciphertext, the attacker learns the timing of such actions, the victim\u2019s AWS Account ID, user agent, encryption context, and IP address.\n\nThis attack requires the victim to have an IAM policy that allows them to access the attacker\u2019s CMK. I found that this practice was allowed by the AWS Visual Policy Editor, but I don\u2019t know whether it is common.\n\nThe AWS Encryption SDKs also succumb to this attack. The SDKs implement envelope encryption: encrypting data with a data encryption key (DEK) and then wrapping the DEK with a CMK using the Encrypt API in AWS KMS. The wrapped DEK is stored as part of the final ciphertext (format is defined [here](https://docs.aws.amazon.com/encryption-sdk/latest/developer-guide/message-format.html)). The attacker can mount this attack by replacing the CMK in the wrapped DEK with their own.\n\n```\n{\n    \"eventVersion\": \"1.05\",\n    \"userIdentity\": {\n        \"type\": \"AWSAccount\",\n        \"principalId\": \"<redacted this is the principal ID of the victim>\",\n        \"accountId\": \"<redacted - this is the AWS account ID of the victim>\"\n    },\n    \"eventTime\": \"2020-06-21T21:05:04Z\",\n    \"eventSource\": \"kms.amazonaws.com\",\n    \"eventName\": \"Decrypt\",\n    \"awsRegion\": \"us-west-2\",\n    \"sourceIPAddress\": \"<redacted - this is the IP address of the victim>\",\n    \"userAgent\": \"<redacted - this is the user agent of the victim>\",\n    \"errorCode\": \"InvalidCiphertextException\",\n    \"requestParameters\": {\n        // The encryption context might include other data from the victim\n        \"encryptionContext\": {\n            \"aws-crypto-public-key\": \"AzfNOGOnNYFmpHspKrAm1L6XtRybONkmkhmB/IriKSA7b2NsV4MEPMph9yX2KTPKWw==\"\n        },\n        \"encryptionAlgorithm\": \"SYMMETRIC_DEFAULT\"\n    },\n    \"responseElements\": null,\n    \"requestID\": \"aeced8e8-75a2-42c3-96ac-d1fa2a1c5ee6\",\n    \"eventID\": \"780a0a6e-4ad8-43d4-a426-75d05022f870\",\n    \"readOnly\": true,\n    \"resources\": [\n        {\n            \"accountId\": \"<redacted - this is the account ID of the attacker>\",\n            \"type\": \"AWS::KMS::Key\",\n            \"ARN\": <redacted - this is the key ARN of the attacker>\n        }\n    ],\n    \"eventType\": \"AwsApiCall\",\n    \"recipientAccountId\": \"<redacted - this is the account ID of the attacker>\",\n    \"sharedEventID\": \"033e147c-8a36-42f5-9d6c-9e071eb752b7\"\n}\n```\n**Figure 1: A failure event logged to the attacker\u2019s Cloud Trail when the victim attempted to decrypt a modified ciphertext containing the attacker\u2019s CMK.**\n\n## Ciphertext Forgery\n\nThe [Decrypt](https://docs.aws.amazon.com/kms/latest/APIReference/API_Decrypt.html) API in AWS KMS doesn\u2019t require the caller to specify the CMK. This parameter is required only when the ciphertext was encrypted under an asymmetric CMK. Otherwise, AWS KMS uses the metadata that it adds to the ciphertext blob to determine which CMK was used to encrypt the ciphertext.\n\nThis leads to the following attack:\n* The attacker creates a CMK that has a key policy that allows access from everyone. This requires no prior knowledge about the victim.\n* The attacker generates a ciphertext by calling the Encrypt API with their key.\n* The attacker intercepts a ciphertext from the victim, and replaces it entirely with their ciphertext.\n* The victim successfully decrypts the ciphertext, as if it was encrypted under their own key. The attacker also learns when this happened, the victim\u2019s AWS Account ID, user agent, encryption context, and IP address.\n\nSimilar to the information leakage attack, this attack also requires the victim to have an IAM policy that allows them to access the attacker\u2019s CMK.\n\nThe AWS Encryption SDKs also succumb to this attack. They don\u2019t specify the CMK when they call the Decrypt API to unwrap the DEK.\n\n## Robustness\n\nThe AWS Encryption SDKs allow a single ciphertext to be generated for multiple recipients, with each decrypting using a different key. To that end, it wraps the DEK multiple times, each under a different CMK. The wrapped DEKs can be combined to form a single ciphertext which can be sent to multiple recipients who can use their own credentials to decrypt it. It\u2019s reasonable to expect that all recipients should decrypt the ciphertext to an identical plaintext. However, because of the use of AES-GMAC and AES-GCM, it\u2019s possible to create a ciphertext that decrypts to two valid yet different plaintexts for two different users. In other words, the AWS Encryption SDKs are [not](https://eprint.iacr.org/2008/440.pdf) [robust](https://eprint.iacr.org/2019/016.pdf).\n\nThe encryption of a message under two CMKs can be summarized as follows:\n* A DEK is randomly generated, and two wrapped DEKs are produced by calling the Encrypt API using the two CMKs\n* A per-message AES-GCM key (K) is derived using HKDF from the DEK, a randomly generated message ID, and a fixed algorithm ID.\n* A header is formed from the wrapped DEKs, the encryption context, and other metadata. A header authentication tag is computed on the header using AES-GMAC with K and a zero IV.\n* The message is encrypted using AES-GCM with K, a non-zero IV, and fixed associated additional data. This produces a message authentication tag.\n* The ciphertext consists of the header, the header authentication tag, the encrypted message, and the message authentication tag.\n\n(There\u2019s also a self-signed digital signature that is irrelevant to this discussion).\n\nIn order to decrypt a ciphertext, the AWS Encryption SDKs loops over the list of wrapped DEKs and returns the first one that it can successfully unwrap. The attacker therefore can wrap a unique DEK for each recipient. Next, the attacker exploits the non-committing property of GMAC to produce two messages that have the same GMAC tag under two different keys. The attacker has to do this twice, one for the header authentication tag and one for the message authentication tag.\n\n```\nGiven a data blob B of one 128-bit block B_1, a GMAC tag is computed as follows:\n\nB_1 * H^2 + B_len * H + J\n\nwhere H and J depends on the key and B_len depends on the length of B.\n\nTo find a message that can produce the same tag under two different keys, one\ncan add append to B a new block B_2 whose value can be deduced by solving\nan algebraic equation. That is, we want to find B_2 such that:\n\nB_1 * H^3 + B_2 * H^2 + B_len * H + J = B_1 * H\u2019^3 + B_2 * H\u2019^2 + B_len * H\u2019 + J\u2019\n\nwhere H\u2019 and J\u2019 are the corresponding H and J of the other key.\n\nB_2 is the only unknown value in this equation, thus it can be computed using\nfinite field arithmetics of GF(2^128):\n\nB_2 = [B_1 * (H^3+H\u2019^3) + B_len * (H + H\u2019) + J + J\u2019] * (H^2 + H\u2019^2)^-1.\n```\n**Figure 2: How to find a message that has the same GMAC tag under two different keys.**\n\nThe overall attack works as follows:\n* The attacker generates a random DEK, derives a per-message key K, and encrypts message M with it using AES in counter mode. This generates a ciphertext C.\n* The attacker generates another random DEK\u2019, derives a per-message key K\u2019, and performs trial decryption of C until the decrypted message M\u2019 has desirable properties. For example, if the attacker wants the first bit of M\u2019 different from that of M, this process should only take a few attempts.\n* The attacker finds a block C* such that the GMAC of C\u2019 = C || C* under K and K\u2019 are identical. Denote this tag C\u2019_tag.\n* The attacker wraps DEK and DEK\u2019 under two recipients\u2019 CMK.\n* The attacker forms a header H and adds a block H* to the encryption context such that the new H\u2019 has the same authentication tag H\u2019_tag under K and K\u2019.\n* The attacker output H\u2019, H\u2019_tag, C\u2019, C\u2019_tag.\n\nThis attack is similar to the one discovered in [Facebook Messenger](https://eprint.iacr.org/2019/016.pdf).\n\n# Acknowledgement\n\nI\u2019m grateful to Jen Barnason for carefully editing this advisory. I will never publish anything without her approval! I want to thank my friend and coworker Sophie \u201cQueen of Hashing\u201d Schmieg for wonderful discussions and for showing me how the arithmetic in GF(2^128) works. I want to thank Jonathan Bannet for asking the questions that led to this work.",
                "fixed_in": [
                    "2.0.0"
                ],
                "id": "GHSA-wqgp-vphw-hphf",
                "link": "https://osv.dev/vulnerability/GHSA-wqgp-vphw-hphf",
                "source": "osv",
                "summary": null,
                "withdrawn": null
            },
            {
                "aliases": [],
                "details": "### Impact\n\nThis advisory addresses several LOW severity issues with streaming signed messages and restricting processing of certain types of invalid messages. \n\nThis ESDK supports a streaming mode where callers may stream the plaintext of signed messages before the ECDSA signature is validated. In addition to these signatures, the ESDK uses AES-GCM encryption and all plaintext is verified before being released to a caller. There is no impact on the integrity of the ciphertext or decrypted plaintext, however some callers may rely on the the ECDSA signature for non-repudiation. Without validating the ECDSA signature, an actor with trusted KMS permissions to decrypt a message may also be able to encrypt messages. This update introduces a new API for callers who wish to stream only unsigned messages. \n\nFor customers who process ESDK messages from untrusted sources, this update also introduces a new configuration to limit the number of Encrypted Data Keys (EDKs) that the ESDK will attempt to process per message. This configuration provides customers with a way to limit the number of AWS KMS Decrypt API calls that the ESDK will make per message. This setting will reject messages with more EDKs than the configured limit.\n\nFinally, this update adds early rejection of invalid messages with certain invalid combinations of algorithm suite and header data.\n\n### Patches\n\nFixed in versions 1.9 and 2.2. We recommend that all users upgrade to address these issues.\n\nCustomers leveraging the ESDK\u2019s streaming features have several options to protect signature validation. One is to ensure that client code reads to the end of the stream before using released plaintext. With this release, using the new API for streaming and falling back to the non-streaming decrypt API for signed messages prevents using any plaintext from signed data before the signature is validated. See https://docs.aws.amazon.com/encryption-sdk/latest/developer-guide/about-versions.html#version2.2.x\n\nUsers processing ESDK messages from untrusted sources should use the new maximum encrypted data keys parameter. See https://docs.aws.amazon.com/encryption-sdk/latest/developer-guide/about-versions.html#version2.2.x\n\n### Workarounds\n\nNone\n\n### For more information\n\nhttps://docs.aws.amazon.com/encryption-sdk/latest/developer-guide/concepts.html#digital-sigs\n\nhttps://docs.aws.amazon.com/encryption-sdk/latest/developer-guide/about-versions.html#version2.2.x\n",
                "fixed_in": [
                    "1.9.0",
                    "2.2.0"
                ],
                "id": "GHSA-x5h4-9gqw-942j",
                "link": "https://osv.dev/vulnerability/GHSA-x5h4-9gqw-942j",
                "source": "osv",
                "summary": null,
                "withdrawn": null
            }
        ]
    },
    "1.3.0": {
        "info": {
            "author": "Amazon Web Services",
            "author_email": "",
            "bugtrack_url": null,
            "classifiers": [
                "Development Status :: 5 - Production/Stable",
                "Intended Audience :: Developers",
                "License :: OSI Approved :: Apache Software License",
                "Natural Language :: English",
                "Programming Language :: Python",
                "Programming Language :: Python :: 2",
                "Programming Language :: Python :: 2.7",
                "Programming Language :: Python :: 3",
                "Programming Language :: Python :: 3.4",
                "Programming Language :: Python :: Implementation :: CPython",
                "Topic :: Security",
                "Topic :: Security :: Cryptography"
            ],
            "description_content_type": null,
            "docs_url": null,
            "download_url": "",
            "downloads": {
                "last_day": -1,
                "last_month": -1,
                "last_week": -1
            },
            "home_page": "https://github.com/awslabs/aws-encryption-sdk-python",
            "keywords": "aws-encryption-sdk aws kms encryption",
            "license": "Apache License 2.0",
            "maintainer": "",
            "maintainer_email": "",
            "name": "aws-encryption-sdk",
            "package_url": "https://pypi.org/project/aws-encryption-sdk/",
            "platform": "",
            "project_url": "https://pypi.org/project/aws-encryption-sdk/",
            "project_urls": {
                "Homepage": "https://github.com/awslabs/aws-encryption-sdk-python"
            },
            "release_url": "https://pypi.org/project/aws-encryption-sdk/1.3.0/",
            "requires_dist": [
                "attrs (>=16.3.0)",
                "boto3 (>=1.4.4)",
                "cryptography (>=1.8.1)"
            ],
            "requires_python": "",
            "summary": "AWS Encryption SDK implementation for Python",
            "version": "1.3.0",
            "yanked": false,
            "yanked_reason": null
        },
        "last_serial": 14939260,
        "urls": [
            {
                "comment_text": "",
                "digests": {
                    "md5": "dd3b09ce65e2e3924e793b667f98c0c2",
                    "sha256": "66000d80c4513130a078371115623d31782c5dd1dce0062244f3e587c8e48946"
                },
                "downloads": -1,
                "filename": "aws_encryption_sdk-1.3.0-py2.py3-none-any.whl",
                "has_sig": false,
                "md5_digest": "dd3b09ce65e2e3924e793b667f98c0c2",
                "packagetype": "bdist_wheel",
                "python_version": "py2.py3",
                "requires_python": null,
                "size": 68760,
                "upload_time": "2017-08-04T21:21:02",
                "upload_time_iso_8601": "2017-08-04T21:21:02.597558Z",
                "url": "https://files.pythonhosted.org/packages/25/39/bbd8a8b1c59d476733855ac4efbddaf849a868d4699da5827d1f50504e52/aws_encryption_sdk-1.3.0-py2.py3-none-any.whl",
                "yanked": false,
                "yanked_reason": null
            }
        ],
        "vulnerabilities": [
            {
                "aliases": [
                    "CVE-2020-8897"
                ],
                "details": "A weak robustness vulnerability exists in the AWS Encryption SDKs for Java, Python, C and Javalcript prior to versions 2.0.0. Due to the non-committing property of AES-GCM (and other AEAD ciphers such as AES-GCM-SIV or (X)ChaCha20Poly1305) used by the SDKs to encrypt messages, an attacker can craft a unique cyphertext which will decrypt to multiple different results, and becomes especially relevant in a multi-recipient setting. We recommend users update their SDK to 2.0.0 or later.",
                "fixed_in": [
                    "2.0.0"
                ],
                "id": "PYSEC-2020-261",
                "link": "https://osv.dev/vulnerability/PYSEC-2020-261",
                "source": "osv",
                "summary": null,
                "withdrawn": null
            },
            {
                "aliases": [
                    "CVE-2020-8897"
                ],
                "details": "Authors: Thai \"[thaidn](https://twitter.com/xorninja)\" Duong\n\n# Summary\n\nThe following security vulnerabilities was discovered and reported to Amazon, affecting AWS KMS and all versions of [AWS Encryption SDKs](https://docs.aws.amazon.com/encryption-sdk/latest/developer-guide/introduction.html) prior to version 2.0.0:\n\n* **Information leakage**: an attacker can create ciphertexts that would leak the user\u2019s AWS account ID, encryption context, user agent, and IP address upon decryption\n* **Ciphertext forgery**: an attacker can create ciphertexts that are accepted by other users\n* **Robustness**: an attacker can create ciphertexts that decrypt to different plaintexts for different users\n\nThe first two bugs are somewhat surprising because they show that the ciphertext format can lead to vulnerabilities. These bugs (and the infamous [alg: \"None\"](https://auth0.com/blog/critical-vulnerabilities-in-json-web-token-libraries/) bugs in JWT) belong to a class of vulnerabilities called **in-band protocol negotiation**. This is the second time we\u2019ve found in-band protocol negotiation vulnerabilities in AWS cryptography libraries; see this [bug](https://github.com/google/security-research/security/advisories/GHSA-7f33-f4f5-xwgw) in S3 Crypto SDK discovered by my colleague Sophie Schmieg.\n\nIn JWT and S3 SDK the culprit is the algorithm field\u2014here it is the key ID. Because the key ID is used to determine which decryption key to use, it can\u2019t be meaningfully authenticated despite being under the attacker\u2019s control. If the key ID is a URL indicating where to fetch the key, the attacker can replace it with their own URL, and learn side-channel information such as the timing and machines on which the decryption happens (this can also lead to [SSRF](https://portswigger.net/web-security/ssrf) issues, but that\u2019s another topic for another day).\n\nIn AWS, the key ID is a unique [Amazon Resource Name](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html). If an attacker were to capture a ciphertext from a user and replace its key ID with their own, the victim\u2019s AWS account ID, encryption context, user agent, and IP address would be logged to the attacker\u2019s AWS account whenever the victim attempted to decrypt the modified ciphertext.\n\nThe last bug shows that the non-committing property of AES-GCM (and other AEAD ciphers such as [AES-GCM-SIV](https://keymaterial.net/2020/09/07/invisible-salamanders-in-aes-gcm-siv/) or (X)ChaCha20Poly1305) is especially problematic in multi-recipient settings. These ciphers have a property that can cause nonidentical plaintexts when decrypting a single ciphertext with two different keys! For example, you can send a single encrypted email to Alice and Bob which, upon decryption, reads \u201cattack\u201d to Alice and \u201cretreat\u201d to Bob. The AWS Encryption SDKs are vulnerable to this attack because they allow a single ciphertext to be generated for multiple recipients, with each decrypting using a different key. I believe this kind of problem is prevalent. I briefly looked at [JWE](https://tools.ietf.org/html/rfc7516) and I think it is vulnerable.\n\n# Mitigations\n\nAmazon has fixed these bugs in release 2.0.0 of the SDKs. A new major version was required because, unfortunately, the fix for the last bug requires a breaking change from earlier versions. All users are recommended to upgrade. More details about Amazon\u2019s mitigations can be found in [their announcement](https://aws.amazon.com/blogs/security/improved-client-side-encryption-explicit-keyids-and-key-commitment/).\n\nWe\u2019re collaborating with Shay Gueron on a paper regarding fast committing AEADs.\n\n# Vulnerabilities\n\n## Information Leakage\n\nThe [Encrypt](https://docs.aws.amazon.com/kms/latest/APIReference/API_Encrypt.html) API in AWS KMS encrypts plaintext into ciphertext by using a customer master key (CMK). The ciphertext format is undocumented, but it contains metadata that specifies the CMK and the encryption algorithm. I reverse-engineered the format and found the location of the CMK. Externally the CMK is identified by its key ARN, but within a ciphertext it is represented by an internal ID, which remained stable during my testing.\n\nWhen I replaced the internal ID of a CMK in a ciphertext with the internal ID of another CMK, I found that AWS KMS attempted to decrypt the ciphertext with the new CMK. The encryption failed and the failure event\u2014including the AWS Account ID, the user agent and the IP address of the caller\u2014was logged to Cloud Trail in the account that owned the replacement CMK.\n\nThis enables the following attack:\n* The attacker creates a CMK that has a key policy that allows access from everyone. This requires no prior knowledge about the victim.\n* The attacker intercepts a ciphertext from the victim, and replaces its CMK with their CMK.\n* Whenever the victim attempts to decrypt the modified ciphertext, the attacker learns the timing of such actions, the victim\u2019s AWS Account ID, user agent, encryption context, and IP address.\n\nThis attack requires the victim to have an IAM policy that allows them to access the attacker\u2019s CMK. I found that this practice was allowed by the AWS Visual Policy Editor, but I don\u2019t know whether it is common.\n\nThe AWS Encryption SDKs also succumb to this attack. The SDKs implement envelope encryption: encrypting data with a data encryption key (DEK) and then wrapping the DEK with a CMK using the Encrypt API in AWS KMS. The wrapped DEK is stored as part of the final ciphertext (format is defined [here](https://docs.aws.amazon.com/encryption-sdk/latest/developer-guide/message-format.html)). The attacker can mount this attack by replacing the CMK in the wrapped DEK with their own.\n\n```\n{\n    \"eventVersion\": \"1.05\",\n    \"userIdentity\": {\n        \"type\": \"AWSAccount\",\n        \"principalId\": \"<redacted this is the principal ID of the victim>\",\n        \"accountId\": \"<redacted - this is the AWS account ID of the victim>\"\n    },\n    \"eventTime\": \"2020-06-21T21:05:04Z\",\n    \"eventSource\": \"kms.amazonaws.com\",\n    \"eventName\": \"Decrypt\",\n    \"awsRegion\": \"us-west-2\",\n    \"sourceIPAddress\": \"<redacted - this is the IP address of the victim>\",\n    \"userAgent\": \"<redacted - this is the user agent of the victim>\",\n    \"errorCode\": \"InvalidCiphertextException\",\n    \"requestParameters\": {\n        // The encryption context might include other data from the victim\n        \"encryptionContext\": {\n            \"aws-crypto-public-key\": \"AzfNOGOnNYFmpHspKrAm1L6XtRybONkmkhmB/IriKSA7b2NsV4MEPMph9yX2KTPKWw==\"\n        },\n        \"encryptionAlgorithm\": \"SYMMETRIC_DEFAULT\"\n    },\n    \"responseElements\": null,\n    \"requestID\": \"aeced8e8-75a2-42c3-96ac-d1fa2a1c5ee6\",\n    \"eventID\": \"780a0a6e-4ad8-43d4-a426-75d05022f870\",\n    \"readOnly\": true,\n    \"resources\": [\n        {\n            \"accountId\": \"<redacted - this is the account ID of the attacker>\",\n            \"type\": \"AWS::KMS::Key\",\n            \"ARN\": <redacted - this is the key ARN of the attacker>\n        }\n    ],\n    \"eventType\": \"AwsApiCall\",\n    \"recipientAccountId\": \"<redacted - this is the account ID of the attacker>\",\n    \"sharedEventID\": \"033e147c-8a36-42f5-9d6c-9e071eb752b7\"\n}\n```\n**Figure 1: A failure event logged to the attacker\u2019s Cloud Trail when the victim attempted to decrypt a modified ciphertext containing the attacker\u2019s CMK.**\n\n## Ciphertext Forgery\n\nThe [Decrypt](https://docs.aws.amazon.com/kms/latest/APIReference/API_Decrypt.html) API in AWS KMS doesn\u2019t require the caller to specify the CMK. This parameter is required only when the ciphertext was encrypted under an asymmetric CMK. Otherwise, AWS KMS uses the metadata that it adds to the ciphertext blob to determine which CMK was used to encrypt the ciphertext.\n\nThis leads to the following attack:\n* The attacker creates a CMK that has a key policy that allows access from everyone. This requires no prior knowledge about the victim.\n* The attacker generates a ciphertext by calling the Encrypt API with their key.\n* The attacker intercepts a ciphertext from the victim, and replaces it entirely with their ciphertext.\n* The victim successfully decrypts the ciphertext, as if it was encrypted under their own key. The attacker also learns when this happened, the victim\u2019s AWS Account ID, user agent, encryption context, and IP address.\n\nSimilar to the information leakage attack, this attack also requires the victim to have an IAM policy that allows them to access the attacker\u2019s CMK.\n\nThe AWS Encryption SDKs also succumb to this attack. They don\u2019t specify the CMK when they call the Decrypt API to unwrap the DEK.\n\n## Robustness\n\nThe AWS Encryption SDKs allow a single ciphertext to be generated for multiple recipients, with each decrypting using a different key. To that end, it wraps the DEK multiple times, each under a different CMK. The wrapped DEKs can be combined to form a single ciphertext which can be sent to multiple recipients who can use their own credentials to decrypt it. It\u2019s reasonable to expect that all recipients should decrypt the ciphertext to an identical plaintext. However, because of the use of AES-GMAC and AES-GCM, it\u2019s possible to create a ciphertext that decrypts to two valid yet different plaintexts for two different users. In other words, the AWS Encryption SDKs are [not](https://eprint.iacr.org/2008/440.pdf) [robust](https://eprint.iacr.org/2019/016.pdf).\n\nThe encryption of a message under two CMKs can be summarized as follows:\n* A DEK is randomly generated, and two wrapped DEKs are produced by calling the Encrypt API using the two CMKs\n* A per-message AES-GCM key (K) is derived using HKDF from the DEK, a randomly generated message ID, and a fixed algorithm ID.\n* A header is formed from the wrapped DEKs, the encryption context, and other metadata. A header authentication tag is computed on the header using AES-GMAC with K and a zero IV.\n* The message is encrypted using AES-GCM with K, a non-zero IV, and fixed associated additional data. This produces a message authentication tag.\n* The ciphertext consists of the header, the header authentication tag, the encrypted message, and the message authentication tag.\n\n(There\u2019s also a self-signed digital signature that is irrelevant to this discussion).\n\nIn order to decrypt a ciphertext, the AWS Encryption SDKs loops over the list of wrapped DEKs and returns the first one that it can successfully unwrap. The attacker therefore can wrap a unique DEK for each recipient. Next, the attacker exploits the non-committing property of GMAC to produce two messages that have the same GMAC tag under two different keys. The attacker has to do this twice, one for the header authentication tag and one for the message authentication tag.\n\n```\nGiven a data blob B of one 128-bit block B_1, a GMAC tag is computed as follows:\n\nB_1 * H^2 + B_len * H + J\n\nwhere H and J depends on the key and B_len depends on the length of B.\n\nTo find a message that can produce the same tag under two different keys, one\ncan add append to B a new block B_2 whose value can be deduced by solving\nan algebraic equation. That is, we want to find B_2 such that:\n\nB_1 * H^3 + B_2 * H^2 + B_len * H + J = B_1 * H\u2019^3 + B_2 * H\u2019^2 + B_len * H\u2019 + J\u2019\n\nwhere H\u2019 and J\u2019 are the corresponding H and J of the other key.\n\nB_2 is the only unknown value in this equation, thus it can be computed using\nfinite field arithmetics of GF(2^128):\n\nB_2 = [B_1 * (H^3+H\u2019^3) + B_len * (H + H\u2019) + J + J\u2019] * (H^2 + H\u2019^2)^-1.\n```\n**Figure 2: How to find a message that has the same GMAC tag under two different keys.**\n\nThe overall attack works as follows:\n* The attacker generates a random DEK, derives a per-message key K, and encrypts message M with it using AES in counter mode. This generates a ciphertext C.\n* The attacker generates another random DEK\u2019, derives a per-message key K\u2019, and performs trial decryption of C until the decrypted message M\u2019 has desirable properties. For example, if the attacker wants the first bit of M\u2019 different from that of M, this process should only take a few attempts.\n* The attacker finds a block C* such that the GMAC of C\u2019 = C || C* under K and K\u2019 are identical. Denote this tag C\u2019_tag.\n* The attacker wraps DEK and DEK\u2019 under two recipients\u2019 CMK.\n* The attacker forms a header H and adds a block H* to the encryption context such that the new H\u2019 has the same authentication tag H\u2019_tag under K and K\u2019.\n* The attacker output H\u2019, H\u2019_tag, C\u2019, C\u2019_tag.\n\nThis attack is similar to the one discovered in [Facebook Messenger](https://eprint.iacr.org/2019/016.pdf).\n\n# Acknowledgement\n\nI\u2019m grateful to Jen Barnason for carefully editing this advisory. I will never publish anything without her approval! I want to thank my friend and coworker Sophie \u201cQueen of Hashing\u201d Schmieg for wonderful discussions and for showing me how the arithmetic in GF(2^128) works. I want to thank Jonathan Bannet for asking the questions that led to this work.",
                "fixed_in": [
                    "2.0.0"
                ],
                "id": "GHSA-wqgp-vphw-hphf",
                "link": "https://osv.dev/vulnerability/GHSA-wqgp-vphw-hphf",
                "source": "osv",
                "summary": null,
                "withdrawn": null
            },
            {
                "aliases": [],
                "details": "### Impact\n\nThis advisory addresses several LOW severity issues with streaming signed messages and restricting processing of certain types of invalid messages. \n\nThis ESDK supports a streaming mode where callers may stream the plaintext of signed messages before the ECDSA signature is validated. In addition to these signatures, the ESDK uses AES-GCM encryption and all plaintext is verified before being released to a caller. There is no impact on the integrity of the ciphertext or decrypted plaintext, however some callers may rely on the the ECDSA signature for non-repudiation. Without validating the ECDSA signature, an actor with trusted KMS permissions to decrypt a message may also be able to encrypt messages. This update introduces a new API for callers who wish to stream only unsigned messages. \n\nFor customers who process ESDK messages from untrusted sources, this update also introduces a new configuration to limit the number of Encrypted Data Keys (EDKs) that the ESDK will attempt to process per message. This configuration provides customers with a way to limit the number of AWS KMS Decrypt API calls that the ESDK will make per message. This setting will reject messages with more EDKs than the configured limit.\n\nFinally, this update adds early rejection of invalid messages with certain invalid combinations of algorithm suite and header data.\n\n### Patches\n\nFixed in versions 1.9 and 2.2. We recommend that all users upgrade to address these issues.\n\nCustomers leveraging the ESDK\u2019s streaming features have several options to protect signature validation. One is to ensure that client code reads to the end of the stream before using released plaintext. With this release, using the new API for streaming and falling back to the non-streaming decrypt API for signed messages prevents using any plaintext from signed data before the signature is validated. See https://docs.aws.amazon.com/encryption-sdk/latest/developer-guide/about-versions.html#version2.2.x\n\nUsers processing ESDK messages from untrusted sources should use the new maximum encrypted data keys parameter. See https://docs.aws.amazon.com/encryption-sdk/latest/developer-guide/about-versions.html#version2.2.x\n\n### Workarounds\n\nNone\n\n### For more information\n\nhttps://docs.aws.amazon.com/encryption-sdk/latest/developer-guide/concepts.html#digital-sigs\n\nhttps://docs.aws.amazon.com/encryption-sdk/latest/developer-guide/about-versions.html#version2.2.x\n",
                "fixed_in": [
                    "1.9.0",
                    "2.2.0"
                ],
                "id": "GHSA-x5h4-9gqw-942j",
                "link": "https://osv.dev/vulnerability/GHSA-x5h4-9gqw-942j",
                "source": "osv",
                "summary": null,
                "withdrawn": null
            }
        ]
    },
    "1.3.1": {
        "info": {
            "author": "Amazon Web Services",
            "author_email": "aws-cryptools@amazon.com",
            "bugtrack_url": null,
            "classifiers": [
                "Development Status :: 5 - Production/Stable",
                "Intended Audience :: Developers",
                "License :: OSI Approved :: Apache Software License",
                "Natural Language :: English",
                "Programming Language :: Python",
                "Programming Language :: Python :: 2",
                "Programming Language :: Python :: 2.7",
                "Programming Language :: Python :: 3",
                "Programming Language :: Python :: 3.4",
                "Programming Language :: Python :: Implementation :: CPython",
                "Topic :: Security",
                "Topic :: Security :: Cryptography"
            ],
            "description_content_type": null,
            "docs_url": null,
            "download_url": "",
            "downloads": {
                "last_day": -1,
                "last_month": -1,
                "last_week": -1
            },
            "home_page": "https://github.com/awslabs/aws-encryption-sdk-python",
            "keywords": "aws-encryption-sdk aws kms encryption",
            "license": "Apache License 2.0",
            "maintainer": "",
            "maintainer_email": "",
            "name": "aws-encryption-sdk",
            "package_url": "https://pypi.org/project/aws-encryption-sdk/",
            "platform": "",
            "project_url": "https://pypi.org/project/aws-encryption-sdk/",
            "project_urls": {
                "Homepage": "https://github.com/awslabs/aws-encryption-sdk-python"
            },
            "release_url": "https://pypi.org/project/aws-encryption-sdk/1.3.1/",
            "requires_dist": [
                "boto3 (>=1.4.4)",
                "cryptography (>=1.8.1)",
                "attrs (>=16.3.0)"
            ],
            "requires_python": "",
            "summary": "AWS Encryption SDK implementation for Python",
            "version": "1.3.1",
            "yanked": false,
            "yanked_reason": null
        },
        "last_serial": 14939260,
        "urls": [
            {
                "comment_text": "",
                "digests": {
                    "md5": "306288d4807ca212ad7da445285acf1a",
                    "sha256": "65ecb6ae8c6067f9ea7819e10dd3aa27d23616e053eae51d133b147ce829ae47"
                },
                "downloads": -1,
                "filename": "aws_encryption_sdk-1.3.1-py2.py3-none-any.whl",
                "has_sig": false,
                "md5_digest": "306288d4807ca212ad7da445285acf1a",
                "packagetype": "bdist_wheel",
                "python_version": "py2.py3",
                "requires_python": null,
                "size": 82804,
                "upload_time": "2017-09-12T23:27:36",
                "upload_time_iso_8601": "2017-09-12T23:27:36.459419Z",
                "url": "https://files.pythonhosted.org/packages/f6/a0/dfd5269392626b42c3c78127afe924972f360a1d53794fc6669fadc6b82a/aws_encryption_sdk-1.3.1-py2.py3-none-any.whl",
                "yanked": false,
                "yanked_reason": null
            }
        ],
        "vulnerabilities": [
            {
                "aliases": [
                    "CVE-2020-8897"
                ],
                "details": "A weak robustness vulnerability exists in the AWS Encryption SDKs for Java, Python, C and Javalcript prior to versions 2.0.0. Due to the non-committing property of AES-GCM (and other AEAD ciphers such as AES-GCM-SIV or (X)ChaCha20Poly1305) used by the SDKs to encrypt messages, an attacker can craft a unique cyphertext which will decrypt to multiple different results, and becomes especially relevant in a multi-recipient setting. We recommend users update their SDK to 2.0.0 or later.",
                "fixed_in": [
                    "2.0.0"
                ],
                "id": "PYSEC-2020-261",
                "link": "https://osv.dev/vulnerability/PYSEC-2020-261",
                "source": "osv",
                "summary": null,
                "withdrawn": null
            },
            {
                "aliases": [
                    "CVE-2020-8897"
                ],
                "details": "Authors: Thai \"[thaidn](https://twitter.com/xorninja)\" Duong\n\n# Summary\n\nThe following security vulnerabilities was discovered and reported to Amazon, affecting AWS KMS and all versions of [AWS Encryption SDKs](https://docs.aws.amazon.com/encryption-sdk/latest/developer-guide/introduction.html) prior to version 2.0.0:\n\n* **Information leakage**: an attacker can create ciphertexts that would leak the user\u2019s AWS account ID, encryption context, user agent, and IP address upon decryption\n* **Ciphertext forgery**: an attacker can create ciphertexts that are accepted by other users\n* **Robustness**: an attacker can create ciphertexts that decrypt to different plaintexts for different users\n\nThe first two bugs are somewhat surprising because they show that the ciphertext format can lead to vulnerabilities. These bugs (and the infamous [alg: \"None\"](https://auth0.com/blog/critical-vulnerabilities-in-json-web-token-libraries/) bugs in JWT) belong to a class of vulnerabilities called **in-band protocol negotiation**. This is the second time we\u2019ve found in-band protocol negotiation vulnerabilities in AWS cryptography libraries; see this [bug](https://github.com/google/security-research/security/advisories/GHSA-7f33-f4f5-xwgw) in S3 Crypto SDK discovered by my colleague Sophie Schmieg.\n\nIn JWT and S3 SDK the culprit is the algorithm field\u2014here it is the key ID. Because the key ID is used to determine which decryption key to use, it can\u2019t be meaningfully authenticated despite being under the attacker\u2019s control. If the key ID is a URL indicating where to fetch the key, the attacker can replace it with their own URL, and learn side-channel information such as the timing and machines on which the decryption happens (this can also lead to [SSRF](https://portswigger.net/web-security/ssrf) issues, but that\u2019s another topic for another day).\n\nIn AWS, the key ID is a unique [Amazon Resource Name](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html). If an attacker were to capture a ciphertext from a user and replace its key ID with their own, the victim\u2019s AWS account ID, encryption context, user agent, and IP address would be logged to the attacker\u2019s AWS account whenever the victim attempted to decrypt the modified ciphertext.\n\nThe last bug shows that the non-committing property of AES-GCM (and other AEAD ciphers such as [AES-GCM-SIV](https://keymaterial.net/2020/09/07/invisible-salamanders-in-aes-gcm-siv/) or (X)ChaCha20Poly1305) is especially problematic in multi-recipient settings. These ciphers have a property that can cause nonidentical plaintexts when decrypting a single ciphertext with two different keys! For example, you can send a single encrypted email to Alice and Bob which, upon decryption, reads \u201cattack\u201d to Alice and \u201cretreat\u201d to Bob. The AWS Encryption SDKs are vulnerable to this attack because they allow a single ciphertext to be generated for multiple recipients, with each decrypting using a different key. I believe this kind of problem is prevalent. I briefly looked at [JWE](https://tools.ietf.org/html/rfc7516) and I think it is vulnerable.\n\n# Mitigations\n\nAmazon has fixed these bugs in release 2.0.0 of the SDKs. A new major version was required because, unfortunately, the fix for the last bug requires a breaking change from earlier versions. All users are recommended to upgrade. More details about Amazon\u2019s mitigations can be found in [their announcement](https://aws.amazon.com/blogs/security/improved-client-side-encryption-explicit-keyids-and-key-commitment/).\n\nWe\u2019re collaborating with Shay Gueron on a paper regarding fast committing AEADs.\n\n# Vulnerabilities\n\n## Information Leakage\n\nThe [Encrypt](https://docs.aws.amazon.com/kms/latest/APIReference/API_Encrypt.html) API in AWS KMS encrypts plaintext into ciphertext by using a customer master key (CMK). The ciphertext format is undocumented, but it contains metadata that specifies the CMK and the encryption algorithm. I reverse-engineered the format and found the location of the CMK. Externally the CMK is identified by its key ARN, but within a ciphertext it is represented by an internal ID, which remained stable during my testing.\n\nWhen I replaced the internal ID of a CMK in a ciphertext with the internal ID of another CMK, I found that AWS KMS attempted to decrypt the ciphertext with the new CMK. The encryption failed and the failure event\u2014including the AWS Account ID, the user agent and the IP address of the caller\u2014was logged to Cloud Trail in the account that owned the replacement CMK.\n\nThis enables the following attack:\n* The attacker creates a CMK that has a key policy that allows access from everyone. This requires no prior knowledge about the victim.\n* The attacker intercepts a ciphertext from the victim, and replaces its CMK with their CMK.\n* Whenever the victim attempts to decrypt the modified ciphertext, the attacker learns the timing of such actions, the victim\u2019s AWS Account ID, user agent, encryption context, and IP address.\n\nThis attack requires the victim to have an IAM policy that allows them to access the attacker\u2019s CMK. I found that this practice was allowed by the AWS Visual Policy Editor, but I don\u2019t know whether it is common.\n\nThe AWS Encryption SDKs also succumb to this attack. The SDKs implement envelope encryption: encrypting data with a data encryption key (DEK) and then wrapping the DEK with a CMK using the Encrypt API in AWS KMS. The wrapped DEK is stored as part of the final ciphertext (format is defined [here](https://docs.aws.amazon.com/encryption-sdk/latest/developer-guide/message-format.html)). The attacker can mount this attack by replacing the CMK in the wrapped DEK with their own.\n\n```\n{\n    \"eventVersion\": \"1.05\",\n    \"userIdentity\": {\n        \"type\": \"AWSAccount\",\n        \"principalId\": \"<redacted this is the principal ID of the victim>\",\n        \"accountId\": \"<redacted - this is the AWS account ID of the victim>\"\n    },\n    \"eventTime\": \"2020-06-21T21:05:04Z\",\n    \"eventSource\": \"kms.amazonaws.com\",\n    \"eventName\": \"Decrypt\",\n    \"awsRegion\": \"us-west-2\",\n    \"sourceIPAddress\": \"<redacted - this is the IP address of the victim>\",\n    \"userAgent\": \"<redacted - this is the user agent of the victim>\",\n    \"errorCode\": \"InvalidCiphertextException\",\n    \"requestParameters\": {\n        // The encryption context might include other data from the victim\n        \"encryptionContext\": {\n            \"aws-crypto-public-key\": \"AzfNOGOnNYFmpHspKrAm1L6XtRybONkmkhmB/IriKSA7b2NsV4MEPMph9yX2KTPKWw==\"\n        },\n        \"encryptionAlgorithm\": \"SYMMETRIC_DEFAULT\"\n    },\n    \"responseElements\": null,\n    \"requestID\": \"aeced8e8-75a2-42c3-96ac-d1fa2a1c5ee6\",\n    \"eventID\": \"780a0a6e-4ad8-43d4-a426-75d05022f870\",\n    \"readOnly\": true,\n    \"resources\": [\n        {\n            \"accountId\": \"<redacted - this is the account ID of the attacker>\",\n            \"type\": \"AWS::KMS::Key\",\n            \"ARN\": <redacted - this is the key ARN of the attacker>\n        }\n    ],\n    \"eventType\": \"AwsApiCall\",\n    \"recipientAccountId\": \"<redacted - this is the account ID of the attacker>\",\n    \"sharedEventID\": \"033e147c-8a36-42f5-9d6c-9e071eb752b7\"\n}\n```\n**Figure 1: A failure event logged to the attacker\u2019s Cloud Trail when the victim attempted to decrypt a modified ciphertext containing the attacker\u2019s CMK.**\n\n## Ciphertext Forgery\n\nThe [Decrypt](https://docs.aws.amazon.com/kms/latest/APIReference/API_Decrypt.html) API in AWS KMS doesn\u2019t require the caller to specify the CMK. This parameter is required only when the ciphertext was encrypted under an asymmetric CMK. Otherwise, AWS KMS uses the metadata that it adds to the ciphertext blob to determine which CMK was used to encrypt the ciphertext.\n\nThis leads to the following attack:\n* The attacker creates a CMK that has a key policy that allows access from everyone. This requires no prior knowledge about the victim.\n* The attacker generates a ciphertext by calling the Encrypt API with their key.\n* The attacker intercepts a ciphertext from the victim, and replaces it entirely with their ciphertext.\n* The victim successfully decrypts the ciphertext, as if it was encrypted under their own key. The attacker also learns when this happened, the victim\u2019s AWS Account ID, user agent, encryption context, and IP address.\n\nSimilar to the information leakage attack, this attack also requires the victim to have an IAM policy that allows them to access the attacker\u2019s CMK.\n\nThe AWS Encryption SDKs also succumb to this attack. They don\u2019t specify the CMK when they call the Decrypt API to unwrap the DEK.\n\n## Robustness\n\nThe AWS Encryption SDKs allow a single ciphertext to be generated for multiple recipients, with each decrypting using a different key. To that end, it wraps the DEK multiple times, each under a different CMK. The wrapped DEKs can be combined to form a single ciphertext which can be sent to multiple recipients who can use their own credentials to decrypt it. It\u2019s reasonable to expect that all recipients should decrypt the ciphertext to an identical plaintext. However, because of the use of AES-GMAC and AES-GCM, it\u2019s possible to create a ciphertext that decrypts to two valid yet different plaintexts for two different users. In other words, the AWS Encryption SDKs are [not](https://eprint.iacr.org/2008/440.pdf) [robust](https://eprint.iacr.org/2019/016.pdf).\n\nThe encryption of a message under two CMKs can be summarized as follows:\n* A DEK is randomly generated, and two wrapped DEKs are produced by calling the Encrypt API using the two CMKs\n* A per-message AES-GCM key (K) is derived using HKDF from the DEK, a randomly generated message ID, and a fixed algorithm ID.\n* A header is formed from the wrapped DEKs, the encryption context, and other metadata. A header authentication tag is computed on the header using AES-GMAC with K and a zero IV.\n* The message is encrypted using AES-GCM with K, a non-zero IV, and fixed associated additional data. This produces a message authentication tag.\n* The ciphertext consists of the header, the header authentication tag, the encrypted message, and the message authentication tag.\n\n(There\u2019s also a self-signed digital signature that is irrelevant to this discussion).\n\nIn order to decrypt a ciphertext, the AWS Encryption SDKs loops over the list of wrapped DEKs and returns the first one that it can successfully unwrap. The attacker therefore can wrap a unique DEK for each recipient. Next, the attacker exploits the non-committing property of GMAC to produce two messages that have the same GMAC tag under two different keys. The attacker has to do this twice, one for the header authentication tag and one for the message authentication tag.\n\n```\nGiven a data blob B of one 128-bit block B_1, a GMAC tag is computed as follows:\n\nB_1 * H^2 + B_len * H + J\n\nwhere H and J depends on the key and B_len depends on the length of B.\n\nTo find a message that can produce the same tag under two different keys, one\ncan add append to B a new block B_2 whose value can be deduced by solving\nan algebraic equation. That is, we want to find B_2 such that:\n\nB_1 * H^3 + B_2 * H^2 + B_len * H + J = B_1 * H\u2019^3 + B_2 * H\u2019^2 + B_len * H\u2019 + J\u2019\n\nwhere H\u2019 and J\u2019 are the corresponding H and J of the other key.\n\nB_2 is the only unknown value in this equation, thus it can be computed using\nfinite field arithmetics of GF(2^128):\n\nB_2 = [B_1 * (H^3+H\u2019^3) + B_len * (H + H\u2019) + J + J\u2019] * (H^2 + H\u2019^2)^-1.\n```\n**Figure 2: How to find a message that has the same GMAC tag under two different keys.**\n\nThe overall attack works as follows:\n* The attacker generates a random DEK, derives a per-message key K, and encrypts message M with it using AES in counter mode. This generates a ciphertext C.\n* The attacker generates another random DEK\u2019, derives a per-message key K\u2019, and performs trial decryption of C until the decrypted message M\u2019 has desirable properties. For example, if the attacker wants the first bit of M\u2019 different from that of M, this process should only take a few attempts.\n* The attacker finds a block C* such that the GMAC of C\u2019 = C || C* under K and K\u2019 are identical. Denote this tag C\u2019_tag.\n* The attacker wraps DEK and DEK\u2019 under two recipients\u2019 CMK.\n* The attacker forms a header H and adds a block H* to the encryption context such that the new H\u2019 has the same authentication tag H\u2019_tag under K and K\u2019.\n* The attacker output H\u2019, H\u2019_tag, C\u2019, C\u2019_tag.\n\nThis attack is similar to the one discovered in [Facebook Messenger](https://eprint.iacr.org/2019/016.pdf).\n\n# Acknowledgement\n\nI\u2019m grateful to Jen Barnason for carefully editing this advisory. I will never publish anything without her approval! I want to thank my friend and coworker Sophie \u201cQueen of Hashing\u201d Schmieg for wonderful discussions and for showing me how the arithmetic in GF(2^128) works. I want to thank Jonathan Bannet for asking the questions that led to this work.",
                "fixed_in": [
                    "2.0.0"
                ],
                "id": "GHSA-wqgp-vphw-hphf",
                "link": "https://osv.dev/vulnerability/GHSA-wqgp-vphw-hphf",
                "source": "osv",
                "summary": null,
                "withdrawn": null
            },
            {
                "aliases": [],
                "details": "### Impact\n\nThis advisory addresses several LOW severity issues with streaming signed messages and restricting processing of certain types of invalid messages. \n\nThis ESDK supports a streaming mode where callers may stream the plaintext of signed messages before the ECDSA signature is validated. In addition to these signatures, the ESDK uses AES-GCM encryption and all plaintext is verified before being released to a caller. There is no impact on the integrity of the ciphertext or decrypted plaintext, however some callers may rely on the the ECDSA signature for non-repudiation. Without validating the ECDSA signature, an actor with trusted KMS permissions to decrypt a message may also be able to encrypt messages. This update introduces a new API for callers who wish to stream only unsigned messages. \n\nFor customers who process ESDK messages from untrusted sources, this update also introduces a new configuration to limit the number of Encrypted Data Keys (EDKs) that the ESDK will attempt to process per message. This configuration provides customers with a way to limit the number of AWS KMS Decrypt API calls that the ESDK will make per message. This setting will reject messages with more EDKs than the configured limit.\n\nFinally, this update adds early rejection of invalid messages with certain invalid combinations of algorithm suite and header data.\n\n### Patches\n\nFixed in versions 1.9 and 2.2. We recommend that all users upgrade to address these issues.\n\nCustomers leveraging the ESDK\u2019s streaming features have several options to protect signature validation. One is to ensure that client code reads to the end of the stream before using released plaintext. With this release, using the new API for streaming and falling back to the non-streaming decrypt API for signed messages prevents using any plaintext from signed data before the signature is validated. See https://docs.aws.amazon.com/encryption-sdk/latest/developer-guide/about-versions.html#version2.2.x\n\nUsers processing ESDK messages from untrusted sources should use the new maximum encrypted data keys parameter. See https://docs.aws.amazon.com/encryption-sdk/latest/developer-guide/about-versions.html#version2.2.x\n\n### Workarounds\n\nNone\n\n### For more information\n\nhttps://docs.aws.amazon.com/encryption-sdk/latest/developer-guide/concepts.html#digital-sigs\n\nhttps://docs.aws.amazon.com/encryption-sdk/latest/developer-guide/about-versions.html#version2.2.x\n",
                "fixed_in": [
                    "1.9.0",
                    "2.2.0"
                ],
                "id": "GHSA-x5h4-9gqw-942j",
                "link": "https://osv.dev/vulnerability/GHSA-x5h4-9gqw-942j",
                "source": "osv",
                "summary": null,
                "withdrawn": null
            }
        ]
    },
    "1.3.2": {
        "info": {
            "author": "Amazon Web Services",
            "author_email": "aws-cryptools@amazon.com",
            "bugtrack_url": null,
            "classifiers": [
                "Development Status :: 5 - Production/Stable",
                "Intended Audience :: Developers",
                "License :: OSI Approved :: Apache Software License",
                "Natural Language :: English",
                "Programming Language :: Python",
                "Programming Language :: Python :: 2",
                "Programming Language :: Python :: 2.7",
                "Programming Language :: Python :: 3",
                "Programming Language :: Python :: 3.4",
                "Programming Language :: Python :: Implementation :: CPython",
                "Topic :: Security",
                "Topic :: Security :: Cryptography"
            ],
            "description_content_type": null,
            "docs_url": null,
            "download_url": "",
            "downloads": {
                "last_day": -1,
                "last_month": -1,
                "last_week": -1
            },
            "home_page": "https://github.com/awslabs/aws-encryption-sdk-python",
            "keywords": "aws-encryption-sdk aws kms encryption",
            "license": "Apache License 2.0",
            "maintainer": "",
            "maintainer_email": "",
            "name": "aws-encryption-sdk",
            "package_url": "https://pypi.org/project/aws-encryption-sdk/",
            "platform": "",
            "project_url": "https://pypi.org/project/aws-encryption-sdk/",
            "project_urls": {
                "Homepage": "https://github.com/awslabs/aws-encryption-sdk-python"
            },
            "release_url": "https://pypi.org/project/aws-encryption-sdk/1.3.2/",
            "requires_dist": [
                "boto3 (>=1.4.4)",
                "cryptography (>=1.8.1)",
                "attrs (>=16.3.0)",
                "wrapt (>=1.10.11)"
            ],
            "requires_python": "",
            "summary": "AWS Encryption SDK implementation for Python",
            "version": "1.3.2",
            "yanked": false,
            "yanked_reason": null
        },
        "last_serial": 14939260,
        "urls": [
            {
                "comment_text": "",
                "digests": {
                    "md5": "ffdf1036e3a6ca0f3ed2ca558f3c234a",
                    "sha256": "7dcfa02b336906ce4dfc76290bccf3242b3c9dd9bfa132c49f658340b4aca46f"
                },
                "downloads": -1,
                "filename": "aws_encryption_sdk-1.3.2-py2.py3-none-any.whl",
                "has_sig": false,
                "md5_digest": "ffdf1036e3a6ca0f3ed2ca558f3c234a",
                "packagetype": "bdist_wheel",
                "python_version": "py2.py3",
                "requires_python": null,
                "size": 86799,
                "upload_time": "2017-09-28T17:17:52",
                "upload_time_iso_8601": "2017-09-28T17:17:52.798289Z",
                "url": "https://files.pythonhosted.org/packages/9a/ec/a2ea82e7b881bba0af36e27a39909c877cd02c29a78b5ce596b2ac966d19/aws_encryption_sdk-1.3.2-py2.py3-none-any.whl",
                "yanked": false,
                "yanked_reason": null
            },
            {
                "comment_text": "",
                "digests": {
                    "md5": "0256700c9d542489c0d2b77ba11f0fed",
                    "sha256": "8504f551f213a9503477e3b40f5bbea2ad26aabd56e341a07fa3a70d7d2618ef"
                },
                "downloads": -1,
                "filename": "aws-encryption-sdk-1.3.2.tar.gz",
                "has_sig": false,
                "md5_digest": "0256700c9d542489c0d2b77ba11f0fed",
                "packagetype": "sdist",
                "python_version": "source",
                "requires_python": null,
                "size": 56236,
                "upload_time": "2017-09-28T17:17:56",
                "upload_time_iso_8601": "2017-09-28T17:17:56.707262Z",
                "url": "https://files.pythonhosted.org/packages/e6/98/66c4defc7d87c499cbd5c19e4bfcf4297cc661fd928cc3797832ed16684c/aws-encryption-sdk-1.3.2.tar.gz",
                "yanked": false,
                "yanked_reason": null
            }
        ],
        "vulnerabilities": [
            {
                "aliases": [
                    "CVE-2020-8897"
                ],
                "details": "A weak robustness vulnerability exists in the AWS Encryption SDKs for Java, Python, C and Javalcript prior to versions 2.0.0. Due to the non-committing property of AES-GCM (and other AEAD ciphers such as AES-GCM-SIV or (X)ChaCha20Poly1305) used by the SDKs to encrypt messages, an attacker can craft a unique cyphertext which will decrypt to multiple different results, and becomes especially relevant in a multi-recipient setting. We recommend users update their SDK to 2.0.0 or later.",
                "fixed_in": [
                    "2.0.0"
                ],
                "id": "PYSEC-2020-261",
                "link": "https://osv.dev/vulnerability/PYSEC-2020-261",
                "source": "osv",
                "summary": null,
                "withdrawn": null
            },
            {
                "aliases": [
                    "CVE-2020-8897"
                ],
                "details": "Authors: Thai \"[thaidn](https://twitter.com/xorninja)\" Duong\n\n# Summary\n\nThe following security vulnerabilities was discovered and reported to Amazon, affecting AWS KMS and all versions of [AWS Encryption SDKs](https://docs.aws.amazon.com/encryption-sdk/latest/developer-guide/introduction.html) prior to version 2.0.0:\n\n* **Information leakage**: an attacker can create ciphertexts that would leak the user\u2019s AWS account ID, encryption context, user agent, and IP address upon decryption\n* **Ciphertext forgery**: an attacker can create ciphertexts that are accepted by other users\n* **Robustness**: an attacker can create ciphertexts that decrypt to different plaintexts for different users\n\nThe first two bugs are somewhat surprising because they show that the ciphertext format can lead to vulnerabilities. These bugs (and the infamous [alg: \"None\"](https://auth0.com/blog/critical-vulnerabilities-in-json-web-token-libraries/) bugs in JWT) belong to a class of vulnerabilities called **in-band protocol negotiation**. This is the second time we\u2019ve found in-band protocol negotiation vulnerabilities in AWS cryptography libraries; see this [bug](https://github.com/google/security-research/security/advisories/GHSA-7f33-f4f5-xwgw) in S3 Crypto SDK discovered by my colleague Sophie Schmieg.\n\nIn JWT and S3 SDK the culprit is the algorithm field\u2014here it is the key ID. Because the key ID is used to determine which decryption key to use, it can\u2019t be meaningfully authenticated despite being under the attacker\u2019s control. If the key ID is a URL indicating where to fetch the key, the attacker can replace it with their own URL, and learn side-channel information such as the timing and machines on which the decryption happens (this can also lead to [SSRF](https://portswigger.net/web-security/ssrf) issues, but that\u2019s another topic for another day).\n\nIn AWS, the key ID is a unique [Amazon Resource Name](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html). If an attacker were to capture a ciphertext from a user and replace its key ID with their own, the victim\u2019s AWS account ID, encryption context, user agent, and IP address would be logged to the attacker\u2019s AWS account whenever the victim attempted to decrypt the modified ciphertext.\n\nThe last bug shows that the non-committing property of AES-GCM (and other AEAD ciphers such as [AES-GCM-SIV](https://keymaterial.net/2020/09/07/invisible-salamanders-in-aes-gcm-siv/) or (X)ChaCha20Poly1305) is especially problematic in multi-recipient settings. These ciphers have a property that can cause nonidentical plaintexts when decrypting a single ciphertext with two different keys! For example, you can send a single encrypted email to Alice and Bob which, upon decryption, reads \u201cattack\u201d to Alice and \u201cretreat\u201d to Bob. The AWS Encryption SDKs are vulnerable to this attack because they allow a single ciphertext to be generated for multiple recipients, with each decrypting using a different key. I believe this kind of problem is prevalent. I briefly looked at [JWE](https://tools.ietf.org/html/rfc7516) and I think it is vulnerable.\n\n# Mitigations\n\nAmazon has fixed these bugs in release 2.0.0 of the SDKs. A new major version was required because, unfortunately, the fix for the last bug requires a breaking change from earlier versions. All users are recommended to upgrade. More details about Amazon\u2019s mitigations can be found in [their announcement](https://aws.amazon.com/blogs/security/improved-client-side-encryption-explicit-keyids-and-key-commitment/).\n\nWe\u2019re collaborating with Shay Gueron on a paper regarding fast committing AEADs.\n\n# Vulnerabilities\n\n## Information Leakage\n\nThe [Encrypt](https://docs.aws.amazon.com/kms/latest/APIReference/API_Encrypt.html) API in AWS KMS encrypts plaintext into ciphertext by using a customer master key (CMK). The ciphertext format is undocumented, but it contains metadata that specifies the CMK and the encryption algorithm. I reverse-engineered the format and found the location of the CMK. Externally the CMK is identified by its key ARN, but within a ciphertext it is represented by an internal ID, which remained stable during my testing.\n\nWhen I replaced the internal ID of a CMK in a ciphertext with the internal ID of another CMK, I found that AWS KMS attempted to decrypt the ciphertext with the new CMK. The encryption failed and the failure event\u2014including the AWS Account ID, the user agent and the IP address of the caller\u2014was logged to Cloud Trail in the account that owned the replacement CMK.\n\nThis enables the following attack:\n* The attacker creates a CMK that has a key policy that allows access from everyone. This requires no prior knowledge about the victim.\n* The attacker intercepts a ciphertext from the victim, and replaces its CMK with their CMK.\n* Whenever the victim attempts to decrypt the modified ciphertext, the attacker learns the timing of such actions, the victim\u2019s AWS Account ID, user agent, encryption context, and IP address.\n\nThis attack requires the victim to have an IAM policy that allows them to access the attacker\u2019s CMK. I found that this practice was allowed by the AWS Visual Policy Editor, but I don\u2019t know whether it is common.\n\nThe AWS Encryption SDKs also succumb to this attack. The SDKs implement envelope encryption: encrypting data with a data encryption key (DEK) and then wrapping the DEK with a CMK using the Encrypt API in AWS KMS. The wrapped DEK is stored as part of the final ciphertext (format is defined [here](https://docs.aws.amazon.com/encryption-sdk/latest/developer-guide/message-format.html)). The attacker can mount this attack by replacing the CMK in the wrapped DEK with their own.\n\n```\n{\n    \"eventVersion\": \"1.05\",\n    \"userIdentity\": {\n        \"type\": \"AWSAccount\",\n        \"principalId\": \"<redacted this is the principal ID of the victim>\",\n        \"accountId\": \"<redacted - this is the AWS account ID of the victim>\"\n    },\n    \"eventTime\": \"2020-06-21T21:05:04Z\",\n    \"eventSource\": \"kms.amazonaws.com\",\n    \"eventName\": \"Decrypt\",\n    \"awsRegion\": \"us-west-2\",\n    \"sourceIPAddress\": \"<redacted - this is the IP address of the victim>\",\n    \"userAgent\": \"<redacted - this is the user agent of the victim>\",\n    \"errorCode\": \"InvalidCiphertextException\",\n    \"requestParameters\": {\n        // The encryption context might include other data from the victim\n        \"encryptionContext\": {\n            \"aws-crypto-public-key\": \"AzfNOGOnNYFmpHspKrAm1L6XtRybONkmkhmB/IriKSA7b2NsV4MEPMph9yX2KTPKWw==\"\n        },\n        \"encryptionAlgorithm\": \"SYMMETRIC_DEFAULT\"\n    },\n    \"responseElements\": null,\n    \"requestID\": \"aeced8e8-75a2-42c3-96ac-d1fa2a1c5ee6\",\n    \"eventID\": \"780a0a6e-4ad8-43d4-a426-75d05022f870\",\n    \"readOnly\": true,\n    \"resources\": [\n        {\n            \"accountId\": \"<redacted - this is the account ID of the attacker>\",\n            \"type\": \"AWS::KMS::Key\",\n            \"ARN\": <redacted - this is the key ARN of the attacker>\n        }\n    ],\n    \"eventType\": \"AwsApiCall\",\n    \"recipientAccountId\": \"<redacted - this is the account ID of the attacker>\",\n    \"sharedEventID\": \"033e147c-8a36-42f5-9d6c-9e071eb752b7\"\n}\n```\n**Figure 1: A failure event logged to the attacker\u2019s Cloud Trail when the victim attempted to decrypt a modified ciphertext containing the attacker\u2019s CMK.**\n\n## Ciphertext Forgery\n\nThe [Decrypt](https://docs.aws.amazon.com/kms/latest/APIReference/API_Decrypt.html) API in AWS KMS doesn\u2019t require the caller to specify the CMK. This parameter is required only when the ciphertext was encrypted under an asymmetric CMK. Otherwise, AWS KMS uses the metadata that it adds to the ciphertext blob to determine which CMK was used to encrypt the ciphertext.\n\nThis leads to the following attack:\n* The attacker creates a CMK that has a key policy that allows access from everyone. This requires no prior knowledge about the victim.\n* The attacker generates a ciphertext by calling the Encrypt API with their key.\n* The attacker intercepts a ciphertext from the victim, and replaces it entirely with their ciphertext.\n* The victim successfully decrypts the ciphertext, as if it was encrypted under their own key. The attacker also learns when this happened, the victim\u2019s AWS Account ID, user agent, encryption context, and IP address.\n\nSimilar to the information leakage attack, this attack also requires the victim to have an IAM policy that allows them to access the attacker\u2019s CMK.\n\nThe AWS Encryption SDKs also succumb to this attack. They don\u2019t specify the CMK when they call the Decrypt API to unwrap the DEK.\n\n## Robustness\n\nThe AWS Encryption SDKs allow a single ciphertext to be generated for multiple recipients, with each decrypting using a different key. To that end, it wraps the DEK multiple times, each under a different CMK. The wrapped DEKs can be combined to form a single ciphertext which can be sent to multiple recipients who can use their own credentials to decrypt it. It\u2019s reasonable to expect that all recipients should decrypt the ciphertext to an identical plaintext. However, because of the use of AES-GMAC and AES-GCM, it\u2019s possible to create a ciphertext that decrypts to two valid yet different plaintexts for two different users. In other words, the AWS Encryption SDKs are [not](https://eprint.iacr.org/2008/440.pdf) [robust](https://eprint.iacr.org/2019/016.pdf).\n\nThe encryption of a message under two CMKs can be summarized as follows:\n* A DEK is randomly generated, and two wrapped DEKs are produced by calling the Encrypt API using the two CMKs\n* A per-message AES-GCM key (K) is derived using HKDF from the DEK, a randomly generated message ID, and a fixed algorithm ID.\n* A header is formed from the wrapped DEKs, the encryption context, and other metadata. A header authentication tag is computed on the header using AES-GMAC with K and a zero IV.\n* The message is encrypted using AES-GCM with K, a non-zero IV, and fixed associated additional data. This produces a message authentication tag.\n* The ciphertext consists of the header, the header authentication tag, the encrypted message, and the message authentication tag.\n\n(There\u2019s also a self-signed digital signature that is irrelevant to this discussion).\n\nIn order to decrypt a ciphertext, the AWS Encryption SDKs loops over the list of wrapped DEKs and returns the first one that it can successfully unwrap. The attacker therefore can wrap a unique DEK for each recipient. Next, the attacker exploits the non-committing property of GMAC to produce two messages that have the same GMAC tag under two different keys. The attacker has to do this twice, one for the header authentication tag and one for the message authentication tag.\n\n```\nGiven a data blob B of one 128-bit block B_1, a GMAC tag is computed as follows:\n\nB_1 * H^2 + B_len * H + J\n\nwhere H and J depends on the key and B_len depends on the length of B.\n\nTo find a message that can produce the same tag under two different keys, one\ncan add append to B a new block B_2 whose value can be deduced by solving\nan algebraic equation. That is, we want to find B_2 such that:\n\nB_1 * H^3 + B_2 * H^2 + B_len * H + J = B_1 * H\u2019^3 + B_2 * H\u2019^2 + B_len * H\u2019 + J\u2019\n\nwhere H\u2019 and J\u2019 are the corresponding H and J of the other key.\n\nB_2 is the only unknown value in this equation, thus it can be computed using\nfinite field arithmetics of GF(2^128):\n\nB_2 = [B_1 * (H^3+H\u2019^3) + B_len * (H + H\u2019) + J + J\u2019] * (H^2 + H\u2019^2)^-1.\n```\n**Figure 2: How to find a message that has the same GMAC tag under two different keys.**\n\nThe overall attack works as follows:\n* The attacker generates a random DEK, derives a per-message key K, and encrypts message M with it using AES in counter mode. This generates a ciphertext C.\n* The attacker generates another random DEK\u2019, derives a per-message key K\u2019, and performs trial decryption of C until the decrypted message M\u2019 has desirable properties. For example, if the attacker wants the first bit of M\u2019 different from that of M, this process should only take a few attempts.\n* The attacker finds a block C* such that the GMAC of C\u2019 = C || C* under K and K\u2019 are identical. Denote this tag C\u2019_tag.\n* The attacker wraps DEK and DEK\u2019 under two recipients\u2019 CMK.\n* The attacker forms a header H and adds a block H* to the encryption context such that the new H\u2019 has the same authentication tag H\u2019_tag under K and K\u2019.\n* The attacker output H\u2019, H\u2019_tag, C\u2019, C\u2019_tag.\n\nThis attack is similar to the one discovered in [Facebook Messenger](https://eprint.iacr.org/2019/016.pdf).\n\n# Acknowledgement\n\nI\u2019m grateful to Jen Barnason for carefully editing this advisory. I will never publish anything without her approval! I want to thank my friend and coworker Sophie \u201cQueen of Hashing\u201d Schmieg for wonderful discussions and for showing me how the arithmetic in GF(2^128) works. I want to thank Jonathan Bannet for asking the questions that led to this work.",
                "fixed_in": [
                    "2.0.0"
                ],
                "id": "GHSA-wqgp-vphw-hphf",
                "link": "https://osv.dev/vulnerability/GHSA-wqgp-vphw-hphf",
                "source": "osv",
                "summary": null,
                "withdrawn": null
            },
            {
                "aliases": [],
                "details": "### Impact\n\nThis advisory addresses several LOW severity issues with streaming signed messages and restricting processing of certain types of invalid messages. \n\nThis ESDK supports a streaming mode where callers may stream the plaintext of signed messages before the ECDSA signature is validated. In addition to these signatures, the ESDK uses AES-GCM encryption and all plaintext is verified before being released to a caller. There is no impact on the integrity of the ciphertext or decrypted plaintext, however some callers may rely on the the ECDSA signature for non-repudiation. Without validating the ECDSA signature, an actor with trusted KMS permissions to decrypt a message may also be able to encrypt messages. This update introduces a new API for callers who wish to stream only unsigned messages. \n\nFor customers who process ESDK messages from untrusted sources, this update also introduces a new configuration to limit the number of Encrypted Data Keys (EDKs) that the ESDK will attempt to process per message. This configuration provides customers with a way to limit the number of AWS KMS Decrypt API calls that the ESDK will make per message. This setting will reject messages with more EDKs than the configured limit.\n\nFinally, this update adds early rejection of invalid messages with certain invalid combinations of algorithm suite and header data.\n\n### Patches\n\nFixed in versions 1.9 and 2.2. We recommend that all users upgrade to address these issues.\n\nCustomers leveraging the ESDK\u2019s streaming features have several options to protect signature validation. One is to ensure that client code reads to the end of the stream before using released plaintext. With this release, using the new API for streaming and falling back to the non-streaming decrypt API for signed messages prevents using any plaintext from signed data before the signature is validated. See https://docs.aws.amazon.com/encryption-sdk/latest/developer-guide/about-versions.html#version2.2.x\n\nUsers processing ESDK messages from untrusted sources should use the new maximum encrypted data keys parameter. See https://docs.aws.amazon.com/encryption-sdk/latest/developer-guide/about-versions.html#version2.2.x\n\n### Workarounds\n\nNone\n\n### For more information\n\nhttps://docs.aws.amazon.com/encryption-sdk/latest/developer-guide/concepts.html#digital-sigs\n\nhttps://docs.aws.amazon.com/encryption-sdk/latest/developer-guide/about-versions.html#version2.2.x\n",
                "fixed_in": [
                    "1.9.0",
                    "2.2.0"
                ],
                "id": "GHSA-x5h4-9gqw-942j",
                "link": "https://osv.dev/vulnerability/GHSA-x5h4-9gqw-942j",
                "source": "osv",
                "summary": null,
                "withdrawn": null
            }
        ]
    },
    "1.3.3": {
        "info": {
            "author": "Amazon Web Services",
            "author_email": "aws-cryptools@amazon.com",
            "bugtrack_url": null,
            "classifiers": [
                "Development Status :: 5 - Production/Stable",
                "Intended Audience :: Developers",
                "License :: OSI Approved :: Apache Software License",
                "Natural Language :: English",
                "Programming Language :: Python",
                "Programming Language :: Python :: 2",
                "Programming Language :: Python :: 2.7",
                "Programming Language :: Python :: 3",
                "Programming Language :: Python :: 3.4",
                "Programming Language :: Python :: Implementation :: CPython",
                "Topic :: Security",
                "Topic :: Security :: Cryptography"
            ],
            "description_content_type": null,
            "docs_url": null,
            "download_url": "",
            "downloads": {
                "last_day": -1,
                "last_month": -1,
                "last_week": -1
            },
            "home_page": "https://github.com/awslabs/aws-encryption-sdk-python",
            "keywords": "aws-encryption-sdk aws kms encryption",
            "license": "Apache License 2.0",
            "maintainer": "",
            "maintainer_email": "",
            "name": "aws-encryption-sdk",
            "package_url": "https://pypi.org/project/aws-encryption-sdk/",
            "platform": "",
            "project_url": "https://pypi.org/project/aws-encryption-sdk/",
            "project_urls": {
                "Homepage": "https://github.com/awslabs/aws-encryption-sdk-python"
            },
            "release_url": "https://pypi.org/project/aws-encryption-sdk/1.3.3/",
            "requires_dist": [
                "boto3 (>=1.4.4)",
                "cryptography (>=1.8.1)",
                "attrs (>=16.3.0)",
                "wrapt (>=1.10.11)"
            ],
            "requires_python": "",
            "summary": "AWS Encryption SDK implementation for Python",
            "version": "1.3.3",
            "yanked": false,
            "yanked_reason": null
        },
        "last_serial": 14939260,
        "urls": [
            {
                "comment_text": "",
                "digests": {
                    "md5": "52a771205a32b8cc8d92961e28a64da8",
                    "sha256": "52a9a2b9b5432c674b2140cfe31d0643ca108bdc482b00e12e5f1446186d3fc1"
                },
                "downloads": -1,
                "filename": "aws_encryption_sdk-1.3.3-py2.py3-none-any.whl",
                "has_sig": false,
                "md5_digest": "52a771205a32b8cc8d92961e28a64da8",
                "packagetype": "bdist_wheel",
                "python_version": "py2.py3",
                "requires_python": null,
                "size": 86785,
                "upload_time": "2017-12-05T21:53:14",
                "upload_time_iso_8601": "2017-12-05T21:53:14.997608Z",
                "url": "https://files.pythonhosted.org/packages/3c/ca/05bf9a9e0dd3f9f4bfb5754924fd051809f75b58fbc17c464ff1e7a8f092/aws_encryption_sdk-1.3.3-py2.py3-none-any.whl",
                "yanked": false,
                "yanked_reason": null
            },
            {
                "comment_text": "",
                "digests": {
                    "md5": "a5da5f2d3b640aa3fc56da4ac1ba8d73",
                    "sha256": "7ce025280818ff8b03f4ab73fbb8179838afaec39c09ccff3c3ab722e78be5c9"
                },
                "downloads": -1,
                "filename": "aws-encryption-sdk-1.3.3.tar.gz",
                "has_sig": false,
                "md5_digest": "a5da5f2d3b640aa3fc56da4ac1ba8d73",
                "packagetype": "sdist",
                "python_version": "source",
                "requires_python": null,
                "size": 2142987,
                "upload_time": "2017-12-05T21:53:18",
                "upload_time_iso_8601": "2017-12-05T21:53:18.041627Z",
                "url": "https://files.pythonhosted.org/packages/3e/ab/a4f7ae9b367f294403c3d41f9d26a58293bca3ff214581221d5989804902/aws-encryption-sdk-1.3.3.tar.gz",
                "yanked": false,
                "yanked_reason": null
            }
        ],
        "vulnerabilities": [
            {
                "aliases": [
                    "CVE-2020-8897"
                ],
                "details": "A weak robustness vulnerability exists in the AWS Encryption SDKs for Java, Python, C and Javalcript prior to versions 2.0.0. Due to the non-committing property of AES-GCM (and other AEAD ciphers such as AES-GCM-SIV or (X)ChaCha20Poly1305) used by the SDKs to encrypt messages, an attacker can craft a unique cyphertext which will decrypt to multiple different results, and becomes especially relevant in a multi-recipient setting. We recommend users update their SDK to 2.0.0 or later.",
                "fixed_in": [
                    "2.0.0"
                ],
                "id": "PYSEC-2020-261",
                "link": "https://osv.dev/vulnerability/PYSEC-2020-261",
                "source": "osv",
                "summary": null,
                "withdrawn": null
            },
            {
                "aliases": [
                    "CVE-2020-8897"
                ],
                "details": "Authors: Thai \"[thaidn](https://twitter.com/xorninja)\" Duong\n\n# Summary\n\nThe following security vulnerabilities was discovered and reported to Amazon, affecting AWS KMS and all versions of [AWS Encryption SDKs](https://docs.aws.amazon.com/encryption-sdk/latest/developer-guide/introduction.html) prior to version 2.0.0:\n\n* **Information leakage**: an attacker can create ciphertexts that would leak the user\u2019s AWS account ID, encryption context, user agent, and IP address upon decryption\n* **Ciphertext forgery**: an attacker can create ciphertexts that are accepted by other users\n* **Robustness**: an attacker can create ciphertexts that decrypt to different plaintexts for different users\n\nThe first two bugs are somewhat surprising because they show that the ciphertext format can lead to vulnerabilities. These bugs (and the infamous [alg: \"None\"](https://auth0.com/blog/critical-vulnerabilities-in-json-web-token-libraries/) bugs in JWT) belong to a class of vulnerabilities called **in-band protocol negotiation**. This is the second time we\u2019ve found in-band protocol negotiation vulnerabilities in AWS cryptography libraries; see this [bug](https://github.com/google/security-research/security/advisories/GHSA-7f33-f4f5-xwgw) in S3 Crypto SDK discovered by my colleague Sophie Schmieg.\n\nIn JWT and S3 SDK the culprit is the algorithm field\u2014here it is the key ID. Because the key ID is used to determine which decryption key to use, it can\u2019t be meaningfully authenticated despite being under the attacker\u2019s control. If the key ID is a URL indicating where to fetch the key, the attacker can replace it with their own URL, and learn side-channel information such as the timing and machines on which the decryption happens (this can also lead to [SSRF](https://portswigger.net/web-security/ssrf) issues, but that\u2019s another topic for another day).\n\nIn AWS, the key ID is a unique [Amazon Resource Name](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html). If an attacker were to capture a ciphertext from a user and replace its key ID with their own, the victim\u2019s AWS account ID, encryption context, user agent, and IP address would be logged to the attacker\u2019s AWS account whenever the victim attempted to decrypt the modified ciphertext.\n\nThe last bug shows that the non-committing property of AES-GCM (and other AEAD ciphers such as [AES-GCM-SIV](https://keymaterial.net/2020/09/07/invisible-salamanders-in-aes-gcm-siv/) or (X)ChaCha20Poly1305) is especially problematic in multi-recipient settings. These ciphers have a property that can cause nonidentical plaintexts when decrypting a single ciphertext with two different keys! For example, you can send a single encrypted email to Alice and Bob which, upon decryption, reads \u201cattack\u201d to Alice and \u201cretreat\u201d to Bob. The AWS Encryption SDKs are vulnerable to this attack because they allow a single ciphertext to be generated for multiple recipients, with each decrypting using a different key. I believe this kind of problem is prevalent. I briefly looked at [JWE](https://tools.ietf.org/html/rfc7516) and I think it is vulnerable.\n\n# Mitigations\n\nAmazon has fixed these bugs in release 2.0.0 of the SDKs. A new major version was required because, unfortunately, the fix for the last bug requires a breaking change from earlier versions. All users are recommended to upgrade. More details about Amazon\u2019s mitigations can be found in [their announcement](https://aws.amazon.com/blogs/security/improved-client-side-encryption-explicit-keyids-and-key-commitment/).\n\nWe\u2019re collaborating with Shay Gueron on a paper regarding fast committing AEADs.\n\n# Vulnerabilities\n\n## Information Leakage\n\nThe [Encrypt](https://docs.aws.amazon.com/kms/latest/APIReference/API_Encrypt.html) API in AWS KMS encrypts plaintext into ciphertext by using a customer master key (CMK). The ciphertext format is undocumented, but it contains metadata that specifies the CMK and the encryption algorithm. I reverse-engineered the format and found the location of the CMK. Externally the CMK is identified by its key ARN, but within a ciphertext it is represented by an internal ID, which remained stable during my testing.\n\nWhen I replaced the internal ID of a CMK in a ciphertext with the internal ID of another CMK, I found that AWS KMS attempted to decrypt the ciphertext with the new CMK. The encryption failed and the failure event\u2014including the AWS Account ID, the user agent and the IP address of the caller\u2014was logged to Cloud Trail in the account that owned the replacement CMK.\n\nThis enables the following attack:\n* The attacker creates a CMK that has a key policy that allows access from everyone. This requires no prior knowledge about the victim.\n* The attacker intercepts a ciphertext from the victim, and replaces its CMK with their CMK.\n* Whenever the victim attempts to decrypt the modified ciphertext, the attacker learns the timing of such actions, the victim\u2019s AWS Account ID, user agent, encryption context, and IP address.\n\nThis attack requires the victim to have an IAM policy that allows them to access the attacker\u2019s CMK. I found that this practice was allowed by the AWS Visual Policy Editor, but I don\u2019t know whether it is common.\n\nThe AWS Encryption SDKs also succumb to this attack. The SDKs implement envelope encryption: encrypting data with a data encryption key (DEK) and then wrapping the DEK with a CMK using the Encrypt API in AWS KMS. The wrapped DEK is stored as part of the final ciphertext (format is defined [here](https://docs.aws.amazon.com/encryption-sdk/latest/developer-guide/message-format.html)). The attacker can mount this attack by replacing the CMK in the wrapped DEK with their own.\n\n```\n{\n    \"eventVersion\": \"1.05\",\n    \"userIdentity\": {\n        \"type\": \"AWSAccount\",\n        \"principalId\": \"<redacted this is the principal ID of the victim>\",\n        \"accountId\": \"<redacted - this is the AWS account ID of the victim>\"\n    },\n    \"eventTime\": \"2020-06-21T21:05:04Z\",\n    \"eventSource\": \"kms.amazonaws.com\",\n    \"eventName\": \"Decrypt\",\n    \"awsRegion\": \"us-west-2\",\n    \"sourceIPAddress\": \"<redacted - this is the IP address of the victim>\",\n    \"userAgent\": \"<redacted - this is the user agent of the victim>\",\n    \"errorCode\": \"InvalidCiphertextException\",\n    \"requestParameters\": {\n        // The encryption context might include other data from the victim\n        \"encryptionContext\": {\n            \"aws-crypto-public-key\": \"AzfNOGOnNYFmpHspKrAm1L6XtRybONkmkhmB/IriKSA7b2NsV4MEPMph9yX2KTPKWw==\"\n        },\n        \"encryptionAlgorithm\": \"SYMMETRIC_DEFAULT\"\n    },\n    \"responseElements\": null,\n    \"requestID\": \"aeced8e8-75a2-42c3-96ac-d1fa2a1c5ee6\",\n    \"eventID\": \"780a0a6e-4ad8-43d4-a426-75d05022f870\",\n    \"readOnly\": true,\n    \"resources\": [\n        {\n            \"accountId\": \"<redacted - this is the account ID of the attacker>\",\n            \"type\": \"AWS::KMS::Key\",\n            \"ARN\": <redacted - this is the key ARN of the attacker>\n        }\n    ],\n    \"eventType\": \"AwsApiCall\",\n    \"recipientAccountId\": \"<redacted - this is the account ID of the attacker>\",\n    \"sharedEventID\": \"033e147c-8a36-42f5-9d6c-9e071eb752b7\"\n}\n```\n**Figure 1: A failure event logged to the attacker\u2019s Cloud Trail when the victim attempted to decrypt a modified ciphertext containing the attacker\u2019s CMK.**\n\n## Ciphertext Forgery\n\nThe [Decrypt](https://docs.aws.amazon.com/kms/latest/APIReference/API_Decrypt.html) API in AWS KMS doesn\u2019t require the caller to specify the CMK. This parameter is required only when the ciphertext was encrypted under an asymmetric CMK. Otherwise, AWS KMS uses the metadata that it adds to the ciphertext blob to determine which CMK was used to encrypt the ciphertext.\n\nThis leads to the following attack:\n* The attacker creates a CMK that has a key policy that allows access from everyone. This requires no prior knowledge about the victim.\n* The attacker generates a ciphertext by calling the Encrypt API with their key.\n* The attacker intercepts a ciphertext from the victim, and replaces it entirely with their ciphertext.\n* The victim successfully decrypts the ciphertext, as if it was encrypted under their own key. The attacker also learns when this happened, the victim\u2019s AWS Account ID, user agent, encryption context, and IP address.\n\nSimilar to the information leakage attack, this attack also requires the victim to have an IAM policy that allows them to access the attacker\u2019s CMK.\n\nThe AWS Encryption SDKs also succumb to this attack. They don\u2019t specify the CMK when they call the Decrypt API to unwrap the DEK.\n\n## Robustness\n\nThe AWS Encryption SDKs allow a single ciphertext to be generated for multiple recipients, with each decrypting using a different key. To that end, it wraps the DEK multiple times, each under a different CMK. The wrapped DEKs can be combined to form a single ciphertext which can be sent to multiple recipients who can use their own credentials to decrypt it. It\u2019s reasonable to expect that all recipients should decrypt the ciphertext to an identical plaintext. However, because of the use of AES-GMAC and AES-GCM, it\u2019s possible to create a ciphertext that decrypts to two valid yet different plaintexts for two different users. In other words, the AWS Encryption SDKs are [not](https://eprint.iacr.org/2008/440.pdf) [robust](https://eprint.iacr.org/2019/016.pdf).\n\nThe encryption of a message under two CMKs can be summarized as follows:\n* A DEK is randomly generated, and two wrapped DEKs are produced by calling the Encrypt API using the two CMKs\n* A per-message AES-GCM key (K) is derived using HKDF from the DEK, a randomly generated message ID, and a fixed algorithm ID.\n* A header is formed from the wrapped DEKs, the encryption context, and other metadata. A header authentication tag is computed on the header using AES-GMAC with K and a zero IV.\n* The message is encrypted using AES-GCM with K, a non-zero IV, and fixed associated additional data. This produces a message authentication tag.\n* The ciphertext consists of the header, the header authentication tag, the encrypted message, and the message authentication tag.\n\n(There\u2019s also a self-signed digital signature that is irrelevant to this discussion).\n\nIn order to decrypt a ciphertext, the AWS Encryption SDKs loops over the list of wrapped DEKs and returns the first one that it can successfully unwrap. The attacker therefore can wrap a unique DEK for each recipient. Next, the attacker exploits the non-committing property of GMAC to produce two messages that have the same GMAC tag under two different keys. The attacker has to do this twice, one for the header authentication tag and one for the message authentication tag.\n\n```\nGiven a data blob B of one 128-bit block B_1, a GMAC tag is computed as follows:\n\nB_1 * H^2 + B_len * H + J\n\nwhere H and J depends on the key and B_len depends on the length of B.\n\nTo find a message that can produce the same tag under two different keys, one\ncan add append to B a new block B_2 whose value can be deduced by solving\nan algebraic equation. That is, we want to find B_2 such that:\n\nB_1 * H^3 + B_2 * H^2 + B_len * H + J = B_1 * H\u2019^3 + B_2 * H\u2019^2 + B_len * H\u2019 + J\u2019\n\nwhere H\u2019 and J\u2019 are the corresponding H and J of the other key.\n\nB_2 is the only unknown value in this equation, thus it can be computed using\nfinite field arithmetics of GF(2^128):\n\nB_2 = [B_1 * (H^3+H\u2019^3) + B_len * (H + H\u2019) + J + J\u2019] * (H^2 + H\u2019^2)^-1.\n```\n**Figure 2: How to find a message that has the same GMAC tag under two different keys.**\n\nThe overall attack works as follows:\n* The attacker generates a random DEK, derives a per-message key K, and encrypts message M with it using AES in counter mode. This generates a ciphertext C.\n* The attacker generates another random DEK\u2019, derives a per-message key K\u2019, and performs trial decryption of C until the decrypted message M\u2019 has desirable properties. For example, if the attacker wants the first bit of M\u2019 different from that of M, this process should only take a few attempts.\n* The attacker finds a block C* such that the GMAC of C\u2019 = C || C* under K and K\u2019 are identical. Denote this tag C\u2019_tag.\n* The attacker wraps DEK and DEK\u2019 under two recipients\u2019 CMK.\n* The attacker forms a header H and adds a block H* to the encryption context such that the new H\u2019 has the same authentication tag H\u2019_tag under K and K\u2019.\n* The attacker output H\u2019, H\u2019_tag, C\u2019, C\u2019_tag.\n\nThis attack is similar to the one discovered in [Facebook Messenger](https://eprint.iacr.org/2019/016.pdf).\n\n# Acknowledgement\n\nI\u2019m grateful to Jen Barnason for carefully editing this advisory. I will never publish anything without her approval! I want to thank my friend and coworker Sophie \u201cQueen of Hashing\u201d Schmieg for wonderful discussions and for showing me how the arithmetic in GF(2^128) works. I want to thank Jonathan Bannet for asking the questions that led to this work.",
                "fixed_in": [
                    "2.0.0"
                ],
                "id": "GHSA-wqgp-vphw-hphf",
                "link": "https://osv.dev/vulnerability/GHSA-wqgp-vphw-hphf",
                "source": "osv",
                "summary": null,
                "withdrawn": null
            },
            {
                "aliases": [],
                "details": "### Impact\n\nThis advisory addresses several LOW severity issues with streaming signed messages and restricting processing of certain types of invalid messages. \n\nThis ESDK supports a streaming mode where callers may stream the plaintext of signed messages before the ECDSA signature is validated. In addition to these signatures, the ESDK uses AES-GCM encryption and all plaintext is verified before being released to a caller. There is no impact on the integrity of the ciphertext or decrypted plaintext, however some callers may rely on the the ECDSA signature for non-repudiation. Without validating the ECDSA signature, an actor with trusted KMS permissions to decrypt a message may also be able to encrypt messages. This update introduces a new API for callers who wish to stream only unsigned messages. \n\nFor customers who process ESDK messages from untrusted sources, this update also introduces a new configuration to limit the number of Encrypted Data Keys (EDKs) that the ESDK will attempt to process per message. This configuration provides customers with a way to limit the number of AWS KMS Decrypt API calls that the ESDK will make per message. This setting will reject messages with more EDKs than the configured limit.\n\nFinally, this update adds early rejection of invalid messages with certain invalid combinations of algorithm suite and header data.\n\n### Patches\n\nFixed in versions 1.9 and 2.2. We recommend that all users upgrade to address these issues.\n\nCustomers leveraging the ESDK\u2019s streaming features have several options to protect signature validation. One is to ensure that client code reads to the end of the stream before using released plaintext. With this release, using the new API for streaming and falling back to the non-streaming decrypt API for signed messages prevents using any plaintext from signed data before the signature is validated. See https://docs.aws.amazon.com/encryption-sdk/latest/developer-guide/about-versions.html#version2.2.x\n\nUsers processing ESDK messages from untrusted sources should use the new maximum encrypted data keys parameter. See https://docs.aws.amazon.com/encryption-sdk/latest/developer-guide/about-versions.html#version2.2.x\n\n### Workarounds\n\nNone\n\n### For more information\n\nhttps://docs.aws.amazon.com/encryption-sdk/latest/developer-guide/concepts.html#digital-sigs\n\nhttps://docs.aws.amazon.com/encryption-sdk/latest/developer-guide/about-versions.html#version2.2.x\n",
                "fixed_in": [
                    "1.9.0",
                    "2.2.0"
                ],
                "id": "GHSA-x5h4-9gqw-942j",
                "link": "https://osv.dev/vulnerability/GHSA-x5h4-9gqw-942j",
                "source": "osv",
                "summary": null,
                "withdrawn": null
            }
        ]
    },
    "1.3.4": {
        "info": {
            "author": "Amazon Web Services",
            "author_email": "aws-cryptools@amazon.com",
            "bugtrack_url": null,
            "classifiers": [
                "Development Status :: 5 - Production/Stable",
                "Intended Audience :: Developers",
                "License :: OSI Approved :: Apache Software License",
                "Natural Language :: English",
                "Programming Language :: Python",
                "Programming Language :: Python :: 2",
                "Programming Language :: Python :: 2.7",
                "Programming Language :: Python :: 3",
                "Programming Language :: Python :: 3.4",
                "Programming Language :: Python :: Implementation :: CPython",
                "Topic :: Security",
                "Topic :: Security :: Cryptography"
            ],
            "description_content_type": "",
            "docs_url": null,
            "download_url": "",
            "downloads": {
                "last_day": -1,
                "last_month": -1,
                "last_week": -1
            },
            "home_page": "https://github.com/awslabs/aws-encryption-sdk-python",
            "keywords": "aws-encryption-sdk aws kms encryption",
            "license": "Apache License 2.0",
            "maintainer": "Amazon Web Services",
            "maintainer_email": "",
            "name": "aws-encryption-sdk",
            "package_url": "https://pypi.org/project/aws-encryption-sdk/",
            "platform": "",
            "project_url": "https://pypi.org/project/aws-encryption-sdk/",
            "project_urls": {
                "Homepage": "https://github.com/awslabs/aws-encryption-sdk-python"
            },
            "release_url": "https://pypi.org/project/aws-encryption-sdk/1.3.4/",
            "requires_dist": [
                "boto3 (>=1.4.4)",
                "cryptography (>=1.8.1)",
                "attrs (>=17.4.0)",
                "wrapt (>=1.10.11)"
            ],
            "requires_python": "",
            "summary": "AWS Encryption SDK implementation for Python",
            "version": "1.3.4",
            "yanked": false,
            "yanked_reason": null
        },
        "last_serial": 14939260,
        "urls": [
            {
                "comment_text": "",
                "digests": {
                    "md5": "a8e95266e58e5966f73b8e6bb7ba9902",
                    "sha256": "3ec11624e8bceeb262eeab7d3d435bf9a7599ee264739192a7a7919d54402a31"
                },
                "downloads": -1,
                "filename": "aws_encryption_sdk-1.3.4-py2.py3-none-any.whl",
                "has_sig": false,
                "md5_digest": "a8e95266e58e5966f73b8e6bb7ba9902",
                "packagetype": "bdist_wheel",
                "python_version": "py2.py3",
                "requires_python": null,
                "size": 83688,
                "upload_time": "2018-04-12T21:20:07",
                "upload_time_iso_8601": "2018-04-12T21:20:07.115961Z",
                "url": "https://files.pythonhosted.org/packages/08/b8/786d1d45836048e1a38617397814805d0c2efdd4ab757e4f9f92254bbbf4/aws_encryption_sdk-1.3.4-py2.py3-none-any.whl",
                "yanked": false,
                "yanked_reason": null
            },
            {
                "comment_text": "",
                "digests": {
                    "md5": "f93c55796fcae7586af35aec359630ec",
                    "sha256": "494ef58964547471f636ff0a3cedb8cde494a710d2fed7a6b8a83b74965ab51f"
                },
                "downloads": -1,
                "filename": "aws-encryption-sdk-1.3.4.tar.gz",
                "has_sig": false,
                "md5_digest": "f93c55796fcae7586af35aec359630ec",
                "packagetype": "sdist",
                "python_version": "source",
                "requires_python": null,
                "size": 3118915,
                "upload_time": "2018-04-12T21:20:09",
                "upload_time_iso_8601": "2018-04-12T21:20:09.183996Z",
                "url": "https://files.pythonhosted.org/packages/cc/8a/418fd04fa5a2d5d6e260a4c779b219c8d9886704274f4136d2b7b83692d0/aws-encryption-sdk-1.3.4.tar.gz",
                "yanked": false,
                "yanked_reason": null
            }
        ],
        "vulnerabilities": [
            {
                "aliases": [
                    "CVE-2020-8897"
                ],
                "details": "A weak robustness vulnerability exists in the AWS Encryption SDKs for Java, Python, C and Javalcript prior to versions 2.0.0. Due to the non-committing property of AES-GCM (and other AEAD ciphers such as AES-GCM-SIV or (X)ChaCha20Poly1305) used by the SDKs to encrypt messages, an attacker can craft a unique cyphertext which will decrypt to multiple different results, and becomes especially relevant in a multi-recipient setting. We recommend users update their SDK to 2.0.0 or later.",
                "fixed_in": [
                    "2.0.0"
                ],
                "id": "PYSEC-2020-261",
                "link": "https://osv.dev/vulnerability/PYSEC-2020-261",
                "source": "osv",
                "summary": null,
                "withdrawn": null
            },
            {
                "aliases": [
                    "CVE-2020-8897"
                ],
                "details": "Authors: Thai \"[thaidn](https://twitter.com/xorninja)\" Duong\n\n# Summary\n\nThe following security vulnerabilities was discovered and reported to Amazon, affecting AWS KMS and all versions of [AWS Encryption SDKs](https://docs.aws.amazon.com/encryption-sdk/latest/developer-guide/introduction.html) prior to version 2.0.0:\n\n* **Information leakage**: an attacker can create ciphertexts that would leak the user\u2019s AWS account ID, encryption context, user agent, and IP address upon decryption\n* **Ciphertext forgery**: an attacker can create ciphertexts that are accepted by other users\n* **Robustness**: an attacker can create ciphertexts that decrypt to different plaintexts for different users\n\nThe first two bugs are somewhat surprising because they show that the ciphertext format can lead to vulnerabilities. These bugs (and the infamous [alg: \"None\"](https://auth0.com/blog/critical-vulnerabilities-in-json-web-token-libraries/) bugs in JWT) belong to a class of vulnerabilities called **in-band protocol negotiation**. This is the second time we\u2019ve found in-band protocol negotiation vulnerabilities in AWS cryptography libraries; see this [bug](https://github.com/google/security-research/security/advisories/GHSA-7f33-f4f5-xwgw) in S3 Crypto SDK discovered by my colleague Sophie Schmieg.\n\nIn JWT and S3 SDK the culprit is the algorithm field\u2014here it is the key ID. Because the key ID is used to determine which decryption key to use, it can\u2019t be meaningfully authenticated despite being under the attacker\u2019s control. If the key ID is a URL indicating where to fetch the key, the attacker can replace it with their own URL, and learn side-channel information such as the timing and machines on which the decryption happens (this can also lead to [SSRF](https://portswigger.net/web-security/ssrf) issues, but that\u2019s another topic for another day).\n\nIn AWS, the key ID is a unique [Amazon Resource Name](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html). If an attacker were to capture a ciphertext from a user and replace its key ID with their own, the victim\u2019s AWS account ID, encryption context, user agent, and IP address would be logged to the attacker\u2019s AWS account whenever the victim attempted to decrypt the modified ciphertext.\n\nThe last bug shows that the non-committing property of AES-GCM (and other AEAD ciphers such as [AES-GCM-SIV](https://keymaterial.net/2020/09/07/invisible-salamanders-in-aes-gcm-siv/) or (X)ChaCha20Poly1305) is especially problematic in multi-recipient settings. These ciphers have a property that can cause nonidentical plaintexts when decrypting a single ciphertext with two different keys! For example, you can send a single encrypted email to Alice and Bob which, upon decryption, reads \u201cattack\u201d to Alice and \u201cretreat\u201d to Bob. The AWS Encryption SDKs are vulnerable to this attack because they allow a single ciphertext to be generated for multiple recipients, with each decrypting using a different key. I believe this kind of problem is prevalent. I briefly looked at [JWE](https://tools.ietf.org/html/rfc7516) and I think it is vulnerable.\n\n# Mitigations\n\nAmazon has fixed these bugs in release 2.0.0 of the SDKs. A new major version was required because, unfortunately, the fix for the last bug requires a breaking change from earlier versions. All users are recommended to upgrade. More details about Amazon\u2019s mitigations can be found in [their announcement](https://aws.amazon.com/blogs/security/improved-client-side-encryption-explicit-keyids-and-key-commitment/).\n\nWe\u2019re collaborating with Shay Gueron on a paper regarding fast committing AEADs.\n\n# Vulnerabilities\n\n## Information Leakage\n\nThe [Encrypt](https://docs.aws.amazon.com/kms/latest/APIReference/API_Encrypt.html) API in AWS KMS encrypts plaintext into ciphertext by using a customer master key (CMK). The ciphertext format is undocumented, but it contains metadata that specifies the CMK and the encryption algorithm. I reverse-engineered the format and found the location of the CMK. Externally the CMK is identified by its key ARN, but within a ciphertext it is represented by an internal ID, which remained stable during my testing.\n\nWhen I replaced the internal ID of a CMK in a ciphertext with the internal ID of another CMK, I found that AWS KMS attempted to decrypt the ciphertext with the new CMK. The encryption failed and the failure event\u2014including the AWS Account ID, the user agent and the IP address of the caller\u2014was logged to Cloud Trail in the account that owned the replacement CMK.\n\nThis enables the following attack:\n* The attacker creates a CMK that has a key policy that allows access from everyone. This requires no prior knowledge about the victim.\n* The attacker intercepts a ciphertext from the victim, and replaces its CMK with their CMK.\n* Whenever the victim attempts to decrypt the modified ciphertext, the attacker learns the timing of such actions, the victim\u2019s AWS Account ID, user agent, encryption context, and IP address.\n\nThis attack requires the victim to have an IAM policy that allows them to access the attacker\u2019s CMK. I found that this practice was allowed by the AWS Visual Policy Editor, but I don\u2019t know whether it is common.\n\nThe AWS Encryption SDKs also succumb to this attack. The SDKs implement envelope encryption: encrypting data with a data encryption key (DEK) and then wrapping the DEK with a CMK using the Encrypt API in AWS KMS. The wrapped DEK is stored as part of the final ciphertext (format is defined [here](https://docs.aws.amazon.com/encryption-sdk/latest/developer-guide/message-format.html)). The attacker can mount this attack by replacing the CMK in the wrapped DEK with their own.\n\n```\n{\n    \"eventVersion\": \"1.05\",\n    \"userIdentity\": {\n        \"type\": \"AWSAccount\",\n        \"principalId\": \"<redacted this is the principal ID of the victim>\",\n        \"accountId\": \"<redacted - this is the AWS account ID of the victim>\"\n    },\n    \"eventTime\": \"2020-06-21T21:05:04Z\",\n    \"eventSource\": \"kms.amazonaws.com\",\n    \"eventName\": \"Decrypt\",\n    \"awsRegion\": \"us-west-2\",\n    \"sourceIPAddress\": \"<redacted - this is the IP address of the victim>\",\n    \"userAgent\": \"<redacted - this is the user agent of the victim>\",\n    \"errorCode\": \"InvalidCiphertextException\",\n    \"requestParameters\": {\n        // The encryption context might include other data from the victim\n        \"encryptionContext\": {\n            \"aws-crypto-public-key\": \"AzfNOGOnNYFmpHspKrAm1L6XtRybONkmkhmB/IriKSA7b2NsV4MEPMph9yX2KTPKWw==\"\n        },\n        \"encryptionAlgorithm\": \"SYMMETRIC_DEFAULT\"\n    },\n    \"responseElements\": null,\n    \"requestID\": \"aeced8e8-75a2-42c3-96ac-d1fa2a1c5ee6\",\n    \"eventID\": \"780a0a6e-4ad8-43d4-a426-75d05022f870\",\n    \"readOnly\": true,\n    \"resources\": [\n        {\n            \"accountId\": \"<redacted - this is the account ID of the attacker>\",\n            \"type\": \"AWS::KMS::Key\",\n            \"ARN\": <redacted - this is the key ARN of the attacker>\n        }\n    ],\n    \"eventType\": \"AwsApiCall\",\n    \"recipientAccountId\": \"<redacted - this is the account ID of the attacker>\",\n    \"sharedEventID\": \"033e147c-8a36-42f5-9d6c-9e071eb752b7\"\n}\n```\n**Figure 1: A failure event logged to the attacker\u2019s Cloud Trail when the victim attempted to decrypt a modified ciphertext containing the attacker\u2019s CMK.**\n\n## Ciphertext Forgery\n\nThe [Decrypt](https://docs.aws.amazon.com/kms/latest/APIReference/API_Decrypt.html) API in AWS KMS doesn\u2019t require the caller to specify the CMK. This parameter is required only when the ciphertext was encrypted under an asymmetric CMK. Otherwise, AWS KMS uses the metadata that it adds to the ciphertext blob to determine which CMK was used to encrypt the ciphertext.\n\nThis leads to the following attack:\n* The attacker creates a CMK that has a key policy that allows access from everyone. This requires no prior knowledge about the victim.\n* The attacker generates a ciphertext by calling the Encrypt API with their key.\n* The attacker intercepts a ciphertext from the victim, and replaces it entirely with their ciphertext.\n* The victim successfully decrypts the ciphertext, as if it was encrypted under their own key. The attacker also learns when this happened, the victim\u2019s AWS Account ID, user agent, encryption context, and IP address.\n\nSimilar to the information leakage attack, this attack also requires the victim to have an IAM policy that allows them to access the attacker\u2019s CMK.\n\nThe AWS Encryption SDKs also succumb to this attack. They don\u2019t specify the CMK when they call the Decrypt API to unwrap the DEK.\n\n## Robustness\n\nThe AWS Encryption SDKs allow a single ciphertext to be generated for multiple recipients, with each decrypting using a different key. To that end, it wraps the DEK multiple times, each under a different CMK. The wrapped DEKs can be combined to form a single ciphertext which can be sent to multiple recipients who can use their own credentials to decrypt it. It\u2019s reasonable to expect that all recipients should decrypt the ciphertext to an identical plaintext. However, because of the use of AES-GMAC and AES-GCM, it\u2019s possible to create a ciphertext that decrypts to two valid yet different plaintexts for two different users. In other words, the AWS Encryption SDKs are [not](https://eprint.iacr.org/2008/440.pdf) [robust](https://eprint.iacr.org/2019/016.pdf).\n\nThe encryption of a message under two CMKs can be summarized as follows:\n* A DEK is randomly generated, and two wrapped DEKs are produced by calling the Encrypt API using the two CMKs\n* A per-message AES-GCM key (K) is derived using HKDF from the DEK, a randomly generated message ID, and a fixed algorithm ID.\n* A header is formed from the wrapped DEKs, the encryption context, and other metadata. A header authentication tag is computed on the header using AES-GMAC with K and a zero IV.\n* The message is encrypted using AES-GCM with K, a non-zero IV, and fixed associated additional data. This produces a message authentication tag.\n* The ciphertext consists of the header, the header authentication tag, the encrypted message, and the message authentication tag.\n\n(There\u2019s also a self-signed digital signature that is irrelevant to this discussion).\n\nIn order to decrypt a ciphertext, the AWS Encryption SDKs loops over the list of wrapped DEKs and returns the first one that it can successfully unwrap. The attacker therefore can wrap a unique DEK for each recipient. Next, the attacker exploits the non-committing property of GMAC to produce two messages that have the same GMAC tag under two different keys. The attacker has to do this twice, one for the header authentication tag and one for the message authentication tag.\n\n```\nGiven a data blob B of one 128-bit block B_1, a GMAC tag is computed as follows:\n\nB_1 * H^2 + B_len * H + J\n\nwhere H and J depends on the key and B_len depends on the length of B.\n\nTo find a message that can produce the same tag under two different keys, one\ncan add append to B a new block B_2 whose value can be deduced by solving\nan algebraic equation. That is, we want to find B_2 such that:\n\nB_1 * H^3 + B_2 * H^2 + B_len * H + J = B_1 * H\u2019^3 + B_2 * H\u2019^2 + B_len * H\u2019 + J\u2019\n\nwhere H\u2019 and J\u2019 are the corresponding H and J of the other key.\n\nB_2 is the only unknown value in this equation, thus it can be computed using\nfinite field arithmetics of GF(2^128):\n\nB_2 = [B_1 * (H^3+H\u2019^3) + B_len * (H + H\u2019) + J + J\u2019] * (H^2 + H\u2019^2)^-1.\n```\n**Figure 2: How to find a message that has the same GMAC tag under two different keys.**\n\nThe overall attack works as follows:\n* The attacker generates a random DEK, derives a per-message key K, and encrypts message M with it using AES in counter mode. This generates a ciphertext C.\n* The attacker generates another random DEK\u2019, derives a per-message key K\u2019, and performs trial decryption of C until the decrypted message M\u2019 has desirable properties. For example, if the attacker wants the first bit of M\u2019 different from that of M, this process should only take a few attempts.\n* The attacker finds a block C* such that the GMAC of C\u2019 = C || C* under K and K\u2019 are identical. Denote this tag C\u2019_tag.\n* The attacker wraps DEK and DEK\u2019 under two recipients\u2019 CMK.\n* The attacker forms a header H and adds a block H* to the encryption context such that the new H\u2019 has the same authentication tag H\u2019_tag under K and K\u2019.\n* The attacker output H\u2019, H\u2019_tag, C\u2019, C\u2019_tag.\n\nThis attack is similar to the one discovered in [Facebook Messenger](https://eprint.iacr.org/2019/016.pdf).\n\n# Acknowledgement\n\nI\u2019m grateful to Jen Barnason for carefully editing this advisory. I will never publish anything without her approval! I want to thank my friend and coworker Sophie \u201cQueen of Hashing\u201d Schmieg for wonderful discussions and for showing me how the arithmetic in GF(2^128) works. I want to thank Jonathan Bannet for asking the questions that led to this work.",
                "fixed_in": [
                    "2.0.0"
                ],
                "id": "GHSA-wqgp-vphw-hphf",
                "link": "https://osv.dev/vulnerability/GHSA-wqgp-vphw-hphf",
                "source": "osv",
                "summary": null,
                "withdrawn": null
            },
            {
                "aliases": [],
                "details": "### Impact\n\nThis advisory addresses several LOW severity issues with streaming signed messages and restricting processing of certain types of invalid messages. \n\nThis ESDK supports a streaming mode where callers may stream the plaintext of signed messages before the ECDSA signature is validated. In addition to these signatures, the ESDK uses AES-GCM encryption and all plaintext is verified before being released to a caller. There is no impact on the integrity of the ciphertext or decrypted plaintext, however some callers may rely on the the ECDSA signature for non-repudiation. Without validating the ECDSA signature, an actor with trusted KMS permissions to decrypt a message may also be able to encrypt messages. This update introduces a new API for callers who wish to stream only unsigned messages. \n\nFor customers who process ESDK messages from untrusted sources, this update also introduces a new configuration to limit the number of Encrypted Data Keys (EDKs) that the ESDK will attempt to process per message. This configuration provides customers with a way to limit the number of AWS KMS Decrypt API calls that the ESDK will make per message. This setting will reject messages with more EDKs than the configured limit.\n\nFinally, this update adds early rejection of invalid messages with certain invalid combinations of algorithm suite and header data.\n\n### Patches\n\nFixed in versions 1.9 and 2.2. We recommend that all users upgrade to address these issues.\n\nCustomers leveraging the ESDK\u2019s streaming features have several options to protect signature validation. One is to ensure that client code reads to the end of the stream before using released plaintext. With this release, using the new API for streaming and falling back to the non-streaming decrypt API for signed messages prevents using any plaintext from signed data before the signature is validated. See https://docs.aws.amazon.com/encryption-sdk/latest/developer-guide/about-versions.html#version2.2.x\n\nUsers processing ESDK messages from untrusted sources should use the new maximum encrypted data keys parameter. See https://docs.aws.amazon.com/encryption-sdk/latest/developer-guide/about-versions.html#version2.2.x\n\n### Workarounds\n\nNone\n\n### For more information\n\nhttps://docs.aws.amazon.com/encryption-sdk/latest/developer-guide/concepts.html#digital-sigs\n\nhttps://docs.aws.amazon.com/encryption-sdk/latest/developer-guide/about-versions.html#version2.2.x\n",
                "fixed_in": [
                    "1.9.0",
                    "2.2.0"
                ],
                "id": "GHSA-x5h4-9gqw-942j",
                "link": "https://osv.dev/vulnerability/GHSA-x5h4-9gqw-942j",
                "source": "osv",
                "summary": null,
                "withdrawn": null
            }
        ]
    },
    "1.3.5": {
        "info": {
            "author": "Amazon Web Services",
            "author_email": "aws-cryptools@amazon.com",
            "bugtrack_url": null,
            "classifiers": [
                "Development Status :: 5 - Production/Stable",
                "Intended Audience :: Developers",
                "License :: OSI Approved :: Apache Software License",
                "Natural Language :: English",
                "Programming Language :: Python",
                "Programming Language :: Python :: 2",
                "Programming Language :: Python :: 2.7",
                "Programming Language :: Python :: 3",
                "Programming Language :: Python :: 3.4",
                "Programming Language :: Python :: Implementation :: CPython",
                "Topic :: Security",
                "Topic :: Security :: Cryptography"
            ],
            "description_content_type": "",
            "docs_url": null,
            "download_url": "",
            "downloads": {
                "last_day": -1,
                "last_month": -1,
                "last_week": -1
            },
            "home_page": "https://github.com/aws/aws-encryption-sdk-python",
            "keywords": "aws-encryption-sdk aws kms encryption",
            "license": "Apache License 2.0",
            "maintainer": "Amazon Web Services",
            "maintainer_email": "",
            "name": "aws-encryption-sdk",
            "package_url": "https://pypi.org/project/aws-encryption-sdk/",
            "platform": "",
            "project_url": "https://pypi.org/project/aws-encryption-sdk/",
            "project_urls": {
                "Homepage": "https://github.com/aws/aws-encryption-sdk-python"
            },
            "release_url": "https://pypi.org/project/aws-encryption-sdk/1.3.5/",
            "requires_dist": [
                "boto3 (>=1.4.4)",
                "cryptography (>=1.8.1)",
                "attrs (>=17.4.0)",
                "wrapt (>=1.10.11)"
            ],
            "requires_python": "",
            "summary": "AWS Encryption SDK implementation for Python",
            "version": "1.3.5",
            "yanked": false,
            "yanked_reason": null
        },
        "last_serial": 14939260,
        "urls": [
            {
                "comment_text": "",
                "digests": {
                    "md5": "c01c32ad96e3d5edbb6553c6e606cd38",
                    "sha256": "539a450a8a4e41b07252a2d8ec645aa37ceb8dd6b6c026e9e5e1fd45e2607a2f"
                },
                "downloads": -1,
                "filename": "aws_encryption_sdk-1.3.5-py2.py3-none-any.whl",
                "has_sig": false,
                "md5_digest": "c01c32ad96e3d5edbb6553c6e606cd38",
                "packagetype": "bdist_wheel",
                "python_version": "py2.py3",
                "requires_python": null,
                "size": 80717,
                "upload_time": "2018-08-01T23:59:45",
                "upload_time_iso_8601": "2018-08-01T23:59:45.639785Z",
                "url": "https://files.pythonhosted.org/packages/a8/1a/3fdeb33296c7b0ead2902f1867c8c84ead601a87f0695266cc02e6e04047/aws_encryption_sdk-1.3.5-py2.py3-none-any.whl",
                "yanked": false,
                "yanked_reason": null
            },
            {
                "comment_text": "",
                "digests": {
                    "md5": "f20ff97f6d37a46231ac64a484387c25",
                    "sha256": "fc77732f95569a51b835d467eb39ae3c0c747eeacb95209379a513b2fdcd8383"
                },
                "downloads": -1,
                "filename": "aws-encryption-sdk-1.3.5.tar.gz",
                "has_sig": false,
                "md5_digest": "f20ff97f6d37a46231ac64a484387c25",
                "packagetype": "sdist",
                "python_version": "source",
                "requires_python": null,
                "size": 121058,
                "upload_time": "2018-08-01T23:59:47",
                "upload_time_iso_8601": "2018-08-01T23:59:47.306908Z",
                "url": "https://files.pythonhosted.org/packages/ec/9b/5897a60d9ed4ed602d988592b4a526763dfee1447b44f720563bd53240d9/aws-encryption-sdk-1.3.5.tar.gz",
                "yanked": false,
                "yanked_reason": null
            }
        ],
        "vulnerabilities": [
            {
                "aliases": [
                    "CVE-2020-8897"
                ],
                "details": "A weak robustness vulnerability exists in the AWS Encryption SDKs for Java, Python, C and Javalcript prior to versions 2.0.0. Due to the non-committing property of AES-GCM (and other AEAD ciphers such as AES-GCM-SIV or (X)ChaCha20Poly1305) used by the SDKs to encrypt messages, an attacker can craft a unique cyphertext which will decrypt to multiple different results, and becomes especially relevant in a multi-recipient setting. We recommend users update their SDK to 2.0.0 or later.",
                "fixed_in": [
                    "2.0.0"
                ],
                "id": "PYSEC-2020-261",
                "link": "https://osv.dev/vulnerability/PYSEC-2020-261",
                "source": "osv",
                "summary": null,
                "withdrawn": null
            },
            {
                "aliases": [
                    "CVE-2020-8897"
                ],
                "details": "Authors: Thai \"[thaidn](https://twitter.com/xorninja)\" Duong\n\n# Summary\n\nThe following security vulnerabilities was discovered and reported to Amazon, affecting AWS KMS and all versions of [AWS Encryption SDKs](https://docs.aws.amazon.com/encryption-sdk/latest/developer-guide/introduction.html) prior to version 2.0.0:\n\n* **Information leakage**: an attacker can create ciphertexts that would leak the user\u2019s AWS account ID, encryption context, user agent, and IP address upon decryption\n* **Ciphertext forgery**: an attacker can create ciphertexts that are accepted by other users\n* **Robustness**: an attacker can create ciphertexts that decrypt to different plaintexts for different users\n\nThe first two bugs are somewhat surprising because they show that the ciphertext format can lead to vulnerabilities. These bugs (and the infamous [alg: \"None\"](https://auth0.com/blog/critical-vulnerabilities-in-json-web-token-libraries/) bugs in JWT) belong to a class of vulnerabilities called **in-band protocol negotiation**. This is the second time we\u2019ve found in-band protocol negotiation vulnerabilities in AWS cryptography libraries; see this [bug](https://github.com/google/security-research/security/advisories/GHSA-7f33-f4f5-xwgw) in S3 Crypto SDK discovered by my colleague Sophie Schmieg.\n\nIn JWT and S3 SDK the culprit is the algorithm field\u2014here it is the key ID. Because the key ID is used to determine which decryption key to use, it can\u2019t be meaningfully authenticated despite being under the attacker\u2019s control. If the key ID is a URL indicating where to fetch the key, the attacker can replace it with their own URL, and learn side-channel information such as the timing and machines on which the decryption happens (this can also lead to [SSRF](https://portswigger.net/web-security/ssrf) issues, but that\u2019s another topic for another day).\n\nIn AWS, the key ID is a unique [Amazon Resource Name](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html). If an attacker were to capture a ciphertext from a user and replace its key ID with their own, the victim\u2019s AWS account ID, encryption context, user agent, and IP address would be logged to the attacker\u2019s AWS account whenever the victim attempted to decrypt the modified ciphertext.\n\nThe last bug shows that the non-committing property of AES-GCM (and other AEAD ciphers such as [AES-GCM-SIV](https://keymaterial.net/2020/09/07/invisible-salamanders-in-aes-gcm-siv/) or (X)ChaCha20Poly1305) is especially problematic in multi-recipient settings. These ciphers have a property that can cause nonidentical plaintexts when decrypting a single ciphertext with two different keys! For example, you can send a single encrypted email to Alice and Bob which, upon decryption, reads \u201cattack\u201d to Alice and \u201cretreat\u201d to Bob. The AWS Encryption SDKs are vulnerable to this attack because they allow a single ciphertext to be generated for multiple recipients, with each decrypting using a different key. I believe this kind of problem is prevalent. I briefly looked at [JWE](https://tools.ietf.org/html/rfc7516) and I think it is vulnerable.\n\n# Mitigations\n\nAmazon has fixed these bugs in release 2.0.0 of the SDKs. A new major version was required because, unfortunately, the fix for the last bug requires a breaking change from earlier versions. All users are recommended to upgrade. More details about Amazon\u2019s mitigations can be found in [their announcement](https://aws.amazon.com/blogs/security/improved-client-side-encryption-explicit-keyids-and-key-commitment/).\n\nWe\u2019re collaborating with Shay Gueron on a paper regarding fast committing AEADs.\n\n# Vulnerabilities\n\n## Information Leakage\n\nThe [Encrypt](https://docs.aws.amazon.com/kms/latest/APIReference/API_Encrypt.html) API in AWS KMS encrypts plaintext into ciphertext by using a customer master key (CMK). The ciphertext format is undocumented, but it contains metadata that specifies the CMK and the encryption algorithm. I reverse-engineered the format and found the location of the CMK. Externally the CMK is identified by its key ARN, but within a ciphertext it is represented by an internal ID, which remained stable during my testing.\n\nWhen I replaced the internal ID of a CMK in a ciphertext with the internal ID of another CMK, I found that AWS KMS attempted to decrypt the ciphertext with the new CMK. The encryption failed and the failure event\u2014including the AWS Account ID, the user agent and the IP address of the caller\u2014was logged to Cloud Trail in the account that owned the replacement CMK.\n\nThis enables the following attack:\n* The attacker creates a CMK that has a key policy that allows access from everyone. This requires no prior knowledge about the victim.\n* The attacker intercepts a ciphertext from the victim, and replaces its CMK with their CMK.\n* Whenever the victim attempts to decrypt the modified ciphertext, the attacker learns the timing of such actions, the victim\u2019s AWS Account ID, user agent, encryption context, and IP address.\n\nThis attack requires the victim to have an IAM policy that allows them to access the attacker\u2019s CMK. I found that this practice was allowed by the AWS Visual Policy Editor, but I don\u2019t know whether it is common.\n\nThe AWS Encryption SDKs also succumb to this attack. The SDKs implement envelope encryption: encrypting data with a data encryption key (DEK) and then wrapping the DEK with a CMK using the Encrypt API in AWS KMS. The wrapped DEK is stored as part of the final ciphertext (format is defined [here](https://docs.aws.amazon.com/encryption-sdk/latest/developer-guide/message-format.html)). The attacker can mount this attack by replacing the CMK in the wrapped DEK with their own.\n\n```\n{\n    \"eventVersion\": \"1.05\",\n    \"userIdentity\": {\n        \"type\": \"AWSAccount\",\n        \"principalId\": \"<redacted this is the principal ID of the victim>\",\n        \"accountId\": \"<redacted - this is the AWS account ID of the victim>\"\n    },\n    \"eventTime\": \"2020-06-21T21:05:04Z\",\n    \"eventSource\": \"kms.amazonaws.com\",\n    \"eventName\": \"Decrypt\",\n    \"awsRegion\": \"us-west-2\",\n    \"sourceIPAddress\": \"<redacted - this is the IP address of the victim>\",\n    \"userAgent\": \"<redacted - this is the user agent of the victim>\",\n    \"errorCode\": \"InvalidCiphertextException\",\n    \"requestParameters\": {\n        // The encryption context might include other data from the victim\n        \"encryptionContext\": {\n            \"aws-crypto-public-key\": \"AzfNOGOnNYFmpHspKrAm1L6XtRybONkmkhmB/IriKSA7b2NsV4MEPMph9yX2KTPKWw==\"\n        },\n        \"encryptionAlgorithm\": \"SYMMETRIC_DEFAULT\"\n    },\n    \"responseElements\": null,\n    \"requestID\": \"aeced8e8-75a2-42c3-96ac-d1fa2a1c5ee6\",\n    \"eventID\": \"780a0a6e-4ad8-43d4-a426-75d05022f870\",\n    \"readOnly\": true,\n    \"resources\": [\n        {\n            \"accountId\": \"<redacted - this is the account ID of the attacker>\",\n            \"type\": \"AWS::KMS::Key\",\n            \"ARN\": <redacted - this is the key ARN of the attacker>\n        }\n    ],\n    \"eventType\": \"AwsApiCall\",\n    \"recipientAccountId\": \"<redacted - this is the account ID of the attacker>\",\n    \"sharedEventID\": \"033e147c-8a36-42f5-9d6c-9e071eb752b7\"\n}\n```\n**Figure 1: A failure event logged to the attacker\u2019s Cloud Trail when the victim attempted to decrypt a modified ciphertext containing the attacker\u2019s CMK.**\n\n## Ciphertext Forgery\n\nThe [Decrypt](https://docs.aws.amazon.com/kms/latest/APIReference/API_Decrypt.html) API in AWS KMS doesn\u2019t require the caller to specify the CMK. This parameter is required only when the ciphertext was encrypted under an asymmetric CMK. Otherwise, AWS KMS uses the metadata that it adds to the ciphertext blob to determine which CMK was used to encrypt the ciphertext.\n\nThis leads to the following attack:\n* The attacker creates a CMK that has a key policy that allows access from everyone. This requires no prior knowledge about the victim.\n* The attacker generates a ciphertext by calling the Encrypt API with their key.\n* The attacker intercepts a ciphertext from the victim, and replaces it entirely with their ciphertext.\n* The victim successfully decrypts the ciphertext, as if it was encrypted under their own key. The attacker also learns when this happened, the victim\u2019s AWS Account ID, user agent, encryption context, and IP address.\n\nSimilar to the information leakage attack, this attack also requires the victim to have an IAM policy that allows them to access the attacker\u2019s CMK.\n\nThe AWS Encryption SDKs also succumb to this attack. They don\u2019t specify the CMK when they call the Decrypt API to unwrap the DEK.\n\n## Robustness\n\nThe AWS Encryption SDKs allow a single ciphertext to be generated for multiple recipients, with each decrypting using a different key. To that end, it wraps the DEK multiple times, each under a different CMK. The wrapped DEKs can be combined to form a single ciphertext which can be sent to multiple recipients who can use their own credentials to decrypt it. It\u2019s reasonable to expect that all recipients should decrypt the ciphertext to an identical plaintext. However, because of the use of AES-GMAC and AES-GCM, it\u2019s possible to create a ciphertext that decrypts to two valid yet different plaintexts for two different users. In other words, the AWS Encryption SDKs are [not](https://eprint.iacr.org/2008/440.pdf) [robust](https://eprint.iacr.org/2019/016.pdf).\n\nThe encryption of a message under two CMKs can be summarized as follows:\n* A DEK is randomly generated, and two wrapped DEKs are produced by calling the Encrypt API using the two CMKs\n* A per-message AES-GCM key (K) is derived using HKDF from the DEK, a randomly generated message ID, and a fixed algorithm ID.\n* A header is formed from the wrapped DEKs, the encryption context, and other metadata. A header authentication tag is computed on the header using AES-GMAC with K and a zero IV.\n* The message is encrypted using AES-GCM with K, a non-zero IV, and fixed associated additional data. This produces a message authentication tag.\n* The ciphertext consists of the header, the header authentication tag, the encrypted message, and the message authentication tag.\n\n(There\u2019s also a self-signed digital signature that is irrelevant to this discussion).\n\nIn order to decrypt a ciphertext, the AWS Encryption SDKs loops over the list of wrapped DEKs and returns the first one that it can successfully unwrap. The attacker therefore can wrap a unique DEK for each recipient. Next, the attacker exploits the non-committing property of GMAC to produce two messages that have the same GMAC tag under two different keys. The attacker has to do this twice, one for the header authentication tag and one for the message authentication tag.\n\n```\nGiven a data blob B of one 128-bit block B_1, a GMAC tag is computed as follows:\n\nB_1 * H^2 + B_len * H + J\n\nwhere H and J depends on the key and B_len depends on the length of B.\n\nTo find a message that can produce the same tag under two different keys, one\ncan add append to B a new block B_2 whose value can be deduced by solving\nan algebraic equation. That is, we want to find B_2 such that:\n\nB_1 * H^3 + B_2 * H^2 + B_len * H + J = B_1 * H\u2019^3 + B_2 * H\u2019^2 + B_len * H\u2019 + J\u2019\n\nwhere H\u2019 and J\u2019 are the corresponding H and J of the other key.\n\nB_2 is the only unknown value in this equation, thus it can be computed using\nfinite field arithmetics of GF(2^128):\n\nB_2 = [B_1 * (H^3+H\u2019^3) + B_len * (H + H\u2019) + J + J\u2019] * (H^2 + H\u2019^2)^-1.\n```\n**Figure 2: How to find a message that has the same GMAC tag under two different keys.**\n\nThe overall attack works as follows:\n* The attacker generates a random DEK, derives a per-message key K, and encrypts message M with it using AES in counter mode. This generates a ciphertext C.\n* The attacker generates another random DEK\u2019, derives a per-message key K\u2019, and performs trial decryption of C until the decrypted message M\u2019 has desirable properties. For example, if the attacker wants the first bit of M\u2019 different from that of M, this process should only take a few attempts.\n* The attacker finds a block C* such that the GMAC of C\u2019 = C || C* under K and K\u2019 are identical. Denote this tag C\u2019_tag.\n* The attacker wraps DEK and DEK\u2019 under two recipients\u2019 CMK.\n* The attacker forms a header H and adds a block H* to the encryption context such that the new H\u2019 has the same authentication tag H\u2019_tag under K and K\u2019.\n* The attacker output H\u2019, H\u2019_tag, C\u2019, C\u2019_tag.\n\nThis attack is similar to the one discovered in [Facebook Messenger](https://eprint.iacr.org/2019/016.pdf).\n\n# Acknowledgement\n\nI\u2019m grateful to Jen Barnason for carefully editing this advisory. I will never publish anything without her approval! I want to thank my friend and coworker Sophie \u201cQueen of Hashing\u201d Schmieg for wonderful discussions and for showing me how the arithmetic in GF(2^128) works. I want to thank Jonathan Bannet for asking the questions that led to this work.",
                "fixed_in": [
                    "2.0.0"
                ],
                "id": "GHSA-wqgp-vphw-hphf",
                "link": "https://osv.dev/vulnerability/GHSA-wqgp-vphw-hphf",
                "source": "osv",
                "summary": null,
                "withdrawn": null
            },
            {
                "aliases": [],
                "details": "### Impact\n\nThis advisory addresses several LOW severity issues with streaming signed messages and restricting processing of certain types of invalid messages. \n\nThis ESDK supports a streaming mode where callers may stream the plaintext of signed messages before the ECDSA signature is validated. In addition to these signatures, the ESDK uses AES-GCM encryption and all plaintext is verified before being released to a caller. There is no impact on the integrity of the ciphertext or decrypted plaintext, however some callers may rely on the the ECDSA signature for non-repudiation. Without validating the ECDSA signature, an actor with trusted KMS permissions to decrypt a message may also be able to encrypt messages. This update introduces a new API for callers who wish to stream only unsigned messages. \n\nFor customers who process ESDK messages from untrusted sources, this update also introduces a new configuration to limit the number of Encrypted Data Keys (EDKs) that the ESDK will attempt to process per message. This configuration provides customers with a way to limit the number of AWS KMS Decrypt API calls that the ESDK will make per message. This setting will reject messages with more EDKs than the configured limit.\n\nFinally, this update adds early rejection of invalid messages with certain invalid combinations of algorithm suite and header data.\n\n### Patches\n\nFixed in versions 1.9 and 2.2. We recommend that all users upgrade to address these issues.\n\nCustomers leveraging the ESDK\u2019s streaming features have several options to protect signature validation. One is to ensure that client code reads to the end of the stream before using released plaintext. With this release, using the new API for streaming and falling back to the non-streaming decrypt API for signed messages prevents using any plaintext from signed data before the signature is validated. See https://docs.aws.amazon.com/encryption-sdk/latest/developer-guide/about-versions.html#version2.2.x\n\nUsers processing ESDK messages from untrusted sources should use the new maximum encrypted data keys parameter. See https://docs.aws.amazon.com/encryption-sdk/latest/developer-guide/about-versions.html#version2.2.x\n\n### Workarounds\n\nNone\n\n### For more information\n\nhttps://docs.aws.amazon.com/encryption-sdk/latest/developer-guide/concepts.html#digital-sigs\n\nhttps://docs.aws.amazon.com/encryption-sdk/latest/developer-guide/about-versions.html#version2.2.x\n",
                "fixed_in": [
                    "1.9.0",
                    "2.2.0"
                ],
                "id": "GHSA-x5h4-9gqw-942j",
                "link": "https://osv.dev/vulnerability/GHSA-x5h4-9gqw-942j",
                "source": "osv",
                "summary": null,
                "withdrawn": null
            }
        ]
    },
    "1.3.6": {
        "info": {
            "author": "Amazon Web Services",
            "author_email": "aws-cryptools@amazon.com",
            "bugtrack_url": null,
            "classifiers": [
                "Development Status :: 5 - Production/Stable",
                "Intended Audience :: Developers",
                "License :: OSI Approved :: Apache Software License",
                "Natural Language :: English",
                "Programming Language :: Python",
                "Programming Language :: Python :: 2",
                "Programming Language :: Python :: 2.7",
                "Programming Language :: Python :: 3",
                "Programming Language :: Python :: 3.4",
                "Programming Language :: Python :: 3.5",
                "Programming Language :: Python :: 3.6",
                "Programming Language :: Python :: 3.7",
                "Programming Language :: Python :: Implementation :: CPython",
                "Topic :: Security",
                "Topic :: Security :: Cryptography"
            ],
            "description_content_type": "",
            "docs_url": null,
            "download_url": "",
            "downloads": {
                "last_day": -1,
                "last_month": -1,
                "last_week": -1
            },
            "home_page": "https://github.com/aws/aws-encryption-sdk-python",
            "keywords": "aws-encryption-sdk aws kms encryption",
            "license": "Apache License 2.0",
            "maintainer": "Amazon Web Services",
            "maintainer_email": "",
            "name": "aws-encryption-sdk",
            "package_url": "https://pypi.org/project/aws-encryption-sdk/",
            "platform": "",
            "project_url": "https://pypi.org/project/aws-encryption-sdk/",
            "project_urls": {
                "Homepage": "https://github.com/aws/aws-encryption-sdk-python"
            },
            "release_url": "https://pypi.org/project/aws-encryption-sdk/1.3.6/",
            "requires_dist": [
                "boto3 (>=1.4.4)",
                "cryptography (>=1.8.1)",
                "attrs (>=17.4.0)",
                "wrapt (>=1.10.11)"
            ],
            "requires_python": "",
            "summary": "AWS Encryption SDK implementation for Python",
            "version": "1.3.6",
            "yanked": false,
            "yanked_reason": null
        },
        "last_serial": 14939260,
        "urls": [
            {
                "comment_text": "",
                "digests": {
                    "md5": "ed5eeade5fc81ee2dc63a7a81e575444",
                    "sha256": "68052e3164aa25d808b4a8215db0721d3cc0d669b7a06323087c3a8d4c3139bd"
                },
                "downloads": -1,
                "filename": "aws_encryption_sdk-1.3.6-py2.py3-none-any.whl",
                "has_sig": false,
                "md5_digest": "ed5eeade5fc81ee2dc63a7a81e575444",
                "packagetype": "bdist_wheel",
                "python_version": "py2.py3",
                "requires_python": null,
                "size": 81072,
                "upload_time": "2018-09-04T22:12:39",
                "upload_time_iso_8601": "2018-09-04T22:12:39.577767Z",
                "url": "https://files.pythonhosted.org/packages/b1/a9/a8ff76a7ee0772508e929ac642ecb7b856282bb32625ea25bcdc89ceffa4/aws_encryption_sdk-1.3.6-py2.py3-none-any.whl",
                "yanked": false,
                "yanked_reason": null
            },
            {
                "comment_text": "",
                "digests": {
                    "md5": "200f1764d3f890881690aadde5346b8c",
                    "sha256": "2ffb5d37729dee1bc00fa1577a8f6811e4fb5a4ab89a4429908aa4594f2615cf"
                },
                "downloads": -1,
                "filename": "aws-encryption-sdk-1.3.6.tar.gz",
                "has_sig": false,
                "md5_digest": "200f1764d3f890881690aadde5346b8c",
                "packagetype": "sdist",
                "python_version": "source",
                "requires_python": null,
                "size": 6159176,
                "upload_time": "2018-09-04T22:12:44",
                "upload_time_iso_8601": "2018-09-04T22:12:44.541317Z",
                "url": "https://files.pythonhosted.org/packages/0a/ca/132c066157d0264d68d92f0fdf4c1ce0571a5f121c3bf89632dc97aa6788/aws-encryption-sdk-1.3.6.tar.gz",
                "yanked": false,
                "yanked_reason": null
            }
        ],
        "vulnerabilities": [
            {
                "aliases": [
                    "CVE-2020-8897"
                ],
                "details": "A weak robustness vulnerability exists in the AWS Encryption SDKs for Java, Python, C and Javalcript prior to versions 2.0.0. Due to the non-committing property of AES-GCM (and other AEAD ciphers such as AES-GCM-SIV or (X)ChaCha20Poly1305) used by the SDKs to encrypt messages, an attacker can craft a unique cyphertext which will decrypt to multiple different results, and becomes especially relevant in a multi-recipient setting. We recommend users update their SDK to 2.0.0 or later.",
                "fixed_in": [
                    "2.0.0"
                ],
                "id": "PYSEC-2020-261",
                "link": "https://osv.dev/vulnerability/PYSEC-2020-261",
                "source": "osv",
                "summary": null,
                "withdrawn": null
            },
            {
                "aliases": [
                    "CVE-2020-8897"
                ],
                "details": "Authors: Thai \"[thaidn](https://twitter.com/xorninja)\" Duong\n\n# Summary\n\nThe following security vulnerabilities was discovered and reported to Amazon, affecting AWS KMS and all versions of [AWS Encryption SDKs](https://docs.aws.amazon.com/encryption-sdk/latest/developer-guide/introduction.html) prior to version 2.0.0:\n\n* **Information leakage**: an attacker can create ciphertexts that would leak the user\u2019s AWS account ID, encryption context, user agent, and IP address upon decryption\n* **Ciphertext forgery**: an attacker can create ciphertexts that are accepted by other users\n* **Robustness**: an attacker can create ciphertexts that decrypt to different plaintexts for different users\n\nThe first two bugs are somewhat surprising because they show that the ciphertext format can lead to vulnerabilities. These bugs (and the infamous [alg: \"None\"](https://auth0.com/blog/critical-vulnerabilities-in-json-web-token-libraries/) bugs in JWT) belong to a class of vulnerabilities called **in-band protocol negotiation**. This is the second time we\u2019ve found in-band protocol negotiation vulnerabilities in AWS cryptography libraries; see this [bug](https://github.com/google/security-research/security/advisories/GHSA-7f33-f4f5-xwgw) in S3 Crypto SDK discovered by my colleague Sophie Schmieg.\n\nIn JWT and S3 SDK the culprit is the algorithm field\u2014here it is the key ID. Because the key ID is used to determine which decryption key to use, it can\u2019t be meaningfully authenticated despite being under the attacker\u2019s control. If the key ID is a URL indicating where to fetch the key, the attacker can replace it with their own URL, and learn side-channel information such as the timing and machines on which the decryption happens (this can also lead to [SSRF](https://portswigger.net/web-security/ssrf) issues, but that\u2019s another topic for another day).\n\nIn AWS, the key ID is a unique [Amazon Resource Name](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html). If an attacker were to capture a ciphertext from a user and replace its key ID with their own, the victim\u2019s AWS account ID, encryption context, user agent, and IP address would be logged to the attacker\u2019s AWS account whenever the victim attempted to decrypt the modified ciphertext.\n\nThe last bug shows that the non-committing property of AES-GCM (and other AEAD ciphers such as [AES-GCM-SIV](https://keymaterial.net/2020/09/07/invisible-salamanders-in-aes-gcm-siv/) or (X)ChaCha20Poly1305) is especially problematic in multi-recipient settings. These ciphers have a property that can cause nonidentical plaintexts when decrypting a single ciphertext with two different keys! For example, you can send a single encrypted email to Alice and Bob which, upon decryption, reads \u201cattack\u201d to Alice and \u201cretreat\u201d to Bob. The AWS Encryption SDKs are vulnerable to this attack because they allow a single ciphertext to be generated for multiple recipients, with each decrypting using a different key. I believe this kind of problem is prevalent. I briefly looked at [JWE](https://tools.ietf.org/html/rfc7516) and I think it is vulnerable.\n\n# Mitigations\n\nAmazon has fixed these bugs in release 2.0.0 of the SDKs. A new major version was required because, unfortunately, the fix for the last bug requires a breaking change from earlier versions. All users are recommended to upgrade. More details about Amazon\u2019s mitigations can be found in [their announcement](https://aws.amazon.com/blogs/security/improved-client-side-encryption-explicit-keyids-and-key-commitment/).\n\nWe\u2019re collaborating with Shay Gueron on a paper regarding fast committing AEADs.\n\n# Vulnerabilities\n\n## Information Leakage\n\nThe [Encrypt](https://docs.aws.amazon.com/kms/latest/APIReference/API_Encrypt.html) API in AWS KMS encrypts plaintext into ciphertext by using a customer master key (CMK). The ciphertext format is undocumented, but it contains metadata that specifies the CMK and the encryption algorithm. I reverse-engineered the format and found the location of the CMK. Externally the CMK is identified by its key ARN, but within a ciphertext it is represented by an internal ID, which remained stable during my testing.\n\nWhen I replaced the internal ID of a CMK in a ciphertext with the internal ID of another CMK, I found that AWS KMS attempted to decrypt the ciphertext with the new CMK. The encryption failed and the failure event\u2014including the AWS Account ID, the user agent and the IP address of the caller\u2014was logged to Cloud Trail in the account that owned the replacement CMK.\n\nThis enables the following attack:\n* The attacker creates a CMK that has a key policy that allows access from everyone. This requires no prior knowledge about the victim.\n* The attacker intercepts a ciphertext from the victim, and replaces its CMK with their CMK.\n* Whenever the victim attempts to decrypt the modified ciphertext, the attacker learns the timing of such actions, the victim\u2019s AWS Account ID, user agent, encryption context, and IP address.\n\nThis attack requires the victim to have an IAM policy that allows them to access the attacker\u2019s CMK. I found that this practice was allowed by the AWS Visual Policy Editor, but I don\u2019t know whether it is common.\n\nThe AWS Encryption SDKs also succumb to this attack. The SDKs implement envelope encryption: encrypting data with a data encryption key (DEK) and then wrapping the DEK with a CMK using the Encrypt API in AWS KMS. The wrapped DEK is stored as part of the final ciphertext (format is defined [here](https://docs.aws.amazon.com/encryption-sdk/latest/developer-guide/message-format.html)). The attacker can mount this attack by replacing the CMK in the wrapped DEK with their own.\n\n```\n{\n    \"eventVersion\": \"1.05\",\n    \"userIdentity\": {\n        \"type\": \"AWSAccount\",\n        \"principalId\": \"<redacted this is the principal ID of the victim>\",\n        \"accountId\": \"<redacted - this is the AWS account ID of the victim>\"\n    },\n    \"eventTime\": \"2020-06-21T21:05:04Z\",\n    \"eventSource\": \"kms.amazonaws.com\",\n    \"eventName\": \"Decrypt\",\n    \"awsRegion\": \"us-west-2\",\n    \"sourceIPAddress\": \"<redacted - this is the IP address of the victim>\",\n    \"userAgent\": \"<redacted - this is the user agent of the victim>\",\n    \"errorCode\": \"InvalidCiphertextException\",\n    \"requestParameters\": {\n        // The encryption context might include other data from the victim\n        \"encryptionContext\": {\n            \"aws-crypto-public-key\": \"AzfNOGOnNYFmpHspKrAm1L6XtRybONkmkhmB/IriKSA7b2NsV4MEPMph9yX2KTPKWw==\"\n        },\n        \"encryptionAlgorithm\": \"SYMMETRIC_DEFAULT\"\n    },\n    \"responseElements\": null,\n    \"requestID\": \"aeced8e8-75a2-42c3-96ac-d1fa2a1c5ee6\",\n    \"eventID\": \"780a0a6e-4ad8-43d4-a426-75d05022f870\",\n    \"readOnly\": true,\n    \"resources\": [\n        {\n            \"accountId\": \"<redacted - this is the account ID of the attacker>\",\n            \"type\": \"AWS::KMS::Key\",\n            \"ARN\": <redacted - this is the key ARN of the attacker>\n        }\n    ],\n    \"eventType\": \"AwsApiCall\",\n    \"recipientAccountId\": \"<redacted - this is the account ID of the attacker>\",\n    \"sharedEventID\": \"033e147c-8a36-42f5-9d6c-9e071eb752b7\"\n}\n```\n**Figure 1: A failure event logged to the attacker\u2019s Cloud Trail when the victim attempted to decrypt a modified ciphertext containing the attacker\u2019s CMK.**\n\n## Ciphertext Forgery\n\nThe [Decrypt](https://docs.aws.amazon.com/kms/latest/APIReference/API_Decrypt.html) API in AWS KMS doesn\u2019t require the caller to specify the CMK. This parameter is required only when the ciphertext was encrypted under an asymmetric CMK. Otherwise, AWS KMS uses the metadata that it adds to the ciphertext blob to determine which CMK was used to encrypt the ciphertext.\n\nThis leads to the following attack:\n* The attacker creates a CMK that has a key policy that allows access from everyone. This requires no prior knowledge about the victim.\n* The attacker generates a ciphertext by calling the Encrypt API with their key.\n* The attacker intercepts a ciphertext from the victim, and replaces it entirely with their ciphertext.\n* The victim successfully decrypts the ciphertext, as if it was encrypted under their own key. The attacker also learns when this happened, the victim\u2019s AWS Account ID, user agent, encryption context, and IP address.\n\nSimilar to the information leakage attack, this attack also requires the victim to have an IAM policy that allows them to access the attacker\u2019s CMK.\n\nThe AWS Encryption SDKs also succumb to this attack. They don\u2019t specify the CMK when they call the Decrypt API to unwrap the DEK.\n\n## Robustness\n\nThe AWS Encryption SDKs allow a single ciphertext to be generated for multiple recipients, with each decrypting using a different key. To that end, it wraps the DEK multiple times, each under a different CMK. The wrapped DEKs can be combined to form a single ciphertext which can be sent to multiple recipients who can use their own credentials to decrypt it. It\u2019s reasonable to expect that all recipients should decrypt the ciphertext to an identical plaintext. However, because of the use of AES-GMAC and AES-GCM, it\u2019s possible to create a ciphertext that decrypts to two valid yet different plaintexts for two different users. In other words, the AWS Encryption SDKs are [not](https://eprint.iacr.org/2008/440.pdf) [robust](https://eprint.iacr.org/2019/016.pdf).\n\nThe encryption of a message under two CMKs can be summarized as follows:\n* A DEK is randomly generated, and two wrapped DEKs are produced by calling the Encrypt API using the two CMKs\n* A per-message AES-GCM key (K) is derived using HKDF from the DEK, a randomly generated message ID, and a fixed algorithm ID.\n* A header is formed from the wrapped DEKs, the encryption context, and other metadata. A header authentication tag is computed on the header using AES-GMAC with K and a zero IV.\n* The message is encrypted using AES-GCM with K, a non-zero IV, and fixed associated additional data. This produces a message authentication tag.\n* The ciphertext consists of the header, the header authentication tag, the encrypted message, and the message authentication tag.\n\n(There\u2019s also a self-signed digital signature that is irrelevant to this discussion).\n\nIn order to decrypt a ciphertext, the AWS Encryption SDKs loops over the list of wrapped DEKs and returns the first one that it can successfully unwrap. The attacker therefore can wrap a unique DEK for each recipient. Next, the attacker exploits the non-committing property of GMAC to produce two messages that have the same GMAC tag under two different keys. The attacker has to do this twice, one for the header authentication tag and one for the message authentication tag.\n\n```\nGiven a data blob B of one 128-bit block B_1, a GMAC tag is computed as follows:\n\nB_1 * H^2 + B_len * H + J\n\nwhere H and J depends on the key and B_len depends on the length of B.\n\nTo find a message that can produce the same tag under two different keys, one\ncan add append to B a new block B_2 whose value can be deduced by solving\nan algebraic equation. That is, we want to find B_2 such that:\n\nB_1 * H^3 + B_2 * H^2 + B_len * H + J = B_1 * H\u2019^3 + B_2 * H\u2019^2 + B_len * H\u2019 + J\u2019\n\nwhere H\u2019 and J\u2019 are the corresponding H and J of the other key.\n\nB_2 is the only unknown value in this equation, thus it can be computed using\nfinite field arithmetics of GF(2^128):\n\nB_2 = [B_1 * (H^3+H\u2019^3) + B_len * (H + H\u2019) + J + J\u2019] * (H^2 + H\u2019^2)^-1.\n```\n**Figure 2: How to find a message that has the same GMAC tag under two different keys.**\n\nThe overall attack works as follows:\n* The attacker generates a random DEK, derives a per-message key K, and encrypts message M with it using AES in counter mode. This generates a ciphertext C.\n* The attacker generates another random DEK\u2019, derives a per-message key K\u2019, and performs trial decryption of C until the decrypted message M\u2019 has desirable properties. For example, if the attacker wants the first bit of M\u2019 different from that of M, this process should only take a few attempts.\n* The attacker finds a block C* such that the GMAC of C\u2019 = C || C* under K and K\u2019 are identical. Denote this tag C\u2019_tag.\n* The attacker wraps DEK and DEK\u2019 under two recipients\u2019 CMK.\n* The attacker forms a header H and adds a block H* to the encryption context such that the new H\u2019 has the same authentication tag H\u2019_tag under K and K\u2019.\n* The attacker output H\u2019, H\u2019_tag, C\u2019, C\u2019_tag.\n\nThis attack is similar to the one discovered in [Facebook Messenger](https://eprint.iacr.org/2019/016.pdf).\n\n# Acknowledgement\n\nI\u2019m grateful to Jen Barnason for carefully editing this advisory. I will never publish anything without her approval! I want to thank my friend and coworker Sophie \u201cQueen of Hashing\u201d Schmieg for wonderful discussions and for showing me how the arithmetic in GF(2^128) works. I want to thank Jonathan Bannet for asking the questions that led to this work.",
                "fixed_in": [
                    "2.0.0"
                ],
                "id": "GHSA-wqgp-vphw-hphf",
                "link": "https://osv.dev/vulnerability/GHSA-wqgp-vphw-hphf",
                "source": "osv",
                "summary": null,
                "withdrawn": null
            },
            {
                "aliases": [],
                "details": "### Impact\n\nThis advisory addresses several LOW severity issues with streaming signed messages and restricting processing of certain types of invalid messages. \n\nThis ESDK supports a streaming mode where callers may stream the plaintext of signed messages before the ECDSA signature is validated. In addition to these signatures, the ESDK uses AES-GCM encryption and all plaintext is verified before being released to a caller. There is no impact on the integrity of the ciphertext or decrypted plaintext, however some callers may rely on the the ECDSA signature for non-repudiation. Without validating the ECDSA signature, an actor with trusted KMS permissions to decrypt a message may also be able to encrypt messages. This update introduces a new API for callers who wish to stream only unsigned messages. \n\nFor customers who process ESDK messages from untrusted sources, this update also introduces a new configuration to limit the number of Encrypted Data Keys (EDKs) that the ESDK will attempt to process per message. This configuration provides customers with a way to limit the number of AWS KMS Decrypt API calls that the ESDK will make per message. This setting will reject messages with more EDKs than the configured limit.\n\nFinally, this update adds early rejection of invalid messages with certain invalid combinations of algorithm suite and header data.\n\n### Patches\n\nFixed in versions 1.9 and 2.2. We recommend that all users upgrade to address these issues.\n\nCustomers leveraging the ESDK\u2019s streaming features have several options to protect signature validation. One is to ensure that client code reads to the end of the stream before using released plaintext. With this release, using the new API for streaming and falling back to the non-streaming decrypt API for signed messages prevents using any plaintext from signed data before the signature is validated. See https://docs.aws.amazon.com/encryption-sdk/latest/developer-guide/about-versions.html#version2.2.x\n\nUsers processing ESDK messages from untrusted sources should use the new maximum encrypted data keys parameter. See https://docs.aws.amazon.com/encryption-sdk/latest/developer-guide/about-versions.html#version2.2.x\n\n### Workarounds\n\nNone\n\n### For more information\n\nhttps://docs.aws.amazon.com/encryption-sdk/latest/developer-guide/concepts.html#digital-sigs\n\nhttps://docs.aws.amazon.com/encryption-sdk/latest/developer-guide/about-versions.html#version2.2.x\n",
                "fixed_in": [
                    "1.9.0",
                    "2.2.0"
                ],
                "id": "GHSA-x5h4-9gqw-942j",
                "link": "https://osv.dev/vulnerability/GHSA-x5h4-9gqw-942j",
                "source": "osv",
                "summary": null,
                "withdrawn": null
            }
        ]
    },
    "1.3.7": {
        "info": {
            "author": "Amazon Web Services",
            "author_email": "aws-cryptools@amazon.com",
            "bugtrack_url": null,
            "classifiers": [
                "Development Status :: 5 - Production/Stable",
                "Intended Audience :: Developers",
                "License :: OSI Approved :: Apache Software License",
                "Natural Language :: English",
                "Programming Language :: Python",
                "Programming Language :: Python :: 2",
                "Programming Language :: Python :: 2.7",
                "Programming Language :: Python :: 3",
                "Programming Language :: Python :: 3.4",
                "Programming Language :: Python :: 3.5",
                "Programming Language :: Python :: 3.6",
                "Programming Language :: Python :: 3.7",
                "Programming Language :: Python :: Implementation :: CPython",
                "Topic :: Security",
                "Topic :: Security :: Cryptography"
            ],
            "description_content_type": "",
            "docs_url": null,
            "download_url": "",
            "downloads": {
                "last_day": -1,
                "last_month": -1,
                "last_week": -1
            },
            "home_page": "https://github.com/aws/aws-encryption-sdk-python",
            "keywords": "aws-encryption-sdk aws kms encryption",
            "license": "Apache License 2.0",
            "maintainer": "Amazon Web Services",
            "maintainer_email": "",
            "name": "aws-encryption-sdk",
            "package_url": "https://pypi.org/project/aws-encryption-sdk/",
            "platform": "",
            "project_url": "https://pypi.org/project/aws-encryption-sdk/",
            "project_urls": {
                "Homepage": "https://github.com/aws/aws-encryption-sdk-python"
            },
            "release_url": "https://pypi.org/project/aws-encryption-sdk/1.3.7/",
            "requires_dist": [
                "boto3 (>=1.4.4)",
                "cryptography (>=1.8.1)",
                "attrs (>=17.4.0)",
                "wrapt (>=1.10.11)"
            ],
            "requires_python": "",
            "summary": "AWS Encryption SDK implementation for Python",
            "version": "1.3.7",
            "yanked": false,
            "yanked_reason": null
        },
        "last_serial": 14939260,
        "urls": [
            {
                "comment_text": "",
                "digests": {
                    "md5": "8ffce42ca95547219c20ed0a9b49d849",
                    "sha256": "f55fca446abe936ddbd8788fd836c52bc7c2210aba5b3474513b93c0e6c20be4"
                },
                "downloads": -1,
                "filename": "aws_encryption_sdk-1.3.7-py2.py3-none-any.whl",
                "has_sig": false,
                "md5_digest": "8ffce42ca95547219c20ed0a9b49d849",
                "packagetype": "bdist_wheel",
                "python_version": "py2.py3",
                "requires_python": null,
                "size": 84045,
                "upload_time": "2018-09-20T19:10:13",
                "upload_time_iso_8601": "2018-09-20T19:10:13.182285Z",
                "url": "https://files.pythonhosted.org/packages/b9/5f/525aa22a6e3e1b2967f44915c2d03086002e13f0f54384b8a75ba85762fe/aws_encryption_sdk-1.3.7-py2.py3-none-any.whl",
                "yanked": false,
                "yanked_reason": null
            },
            {
                "comment_text": "",
                "digests": {
                    "md5": "ccacea68f341e580998ce0b170b104c1",
                    "sha256": "909307d2def005c7fa2826db806a498fb51409192bba9feae5caf68bed10d383"
                },
                "downloads": -1,
                "filename": "aws-encryption-sdk-1.3.7.tar.gz",
                "has_sig": false,
                "md5_digest": "ccacea68f341e580998ce0b170b104c1",
                "packagetype": "sdist",
                "python_version": "source",
                "requires_python": null,
                "size": 7921808,
                "upload_time": "2018-09-20T19:10:16",
                "upload_time_iso_8601": "2018-09-20T19:10:16.651089Z",
                "url": "https://files.pythonhosted.org/packages/2a/f7/ccd8bd22a023e5805397f64c20894f27db4fe37e3c12343ff85badc5c68b/aws-encryption-sdk-1.3.7.tar.gz",
                "yanked": false,
                "yanked_reason": null
            }
        ],
        "vulnerabilities": [
            {
                "aliases": [
                    "CVE-2020-8897"
                ],
                "details": "A weak robustness vulnerability exists in the AWS Encryption SDKs for Java, Python, C and Javalcript prior to versions 2.0.0. Due to the non-committing property of AES-GCM (and other AEAD ciphers such as AES-GCM-SIV or (X)ChaCha20Poly1305) used by the SDKs to encrypt messages, an attacker can craft a unique cyphertext which will decrypt to multiple different results, and becomes especially relevant in a multi-recipient setting. We recommend users update their SDK to 2.0.0 or later.",
                "fixed_in": [
                    "2.0.0"
                ],
                "id": "PYSEC-2020-261",
                "link": "https://osv.dev/vulnerability/PYSEC-2020-261",
                "source": "osv",
                "summary": null,
                "withdrawn": null
            },
            {
                "aliases": [
                    "CVE-2020-8897"
                ],
                "details": "Authors: Thai \"[thaidn](https://twitter.com/xorninja)\" Duong\n\n# Summary\n\nThe following security vulnerabilities was discovered and reported to Amazon, affecting AWS KMS and all versions of [AWS Encryption SDKs](https://docs.aws.amazon.com/encryption-sdk/latest/developer-guide/introduction.html) prior to version 2.0.0:\n\n* **Information leakage**: an attacker can create ciphertexts that would leak the user\u2019s AWS account ID, encryption context, user agent, and IP address upon decryption\n* **Ciphertext forgery**: an attacker can create ciphertexts that are accepted by other users\n* **Robustness**: an attacker can create ciphertexts that decrypt to different plaintexts for different users\n\nThe first two bugs are somewhat surprising because they show that the ciphertext format can lead to vulnerabilities. These bugs (and the infamous [alg: \"None\"](https://auth0.com/blog/critical-vulnerabilities-in-json-web-token-libraries/) bugs in JWT) belong to a class of vulnerabilities called **in-band protocol negotiation**. This is the second time we\u2019ve found in-band protocol negotiation vulnerabilities in AWS cryptography libraries; see this [bug](https://github.com/google/security-research/security/advisories/GHSA-7f33-f4f5-xwgw) in S3 Crypto SDK discovered by my colleague Sophie Schmieg.\n\nIn JWT and S3 SDK the culprit is the algorithm field\u2014here it is the key ID. Because the key ID is used to determine which decryption key to use, it can\u2019t be meaningfully authenticated despite being under the attacker\u2019s control. If the key ID is a URL indicating where to fetch the key, the attacker can replace it with their own URL, and learn side-channel information such as the timing and machines on which the decryption happens (this can also lead to [SSRF](https://portswigger.net/web-security/ssrf) issues, but that\u2019s another topic for another day).\n\nIn AWS, the key ID is a unique [Amazon Resource Name](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html). If an attacker were to capture a ciphertext from a user and replace its key ID with their own, the victim\u2019s AWS account ID, encryption context, user agent, and IP address would be logged to the attacker\u2019s AWS account whenever the victim attempted to decrypt the modified ciphertext.\n\nThe last bug shows that the non-committing property of AES-GCM (and other AEAD ciphers such as [AES-GCM-SIV](https://keymaterial.net/2020/09/07/invisible-salamanders-in-aes-gcm-siv/) or (X)ChaCha20Poly1305) is especially problematic in multi-recipient settings. These ciphers have a property that can cause nonidentical plaintexts when decrypting a single ciphertext with two different keys! For example, you can send a single encrypted email to Alice and Bob which, upon decryption, reads \u201cattack\u201d to Alice and \u201cretreat\u201d to Bob. The AWS Encryption SDKs are vulnerable to this attack because they allow a single ciphertext to be generated for multiple recipients, with each decrypting using a different key. I believe this kind of problem is prevalent. I briefly looked at [JWE](https://tools.ietf.org/html/rfc7516) and I think it is vulnerable.\n\n# Mitigations\n\nAmazon has fixed these bugs in release 2.0.0 of the SDKs. A new major version was required because, unfortunately, the fix for the last bug requires a breaking change from earlier versions. All users are recommended to upgrade. More details about Amazon\u2019s mitigations can be found in [their announcement](https://aws.amazon.com/blogs/security/improved-client-side-encryption-explicit-keyids-and-key-commitment/).\n\nWe\u2019re collaborating with Shay Gueron on a paper regarding fast committing AEADs.\n\n# Vulnerabilities\n\n## Information Leakage\n\nThe [Encrypt](https://docs.aws.amazon.com/kms/latest/APIReference/API_Encrypt.html) API in AWS KMS encrypts plaintext into ciphertext by using a customer master key (CMK). The ciphertext format is undocumented, but it contains metadata that specifies the CMK and the encryption algorithm. I reverse-engineered the format and found the location of the CMK. Externally the CMK is identified by its key ARN, but within a ciphertext it is represented by an internal ID, which remained stable during my testing.\n\nWhen I replaced the internal ID of a CMK in a ciphertext with the internal ID of another CMK, I found that AWS KMS attempted to decrypt the ciphertext with the new CMK. The encryption failed and the failure event\u2014including the AWS Account ID, the user agent and the IP address of the caller\u2014was logged to Cloud Trail in the account that owned the replacement CMK.\n\nThis enables the following attack:\n* The attacker creates a CMK that has a key policy that allows access from everyone. This requires no prior knowledge about the victim.\n* The attacker intercepts a ciphertext from the victim, and replaces its CMK with their CMK.\n* Whenever the victim attempts to decrypt the modified ciphertext, the attacker learns the timing of such actions, the victim\u2019s AWS Account ID, user agent, encryption context, and IP address.\n\nThis attack requires the victim to have an IAM policy that allows them to access the attacker\u2019s CMK. I found that this practice was allowed by the AWS Visual Policy Editor, but I don\u2019t know whether it is common.\n\nThe AWS Encryption SDKs also succumb to this attack. The SDKs implement envelope encryption: encrypting data with a data encryption key (DEK) and then wrapping the DEK with a CMK using the Encrypt API in AWS KMS. The wrapped DEK is stored as part of the final ciphertext (format is defined [here](https://docs.aws.amazon.com/encryption-sdk/latest/developer-guide/message-format.html)). The attacker can mount this attack by replacing the CMK in the wrapped DEK with their own.\n\n```\n{\n    \"eventVersion\": \"1.05\",\n    \"userIdentity\": {\n        \"type\": \"AWSAccount\",\n        \"principalId\": \"<redacted this is the principal ID of the victim>\",\n        \"accountId\": \"<redacted - this is the AWS account ID of the victim>\"\n    },\n    \"eventTime\": \"2020-06-21T21:05:04Z\",\n    \"eventSource\": \"kms.amazonaws.com\",\n    \"eventName\": \"Decrypt\",\n    \"awsRegion\": \"us-west-2\",\n    \"sourceIPAddress\": \"<redacted - this is the IP address of the victim>\",\n    \"userAgent\": \"<redacted - this is the user agent of the victim>\",\n    \"errorCode\": \"InvalidCiphertextException\",\n    \"requestParameters\": {\n        // The encryption context might include other data from the victim\n        \"encryptionContext\": {\n            \"aws-crypto-public-key\": \"AzfNOGOnNYFmpHspKrAm1L6XtRybONkmkhmB/IriKSA7b2NsV4MEPMph9yX2KTPKWw==\"\n        },\n        \"encryptionAlgorithm\": \"SYMMETRIC_DEFAULT\"\n    },\n    \"responseElements\": null,\n    \"requestID\": \"aeced8e8-75a2-42c3-96ac-d1fa2a1c5ee6\",\n    \"eventID\": \"780a0a6e-4ad8-43d4-a426-75d05022f870\",\n    \"readOnly\": true,\n    \"resources\": [\n        {\n            \"accountId\": \"<redacted - this is the account ID of the attacker>\",\n            \"type\": \"AWS::KMS::Key\",\n            \"ARN\": <redacted - this is the key ARN of the attacker>\n        }\n    ],\n    \"eventType\": \"AwsApiCall\",\n    \"recipientAccountId\": \"<redacted - this is the account ID of the attacker>\",\n    \"sharedEventID\": \"033e147c-8a36-42f5-9d6c-9e071eb752b7\"\n}\n```\n**Figure 1: A failure event logged to the attacker\u2019s Cloud Trail when the victim attempted to decrypt a modified ciphertext containing the attacker\u2019s CMK.**\n\n## Ciphertext Forgery\n\nThe [Decrypt](https://docs.aws.amazon.com/kms/latest/APIReference/API_Decrypt.html) API in AWS KMS doesn\u2019t require the caller to specify the CMK. This parameter is required only when the ciphertext was encrypted under an asymmetric CMK. Otherwise, AWS KMS uses the metadata that it adds to the ciphertext blob to determine which CMK was used to encrypt the ciphertext.\n\nThis leads to the following attack:\n* The attacker creates a CMK that has a key policy that allows access from everyone. This requires no prior knowledge about the victim.\n* The attacker generates a ciphertext by calling the Encrypt API with their key.\n* The attacker intercepts a ciphertext from the victim, and replaces it entirely with their ciphertext.\n* The victim successfully decrypts the ciphertext, as if it was encrypted under their own key. The attacker also learns when this happened, the victim\u2019s AWS Account ID, user agent, encryption context, and IP address.\n\nSimilar to the information leakage attack, this attack also requires the victim to have an IAM policy that allows them to access the attacker\u2019s CMK.\n\nThe AWS Encryption SDKs also succumb to this attack. They don\u2019t specify the CMK when they call the Decrypt API to unwrap the DEK.\n\n## Robustness\n\nThe AWS Encryption SDKs allow a single ciphertext to be generated for multiple recipients, with each decrypting using a different key. To that end, it wraps the DEK multiple times, each under a different CMK. The wrapped DEKs can be combined to form a single ciphertext which can be sent to multiple recipients who can use their own credentials to decrypt it. It\u2019s reasonable to expect that all recipients should decrypt the ciphertext to an identical plaintext. However, because of the use of AES-GMAC and AES-GCM, it\u2019s possible to create a ciphertext that decrypts to two valid yet different plaintexts for two different users. In other words, the AWS Encryption SDKs are [not](https://eprint.iacr.org/2008/440.pdf) [robust](https://eprint.iacr.org/2019/016.pdf).\n\nThe encryption of a message under two CMKs can be summarized as follows:\n* A DEK is randomly generated, and two wrapped DEKs are produced by calling the Encrypt API using the two CMKs\n* A per-message AES-GCM key (K) is derived using HKDF from the DEK, a randomly generated message ID, and a fixed algorithm ID.\n* A header is formed from the wrapped DEKs, the encryption context, and other metadata. A header authentication tag is computed on the header using AES-GMAC with K and a zero IV.\n* The message is encrypted using AES-GCM with K, a non-zero IV, and fixed associated additional data. This produces a message authentication tag.\n* The ciphertext consists of the header, the header authentication tag, the encrypted message, and the message authentication tag.\n\n(There\u2019s also a self-signed digital signature that is irrelevant to this discussion).\n\nIn order to decrypt a ciphertext, the AWS Encryption SDKs loops over the list of wrapped DEKs and returns the first one that it can successfully unwrap. The attacker therefore can wrap a unique DEK for each recipient. Next, the attacker exploits the non-committing property of GMAC to produce two messages that have the same GMAC tag under two different keys. The attacker has to do this twice, one for the header authentication tag and one for the message authentication tag.\n\n```\nGiven a data blob B of one 128-bit block B_1, a GMAC tag is computed as follows:\n\nB_1 * H^2 + B_len * H + J\n\nwhere H and J depends on the key and B_len depends on the length of B.\n\nTo find a message that can produce the same tag under two different keys, one\ncan add append to B a new block B_2 whose value can be deduced by solving\nan algebraic equation. That is, we want to find B_2 such that:\n\nB_1 * H^3 + B_2 * H^2 + B_len * H + J = B_1 * H\u2019^3 + B_2 * H\u2019^2 + B_len * H\u2019 + J\u2019\n\nwhere H\u2019 and J\u2019 are the corresponding H and J of the other key.\n\nB_2 is the only unknown value in this equation, thus it can be computed using\nfinite field arithmetics of GF(2^128):\n\nB_2 = [B_1 * (H^3+H\u2019^3) + B_len * (H + H\u2019) + J + J\u2019] * (H^2 + H\u2019^2)^-1.\n```\n**Figure 2: How to find a message that has the same GMAC tag under two different keys.**\n\nThe overall attack works as follows:\n* The attacker generates a random DEK, derives a per-message key K, and encrypts message M with it using AES in counter mode. This generates a ciphertext C.\n* The attacker generates another random DEK\u2019, derives a per-message key K\u2019, and performs trial decryption of C until the decrypted message M\u2019 has desirable properties. For example, if the attacker wants the first bit of M\u2019 different from that of M, this process should only take a few attempts.\n* The attacker finds a block C* such that the GMAC of C\u2019 = C || C* under K and K\u2019 are identical. Denote this tag C\u2019_tag.\n* The attacker wraps DEK and DEK\u2019 under two recipients\u2019 CMK.\n* The attacker forms a header H and adds a block H* to the encryption context such that the new H\u2019 has the same authentication tag H\u2019_tag under K and K\u2019.\n* The attacker output H\u2019, H\u2019_tag, C\u2019, C\u2019_tag.\n\nThis attack is similar to the one discovered in [Facebook Messenger](https://eprint.iacr.org/2019/016.pdf).\n\n# Acknowledgement\n\nI\u2019m grateful to Jen Barnason for carefully editing this advisory. I will never publish anything without her approval! I want to thank my friend and coworker Sophie \u201cQueen of Hashing\u201d Schmieg for wonderful discussions and for showing me how the arithmetic in GF(2^128) works. I want to thank Jonathan Bannet for asking the questions that led to this work.",
                "fixed_in": [
                    "2.0.0"
                ],
                "id": "GHSA-wqgp-vphw-hphf",
                "link": "https://osv.dev/vulnerability/GHSA-wqgp-vphw-hphf",
                "source": "osv",
                "summary": null,
                "withdrawn": null
            },
            {
                "aliases": [],
                "details": "### Impact\n\nThis advisory addresses several LOW severity issues with streaming signed messages and restricting processing of certain types of invalid messages. \n\nThis ESDK supports a streaming mode where callers may stream the plaintext of signed messages before the ECDSA signature is validated. In addition to these signatures, the ESDK uses AES-GCM encryption and all plaintext is verified before being released to a caller. There is no impact on the integrity of the ciphertext or decrypted plaintext, however some callers may rely on the the ECDSA signature for non-repudiation. Without validating the ECDSA signature, an actor with trusted KMS permissions to decrypt a message may also be able to encrypt messages. This update introduces a new API for callers who wish to stream only unsigned messages. \n\nFor customers who process ESDK messages from untrusted sources, this update also introduces a new configuration to limit the number of Encrypted Data Keys (EDKs) that the ESDK will attempt to process per message. This configuration provides customers with a way to limit the number of AWS KMS Decrypt API calls that the ESDK will make per message. This setting will reject messages with more EDKs than the configured limit.\n\nFinally, this update adds early rejection of invalid messages with certain invalid combinations of algorithm suite and header data.\n\n### Patches\n\nFixed in versions 1.9 and 2.2. We recommend that all users upgrade to address these issues.\n\nCustomers leveraging the ESDK\u2019s streaming features have several options to protect signature validation. One is to ensure that client code reads to the end of the stream before using released plaintext. With this release, using the new API for streaming and falling back to the non-streaming decrypt API for signed messages prevents using any plaintext from signed data before the signature is validated. See https://docs.aws.amazon.com/encryption-sdk/latest/developer-guide/about-versions.html#version2.2.x\n\nUsers processing ESDK messages from untrusted sources should use the new maximum encrypted data keys parameter. See https://docs.aws.amazon.com/encryption-sdk/latest/developer-guide/about-versions.html#version2.2.x\n\n### Workarounds\n\nNone\n\n### For more information\n\nhttps://docs.aws.amazon.com/encryption-sdk/latest/developer-guide/concepts.html#digital-sigs\n\nhttps://docs.aws.amazon.com/encryption-sdk/latest/developer-guide/about-versions.html#version2.2.x\n",
                "fixed_in": [
                    "1.9.0",
                    "2.2.0"
                ],
                "id": "GHSA-x5h4-9gqw-942j",
                "link": "https://osv.dev/vulnerability/GHSA-x5h4-9gqw-942j",
                "source": "osv",
                "summary": null,
                "withdrawn": null
            }
        ]
    },
    "1.3.8": {
        "info": {
            "author": "Amazon Web Services",
            "author_email": "aws-cryptools@amazon.com",
            "bugtrack_url": null,
            "classifiers": [
                "Development Status :: 5 - Production/Stable",
                "Intended Audience :: Developers",
                "License :: OSI Approved :: Apache Software License",
                "Natural Language :: English",
                "Programming Language :: Python",
                "Programming Language :: Python :: 2",
                "Programming Language :: Python :: 2.7",
                "Programming Language :: Python :: 3",
                "Programming Language :: Python :: 3.4",
                "Programming Language :: Python :: 3.5",
                "Programming Language :: Python :: 3.6",
                "Programming Language :: Python :: 3.7",
                "Programming Language :: Python :: Implementation :: CPython",
                "Topic :: Security",
                "Topic :: Security :: Cryptography"
            ],
            "description_content_type": "",
            "docs_url": null,
            "download_url": "",
            "downloads": {
                "last_day": -1,
                "last_month": -1,
                "last_week": -1
            },
            "home_page": "https://github.com/aws/aws-encryption-sdk-python",
            "keywords": "aws-encryption-sdk aws kms encryption",
            "license": "Apache License 2.0",
            "maintainer": "Amazon Web Services",
            "maintainer_email": "",
            "name": "aws-encryption-sdk",
            "package_url": "https://pypi.org/project/aws-encryption-sdk/",
            "platform": "",
            "project_url": "https://pypi.org/project/aws-encryption-sdk/",
            "project_urls": {
                "Homepage": "https://github.com/aws/aws-encryption-sdk-python"
            },
            "release_url": "https://pypi.org/project/aws-encryption-sdk/1.3.8/",
            "requires_dist": [
                "boto3 (>=1.4.4)",
                "cryptography (>=1.8.1)",
                "attrs (>=17.4.0)",
                "wrapt (>=1.10.11)"
            ],
            "requires_python": "",
            "summary": "AWS Encryption SDK implementation for Python",
            "version": "1.3.8",
            "yanked": false,
            "yanked_reason": null
        },
        "last_serial": 14939260,
        "urls": [
            {
                "comment_text": "",
                "digests": {
                    "md5": "3a20a41a6cfc1b1f1df2a4b05889879d",
                    "sha256": "fdd6a9a4536b8534b73b76ad3bc424e4ef5c1e745b7172a543a87ec18db85053"
                },
                "downloads": -1,
                "filename": "aws_encryption_sdk-1.3.8-py2.py3-none-any.whl",
                "has_sig": false,
                "md5_digest": "3a20a41a6cfc1b1f1df2a4b05889879d",
                "packagetype": "bdist_wheel",
                "python_version": "py2.py3",
                "requires_python": null,
                "size": 84988,
                "upload_time": "2018-11-15T19:11:33",
                "upload_time_iso_8601": "2018-11-15T19:11:33.324765Z",
                "url": "https://files.pythonhosted.org/packages/d3/be/f932c3c8993d30c27e89d801cb1802cc2ce5a611f8dd851d2d2c0c864a6b/aws_encryption_sdk-1.3.8-py2.py3-none-any.whl",
                "yanked": false,
                "yanked_reason": null
            },
            {
                "comment_text": "",
                "digests": {
                    "md5": "c3a8b56011d961471d7bdf06b45882b9",
                    "sha256": "a0188f1c6a19523e275ac8655c6156866d78e8eb4bd1ac14b68f6c50804c6e1b"
                },
                "downloads": -1,
                "filename": "aws-encryption-sdk-1.3.8.tar.gz",
                "has_sig": false,
                "md5_digest": "c3a8b56011d961471d7bdf06b45882b9",
                "packagetype": "sdist",
                "python_version": "source",
                "requires_python": null,
                "size": 7973560,
                "upload_time": "2018-11-15T19:11:37",
                "upload_time_iso_8601": "2018-11-15T19:11:37.297509Z",
                "url": "https://files.pythonhosted.org/packages/9c/67/1dc65ae578aba8a3b7e3c6175abcab40f04670b9b6629351d41f860c06b4/aws-encryption-sdk-1.3.8.tar.gz",
                "yanked": false,
                "yanked_reason": null
            }
        ],
        "vulnerabilities": [
            {
                "aliases": [
                    "CVE-2020-8897"
                ],
                "details": "A weak robustness vulnerability exists in the AWS Encryption SDKs for Java, Python, C and Javalcript prior to versions 2.0.0. Due to the non-committing property of AES-GCM (and other AEAD ciphers such as AES-GCM-SIV or (X)ChaCha20Poly1305) used by the SDKs to encrypt messages, an attacker can craft a unique cyphertext which will decrypt to multiple different results, and becomes especially relevant in a multi-recipient setting. We recommend users update their SDK to 2.0.0 or later.",
                "fixed_in": [
                    "2.0.0"
                ],
                "id": "PYSEC-2020-261",
                "link": "https://osv.dev/vulnerability/PYSEC-2020-261",
                "source": "osv",
                "summary": null,
                "withdrawn": null
            },
            {
                "aliases": [
                    "CVE-2020-8897"
                ],
                "details": "Authors: Thai \"[thaidn](https://twitter.com/xorninja)\" Duong\n\n# Summary\n\nThe following security vulnerabilities was discovered and reported to Amazon, affecting AWS KMS and all versions of [AWS Encryption SDKs](https://docs.aws.amazon.com/encryption-sdk/latest/developer-guide/introduction.html) prior to version 2.0.0:\n\n* **Information leakage**: an attacker can create ciphertexts that would leak the user\u2019s AWS account ID, encryption context, user agent, and IP address upon decryption\n* **Ciphertext forgery**: an attacker can create ciphertexts that are accepted by other users\n* **Robustness**: an attacker can create ciphertexts that decrypt to different plaintexts for different users\n\nThe first two bugs are somewhat surprising because they show that the ciphertext format can lead to vulnerabilities. These bugs (and the infamous [alg: \"None\"](https://auth0.com/blog/critical-vulnerabilities-in-json-web-token-libraries/) bugs in JWT) belong to a class of vulnerabilities called **in-band protocol negotiation**. This is the second time we\u2019ve found in-band protocol negotiation vulnerabilities in AWS cryptography libraries; see this [bug](https://github.com/google/security-research/security/advisories/GHSA-7f33-f4f5-xwgw) in S3 Crypto SDK discovered by my colleague Sophie Schmieg.\n\nIn JWT and S3 SDK the culprit is the algorithm field\u2014here it is the key ID. Because the key ID is used to determine which decryption key to use, it can\u2019t be meaningfully authenticated despite being under the attacker\u2019s control. If the key ID is a URL indicating where to fetch the key, the attacker can replace it with their own URL, and learn side-channel information such as the timing and machines on which the decryption happens (this can also lead to [SSRF](https://portswigger.net/web-security/ssrf) issues, but that\u2019s another topic for another day).\n\nIn AWS, the key ID is a unique [Amazon Resource Name](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html). If an attacker were to capture a ciphertext from a user and replace its key ID with their own, the victim\u2019s AWS account ID, encryption context, user agent, and IP address would be logged to the attacker\u2019s AWS account whenever the victim attempted to decrypt the modified ciphertext.\n\nThe last bug shows that the non-committing property of AES-GCM (and other AEAD ciphers such as [AES-GCM-SIV](https://keymaterial.net/2020/09/07/invisible-salamanders-in-aes-gcm-siv/) or (X)ChaCha20Poly1305) is especially problematic in multi-recipient settings. These ciphers have a property that can cause nonidentical plaintexts when decrypting a single ciphertext with two different keys! For example, you can send a single encrypted email to Alice and Bob which, upon decryption, reads \u201cattack\u201d to Alice and \u201cretreat\u201d to Bob. The AWS Encryption SDKs are vulnerable to this attack because they allow a single ciphertext to be generated for multiple recipients, with each decrypting using a different key. I believe this kind of problem is prevalent. I briefly looked at [JWE](https://tools.ietf.org/html/rfc7516) and I think it is vulnerable.\n\n# Mitigations\n\nAmazon has fixed these bugs in release 2.0.0 of the SDKs. A new major version was required because, unfortunately, the fix for the last bug requires a breaking change from earlier versions. All users are recommended to upgrade. More details about Amazon\u2019s mitigations can be found in [their announcement](https://aws.amazon.com/blogs/security/improved-client-side-encryption-explicit-keyids-and-key-commitment/).\n\nWe\u2019re collaborating with Shay Gueron on a paper regarding fast committing AEADs.\n\n# Vulnerabilities\n\n## Information Leakage\n\nThe [Encrypt](https://docs.aws.amazon.com/kms/latest/APIReference/API_Encrypt.html) API in AWS KMS encrypts plaintext into ciphertext by using a customer master key (CMK). The ciphertext format is undocumented, but it contains metadata that specifies the CMK and the encryption algorithm. I reverse-engineered the format and found the location of the CMK. Externally the CMK is identified by its key ARN, but within a ciphertext it is represented by an internal ID, which remained stable during my testing.\n\nWhen I replaced the internal ID of a CMK in a ciphertext with the internal ID of another CMK, I found that AWS KMS attempted to decrypt the ciphertext with the new CMK. The encryption failed and the failure event\u2014including the AWS Account ID, the user agent and the IP address of the caller\u2014was logged to Cloud Trail in the account that owned the replacement CMK.\n\nThis enables the following attack:\n* The attacker creates a CMK that has a key policy that allows access from everyone. This requires no prior knowledge about the victim.\n* The attacker intercepts a ciphertext from the victim, and replaces its CMK with their CMK.\n* Whenever the victim attempts to decrypt the modified ciphertext, the attacker learns the timing of such actions, the victim\u2019s AWS Account ID, user agent, encryption context, and IP address.\n\nThis attack requires the victim to have an IAM policy that allows them to access the attacker\u2019s CMK. I found that this practice was allowed by the AWS Visual Policy Editor, but I don\u2019t know whether it is common.\n\nThe AWS Encryption SDKs also succumb to this attack. The SDKs implement envelope encryption: encrypting data with a data encryption key (DEK) and then wrapping the DEK with a CMK using the Encrypt API in AWS KMS. The wrapped DEK is stored as part of the final ciphertext (format is defined [here](https://docs.aws.amazon.com/encryption-sdk/latest/developer-guide/message-format.html)). The attacker can mount this attack by replacing the CMK in the wrapped DEK with their own.\n\n```\n{\n    \"eventVersion\": \"1.05\",\n    \"userIdentity\": {\n        \"type\": \"AWSAccount\",\n        \"principalId\": \"<redacted this is the principal ID of the victim>\",\n        \"accountId\": \"<redacted - this is the AWS account ID of the victim>\"\n    },\n    \"eventTime\": \"2020-06-21T21:05:04Z\",\n    \"eventSource\": \"kms.amazonaws.com\",\n    \"eventName\": \"Decrypt\",\n    \"awsRegion\": \"us-west-2\",\n    \"sourceIPAddress\": \"<redacted - this is the IP address of the victim>\",\n    \"userAgent\": \"<redacted - this is the user agent of the victim>\",\n    \"errorCode\": \"InvalidCiphertextException\",\n    \"requestParameters\": {\n        // The encryption context might include other data from the victim\n        \"encryptionContext\": {\n            \"aws-crypto-public-key\": \"AzfNOGOnNYFmpHspKrAm1L6XtRybONkmkhmB/IriKSA7b2NsV4MEPMph9yX2KTPKWw==\"\n        },\n        \"encryptionAlgorithm\": \"SYMMETRIC_DEFAULT\"\n    },\n    \"responseElements\": null,\n    \"requestID\": \"aeced8e8-75a2-42c3-96ac-d1fa2a1c5ee6\",\n    \"eventID\": \"780a0a6e-4ad8-43d4-a426-75d05022f870\",\n    \"readOnly\": true,\n    \"resources\": [\n        {\n            \"accountId\": \"<redacted - this is the account ID of the attacker>\",\n            \"type\": \"AWS::KMS::Key\",\n            \"ARN\": <redacted - this is the key ARN of the attacker>\n        }\n    ],\n    \"eventType\": \"AwsApiCall\",\n    \"recipientAccountId\": \"<redacted - this is the account ID of the attacker>\",\n    \"sharedEventID\": \"033e147c-8a36-42f5-9d6c-9e071eb752b7\"\n}\n```\n**Figure 1: A failure event logged to the attacker\u2019s Cloud Trail when the victim attempted to decrypt a modified ciphertext containing the attacker\u2019s CMK.**\n\n## Ciphertext Forgery\n\nThe [Decrypt](https://docs.aws.amazon.com/kms/latest/APIReference/API_Decrypt.html) API in AWS KMS doesn\u2019t require the caller to specify the CMK. This parameter is required only when the ciphertext was encrypted under an asymmetric CMK. Otherwise, AWS KMS uses the metadata that it adds to the ciphertext blob to determine which CMK was used to encrypt the ciphertext.\n\nThis leads to the following attack:\n* The attacker creates a CMK that has a key policy that allows access from everyone. This requires no prior knowledge about the victim.\n* The attacker generates a ciphertext by calling the Encrypt API with their key.\n* The attacker intercepts a ciphertext from the victim, and replaces it entirely with their ciphertext.\n* The victim successfully decrypts the ciphertext, as if it was encrypted under their own key. The attacker also learns when this happened, the victim\u2019s AWS Account ID, user agent, encryption context, and IP address.\n\nSimilar to the information leakage attack, this attack also requires the victim to have an IAM policy that allows them to access the attacker\u2019s CMK.\n\nThe AWS Encryption SDKs also succumb to this attack. They don\u2019t specify the CMK when they call the Decrypt API to unwrap the DEK.\n\n## Robustness\n\nThe AWS Encryption SDKs allow a single ciphertext to be generated for multiple recipients, with each decrypting using a different key. To that end, it wraps the DEK multiple times, each under a different CMK. The wrapped DEKs can be combined to form a single ciphertext which can be sent to multiple recipients who can use their own credentials to decrypt it. It\u2019s reasonable to expect that all recipients should decrypt the ciphertext to an identical plaintext. However, because of the use of AES-GMAC and AES-GCM, it\u2019s possible to create a ciphertext that decrypts to two valid yet different plaintexts for two different users. In other words, the AWS Encryption SDKs are [not](https://eprint.iacr.org/2008/440.pdf) [robust](https://eprint.iacr.org/2019/016.pdf).\n\nThe encryption of a message under two CMKs can be summarized as follows:\n* A DEK is randomly generated, and two wrapped DEKs are produced by calling the Encrypt API using the two CMKs\n* A per-message AES-GCM key (K) is derived using HKDF from the DEK, a randomly generated message ID, and a fixed algorithm ID.\n* A header is formed from the wrapped DEKs, the encryption context, and other metadata. A header authentication tag is computed on the header using AES-GMAC with K and a zero IV.\n* The message is encrypted using AES-GCM with K, a non-zero IV, and fixed associated additional data. This produces a message authentication tag.\n* The ciphertext consists of the header, the header authentication tag, the encrypted message, and the message authentication tag.\n\n(There\u2019s also a self-signed digital signature that is irrelevant to this discussion).\n\nIn order to decrypt a ciphertext, the AWS Encryption SDKs loops over the list of wrapped DEKs and returns the first one that it can successfully unwrap. The attacker therefore can wrap a unique DEK for each recipient. Next, the attacker exploits the non-committing property of GMAC to produce two messages that have the same GMAC tag under two different keys. The attacker has to do this twice, one for the header authentication tag and one for the message authentication tag.\n\n```\nGiven a data blob B of one 128-bit block B_1, a GMAC tag is computed as follows:\n\nB_1 * H^2 + B_len * H + J\n\nwhere H and J depends on the key and B_len depends on the length of B.\n\nTo find a message that can produce the same tag under two different keys, one\ncan add append to B a new block B_2 whose value can be deduced by solving\nan algebraic equation. That is, we want to find B_2 such that:\n\nB_1 * H^3 + B_2 * H^2 + B_len * H + J = B_1 * H\u2019^3 + B_2 * H\u2019^2 + B_len * H\u2019 + J\u2019\n\nwhere H\u2019 and J\u2019 are the corresponding H and J of the other key.\n\nB_2 is the only unknown value in this equation, thus it can be computed using\nfinite field arithmetics of GF(2^128):\n\nB_2 = [B_1 * (H^3+H\u2019^3) + B_len * (H + H\u2019) + J + J\u2019] * (H^2 + H\u2019^2)^-1.\n```\n**Figure 2: How to find a message that has the same GMAC tag under two different keys.**\n\nThe overall attack works as follows:\n* The attacker generates a random DEK, derives a per-message key K, and encrypts message M with it using AES in counter mode. This generates a ciphertext C.\n* The attacker generates another random DEK\u2019, derives a per-message key K\u2019, and performs trial decryption of C until the decrypted message M\u2019 has desirable properties. For example, if the attacker wants the first bit of M\u2019 different from that of M, this process should only take a few attempts.\n* The attacker finds a block C* such that the GMAC of C\u2019 = C || C* under K and K\u2019 are identical. Denote this tag C\u2019_tag.\n* The attacker wraps DEK and DEK\u2019 under two recipients\u2019 CMK.\n* The attacker forms a header H and adds a block H* to the encryption context such that the new H\u2019 has the same authentication tag H\u2019_tag under K and K\u2019.\n* The attacker output H\u2019, H\u2019_tag, C\u2019, C\u2019_tag.\n\nThis attack is similar to the one discovered in [Facebook Messenger](https://eprint.iacr.org/2019/016.pdf).\n\n# Acknowledgement\n\nI\u2019m grateful to Jen Barnason for carefully editing this advisory. I will never publish anything without her approval! I want to thank my friend and coworker Sophie \u201cQueen of Hashing\u201d Schmieg for wonderful discussions and for showing me how the arithmetic in GF(2^128) works. I want to thank Jonathan Bannet for asking the questions that led to this work.",
                "fixed_in": [
                    "2.0.0"
                ],
                "id": "GHSA-wqgp-vphw-hphf",
                "link": "https://osv.dev/vulnerability/GHSA-wqgp-vphw-hphf",
                "source": "osv",
                "summary": null,
                "withdrawn": null
            },
            {
                "aliases": [],
                "details": "### Impact\n\nThis advisory addresses several LOW severity issues with streaming signed messages and restricting processing of certain types of invalid messages. \n\nThis ESDK supports a streaming mode where callers may stream the plaintext of signed messages before the ECDSA signature is validated. In addition to these signatures, the ESDK uses AES-GCM encryption and all plaintext is verified before being released to a caller. There is no impact on the integrity of the ciphertext or decrypted plaintext, however some callers may rely on the the ECDSA signature for non-repudiation. Without validating the ECDSA signature, an actor with trusted KMS permissions to decrypt a message may also be able to encrypt messages. This update introduces a new API for callers who wish to stream only unsigned messages. \n\nFor customers who process ESDK messages from untrusted sources, this update also introduces a new configuration to limit the number of Encrypted Data Keys (EDKs) that the ESDK will attempt to process per message. This configuration provides customers with a way to limit the number of AWS KMS Decrypt API calls that the ESDK will make per message. This setting will reject messages with more EDKs than the configured limit.\n\nFinally, this update adds early rejection of invalid messages with certain invalid combinations of algorithm suite and header data.\n\n### Patches\n\nFixed in versions 1.9 and 2.2. We recommend that all users upgrade to address these issues.\n\nCustomers leveraging the ESDK\u2019s streaming features have several options to protect signature validation. One is to ensure that client code reads to the end of the stream before using released plaintext. With this release, using the new API for streaming and falling back to the non-streaming decrypt API for signed messages prevents using any plaintext from signed data before the signature is validated. See https://docs.aws.amazon.com/encryption-sdk/latest/developer-guide/about-versions.html#version2.2.x\n\nUsers processing ESDK messages from untrusted sources should use the new maximum encrypted data keys parameter. See https://docs.aws.amazon.com/encryption-sdk/latest/developer-guide/about-versions.html#version2.2.x\n\n### Workarounds\n\nNone\n\n### For more information\n\nhttps://docs.aws.amazon.com/encryption-sdk/latest/developer-guide/concepts.html#digital-sigs\n\nhttps://docs.aws.amazon.com/encryption-sdk/latest/developer-guide/about-versions.html#version2.2.x\n",
                "fixed_in": [
                    "1.9.0",
                    "2.2.0"
                ],
                "id": "GHSA-x5h4-9gqw-942j",
                "link": "https://osv.dev/vulnerability/GHSA-x5h4-9gqw-942j",
                "source": "osv",
                "summary": null,
                "withdrawn": null
            }
        ]
    },
    "1.4.0": {
        "info": {
            "author": "Amazon Web Services",
            "author_email": "aws-cryptools@amazon.com",
            "bugtrack_url": null,
            "classifiers": [
                "Development Status :: 5 - Production/Stable",
                "Intended Audience :: Developers",
                "License :: OSI Approved :: Apache Software License",
                "Natural Language :: English",
                "Programming Language :: Python",
                "Programming Language :: Python :: 2",
                "Programming Language :: Python :: 2.7",
                "Programming Language :: Python :: 3",
                "Programming Language :: Python :: 3.4",
                "Programming Language :: Python :: 3.5",
                "Programming Language :: Python :: 3.6",
                "Programming Language :: Python :: 3.7",
                "Programming Language :: Python :: Implementation :: CPython",
                "Topic :: Security",
                "Topic :: Security :: Cryptography"
            ],
            "description_content_type": "",
            "docs_url": null,
            "download_url": "",
            "downloads": {
                "last_day": -1,
                "last_month": -1,
                "last_week": -1
            },
            "home_page": "https://github.com/aws/aws-encryption-sdk-python",
            "keywords": "aws-encryption-sdk aws kms encryption",
            "license": "Apache License 2.0",
            "maintainer": "Amazon Web Services",
            "maintainer_email": "",
            "name": "aws-encryption-sdk",
            "package_url": "https://pypi.org/project/aws-encryption-sdk/",
            "platform": "",
            "project_url": "https://pypi.org/project/aws-encryption-sdk/",
            "project_urls": {
                "Homepage": "https://github.com/aws/aws-encryption-sdk-python"
            },
            "release_url": "https://pypi.org/project/aws-encryption-sdk/1.4.0/",
            "requires_dist": [
                "boto3 (>=1.4.4)",
                "cryptography (>=1.8.1)",
                "attrs (>=17.4.0)",
                "wrapt (>=1.10.11)"
            ],
            "requires_python": "",
            "summary": "AWS Encryption SDK implementation for Python",
            "version": "1.4.0",
            "yanked": false,
            "yanked_reason": null
        },
        "last_serial": 14939260,
        "urls": [
            {
                "comment_text": "",
                "digests": {
                    "md5": "e554bc6a8e4872a44120c73982e7d1ce",
                    "sha256": "9888b4ac7037b36ded4465e8aa44124742507786eea4563078afb37ce9289b7d"
                },
                "downloads": -1,
                "filename": "aws_encryption_sdk-1.4.0-py2.py3-none-any.whl",
                "has_sig": false,
                "md5_digest": "e554bc6a8e4872a44120c73982e7d1ce",
                "packagetype": "bdist_wheel",
                "python_version": "py2.py3",
                "requires_python": null,
                "size": 85361,
                "upload_time": "2019-05-23T23:21:17",
                "upload_time_iso_8601": "2019-05-23T23:21:17.949270Z",
                "url": "https://files.pythonhosted.org/packages/ee/d6/1bb76ed57bfb1fd30dd7e1f1d0d4834c27dbb082b6edaefc6dbe0997ce71/aws_encryption_sdk-1.4.0-py2.py3-none-any.whl",
                "yanked": false,
                "yanked_reason": null
            },
            {
                "comment_text": "",
                "digests": {
                    "md5": "2c23fdfed6fa37b4506eca1c411bf809",
                    "sha256": "76b358c7e3dc6d5299ee037a99440b47f3866c8d9228865a67198700a77c6962"
                },
                "downloads": -1,
                "filename": "aws-encryption-sdk-1.4.0.tar.gz",
                "has_sig": false,
                "md5_digest": "2c23fdfed6fa37b4506eca1c411bf809",
                "packagetype": "sdist",
                "python_version": "source",
                "requires_python": null,
                "size": 7969872,
                "upload_time": "2019-05-23T23:21:21",
                "upload_time_iso_8601": "2019-05-23T23:21:21.190742Z",
                "url": "https://files.pythonhosted.org/packages/66/63/ad1fdf37582e4bf15d4a6b8445567bb8a220cd46e13d9afbb6e5f27e3e60/aws-encryption-sdk-1.4.0.tar.gz",
                "yanked": false,
                "yanked_reason": null
            }
        ],
        "vulnerabilities": [
            {
                "aliases": [
                    "CVE-2020-8897"
                ],
                "details": "A weak robustness vulnerability exists in the AWS Encryption SDKs for Java, Python, C and Javalcript prior to versions 2.0.0. Due to the non-committing property of AES-GCM (and other AEAD ciphers such as AES-GCM-SIV or (X)ChaCha20Poly1305) used by the SDKs to encrypt messages, an attacker can craft a unique cyphertext which will decrypt to multiple different results, and becomes especially relevant in a multi-recipient setting. We recommend users update their SDK to 2.0.0 or later.",
                "fixed_in": [
                    "2.0.0"
                ],
                "id": "PYSEC-2020-261",
                "link": "https://osv.dev/vulnerability/PYSEC-2020-261",
                "source": "osv",
                "summary": null,
                "withdrawn": null
            },
            {
                "aliases": [
                    "CVE-2020-8897"
                ],
                "details": "Authors: Thai \"[thaidn](https://twitter.com/xorninja)\" Duong\n\n# Summary\n\nThe following security vulnerabilities was discovered and reported to Amazon, affecting AWS KMS and all versions of [AWS Encryption SDKs](https://docs.aws.amazon.com/encryption-sdk/latest/developer-guide/introduction.html) prior to version 2.0.0:\n\n* **Information leakage**: an attacker can create ciphertexts that would leak the user\u2019s AWS account ID, encryption context, user agent, and IP address upon decryption\n* **Ciphertext forgery**: an attacker can create ciphertexts that are accepted by other users\n* **Robustness**: an attacker can create ciphertexts that decrypt to different plaintexts for different users\n\nThe first two bugs are somewhat surprising because they show that the ciphertext format can lead to vulnerabilities. These bugs (and the infamous [alg: \"None\"](https://auth0.com/blog/critical-vulnerabilities-in-json-web-token-libraries/) bugs in JWT) belong to a class of vulnerabilities called **in-band protocol negotiation**. This is the second time we\u2019ve found in-band protocol negotiation vulnerabilities in AWS cryptography libraries; see this [bug](https://github.com/google/security-research/security/advisories/GHSA-7f33-f4f5-xwgw) in S3 Crypto SDK discovered by my colleague Sophie Schmieg.\n\nIn JWT and S3 SDK the culprit is the algorithm field\u2014here it is the key ID. Because the key ID is used to determine which decryption key to use, it can\u2019t be meaningfully authenticated despite being under the attacker\u2019s control. If the key ID is a URL indicating where to fetch the key, the attacker can replace it with their own URL, and learn side-channel information such as the timing and machines on which the decryption happens (this can also lead to [SSRF](https://portswigger.net/web-security/ssrf) issues, but that\u2019s another topic for another day).\n\nIn AWS, the key ID is a unique [Amazon Resource Name](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html). If an attacker were to capture a ciphertext from a user and replace its key ID with their own, the victim\u2019s AWS account ID, encryption context, user agent, and IP address would be logged to the attacker\u2019s AWS account whenever the victim attempted to decrypt the modified ciphertext.\n\nThe last bug shows that the non-committing property of AES-GCM (and other AEAD ciphers such as [AES-GCM-SIV](https://keymaterial.net/2020/09/07/invisible-salamanders-in-aes-gcm-siv/) or (X)ChaCha20Poly1305) is especially problematic in multi-recipient settings. These ciphers have a property that can cause nonidentical plaintexts when decrypting a single ciphertext with two different keys! For example, you can send a single encrypted email to Alice and Bob which, upon decryption, reads \u201cattack\u201d to Alice and \u201cretreat\u201d to Bob. The AWS Encryption SDKs are vulnerable to this attack because they allow a single ciphertext to be generated for multiple recipients, with each decrypting using a different key. I believe this kind of problem is prevalent. I briefly looked at [JWE](https://tools.ietf.org/html/rfc7516) and I think it is vulnerable.\n\n# Mitigations\n\nAmazon has fixed these bugs in release 2.0.0 of the SDKs. A new major version was required because, unfortunately, the fix for the last bug requires a breaking change from earlier versions. All users are recommended to upgrade. More details about Amazon\u2019s mitigations can be found in [their announcement](https://aws.amazon.com/blogs/security/improved-client-side-encryption-explicit-keyids-and-key-commitment/).\n\nWe\u2019re collaborating with Shay Gueron on a paper regarding fast committing AEADs.\n\n# Vulnerabilities\n\n## Information Leakage\n\nThe [Encrypt](https://docs.aws.amazon.com/kms/latest/APIReference/API_Encrypt.html) API in AWS KMS encrypts plaintext into ciphertext by using a customer master key (CMK). The ciphertext format is undocumented, but it contains metadata that specifies the CMK and the encryption algorithm. I reverse-engineered the format and found the location of the CMK. Externally the CMK is identified by its key ARN, but within a ciphertext it is represented by an internal ID, which remained stable during my testing.\n\nWhen I replaced the internal ID of a CMK in a ciphertext with the internal ID of another CMK, I found that AWS KMS attempted to decrypt the ciphertext with the new CMK. The encryption failed and the failure event\u2014including the AWS Account ID, the user agent and the IP address of the caller\u2014was logged to Cloud Trail in the account that owned the replacement CMK.\n\nThis enables the following attack:\n* The attacker creates a CMK that has a key policy that allows access from everyone. This requires no prior knowledge about the victim.\n* The attacker intercepts a ciphertext from the victim, and replaces its CMK with their CMK.\n* Whenever the victim attempts to decrypt the modified ciphertext, the attacker learns the timing of such actions, the victim\u2019s AWS Account ID, user agent, encryption context, and IP address.\n\nThis attack requires the victim to have an IAM policy that allows them to access the attacker\u2019s CMK. I found that this practice was allowed by the AWS Visual Policy Editor, but I don\u2019t know whether it is common.\n\nThe AWS Encryption SDKs also succumb to this attack. The SDKs implement envelope encryption: encrypting data with a data encryption key (DEK) and then wrapping the DEK with a CMK using the Encrypt API in AWS KMS. The wrapped DEK is stored as part of the final ciphertext (format is defined [here](https://docs.aws.amazon.com/encryption-sdk/latest/developer-guide/message-format.html)). The attacker can mount this attack by replacing the CMK in the wrapped DEK with their own.\n\n```\n{\n    \"eventVersion\": \"1.05\",\n    \"userIdentity\": {\n        \"type\": \"AWSAccount\",\n        \"principalId\": \"<redacted this is the principal ID of the victim>\",\n        \"accountId\": \"<redacted - this is the AWS account ID of the victim>\"\n    },\n    \"eventTime\": \"2020-06-21T21:05:04Z\",\n    \"eventSource\": \"kms.amazonaws.com\",\n    \"eventName\": \"Decrypt\",\n    \"awsRegion\": \"us-west-2\",\n    \"sourceIPAddress\": \"<redacted - this is the IP address of the victim>\",\n    \"userAgent\": \"<redacted - this is the user agent of the victim>\",\n    \"errorCode\": \"InvalidCiphertextException\",\n    \"requestParameters\": {\n        // The encryption context might include other data from the victim\n        \"encryptionContext\": {\n            \"aws-crypto-public-key\": \"AzfNOGOnNYFmpHspKrAm1L6XtRybONkmkhmB/IriKSA7b2NsV4MEPMph9yX2KTPKWw==\"\n        },\n        \"encryptionAlgorithm\": \"SYMMETRIC_DEFAULT\"\n    },\n    \"responseElements\": null,\n    \"requestID\": \"aeced8e8-75a2-42c3-96ac-d1fa2a1c5ee6\",\n    \"eventID\": \"780a0a6e-4ad8-43d4-a426-75d05022f870\",\n    \"readOnly\": true,\n    \"resources\": [\n        {\n            \"accountId\": \"<redacted - this is the account ID of the attacker>\",\n            \"type\": \"AWS::KMS::Key\",\n            \"ARN\": <redacted - this is the key ARN of the attacker>\n        }\n    ],\n    \"eventType\": \"AwsApiCall\",\n    \"recipientAccountId\": \"<redacted - this is the account ID of the attacker>\",\n    \"sharedEventID\": \"033e147c-8a36-42f5-9d6c-9e071eb752b7\"\n}\n```\n**Figure 1: A failure event logged to the attacker\u2019s Cloud Trail when the victim attempted to decrypt a modified ciphertext containing the attacker\u2019s CMK.**\n\n## Ciphertext Forgery\n\nThe [Decrypt](https://docs.aws.amazon.com/kms/latest/APIReference/API_Decrypt.html) API in AWS KMS doesn\u2019t require the caller to specify the CMK. This parameter is required only when the ciphertext was encrypted under an asymmetric CMK. Otherwise, AWS KMS uses the metadata that it adds to the ciphertext blob to determine which CMK was used to encrypt the ciphertext.\n\nThis leads to the following attack:\n* The attacker creates a CMK that has a key policy that allows access from everyone. This requires no prior knowledge about the victim.\n* The attacker generates a ciphertext by calling the Encrypt API with their key.\n* The attacker intercepts a ciphertext from the victim, and replaces it entirely with their ciphertext.\n* The victim successfully decrypts the ciphertext, as if it was encrypted under their own key. The attacker also learns when this happened, the victim\u2019s AWS Account ID, user agent, encryption context, and IP address.\n\nSimilar to the information leakage attack, this attack also requires the victim to have an IAM policy that allows them to access the attacker\u2019s CMK.\n\nThe AWS Encryption SDKs also succumb to this attack. They don\u2019t specify the CMK when they call the Decrypt API to unwrap the DEK.\n\n## Robustness\n\nThe AWS Encryption SDKs allow a single ciphertext to be generated for multiple recipients, with each decrypting using a different key. To that end, it wraps the DEK multiple times, each under a different CMK. The wrapped DEKs can be combined to form a single ciphertext which can be sent to multiple recipients who can use their own credentials to decrypt it. It\u2019s reasonable to expect that all recipients should decrypt the ciphertext to an identical plaintext. However, because of the use of AES-GMAC and AES-GCM, it\u2019s possible to create a ciphertext that decrypts to two valid yet different plaintexts for two different users. In other words, the AWS Encryption SDKs are [not](https://eprint.iacr.org/2008/440.pdf) [robust](https://eprint.iacr.org/2019/016.pdf).\n\nThe encryption of a message under two CMKs can be summarized as follows:\n* A DEK is randomly generated, and two wrapped DEKs are produced by calling the Encrypt API using the two CMKs\n* A per-message AES-GCM key (K) is derived using HKDF from the DEK, a randomly generated message ID, and a fixed algorithm ID.\n* A header is formed from the wrapped DEKs, the encryption context, and other metadata. A header authentication tag is computed on the header using AES-GMAC with K and a zero IV.\n* The message is encrypted using AES-GCM with K, a non-zero IV, and fixed associated additional data. This produces a message authentication tag.\n* The ciphertext consists of the header, the header authentication tag, the encrypted message, and the message authentication tag.\n\n(There\u2019s also a self-signed digital signature that is irrelevant to this discussion).\n\nIn order to decrypt a ciphertext, the AWS Encryption SDKs loops over the list of wrapped DEKs and returns the first one that it can successfully unwrap. The attacker therefore can wrap a unique DEK for each recipient. Next, the attacker exploits the non-committing property of GMAC to produce two messages that have the same GMAC tag under two different keys. The attacker has to do this twice, one for the header authentication tag and one for the message authentication tag.\n\n```\nGiven a data blob B of one 128-bit block B_1, a GMAC tag is computed as follows:\n\nB_1 * H^2 + B_len * H + J\n\nwhere H and J depends on the key and B_len depends on the length of B.\n\nTo find a message that can produce the same tag under two different keys, one\ncan add append to B a new block B_2 whose value can be deduced by solving\nan algebraic equation. That is, we want to find B_2 such that:\n\nB_1 * H^3 + B_2 * H^2 + B_len * H + J = B_1 * H\u2019^3 + B_2 * H\u2019^2 + B_len * H\u2019 + J\u2019\n\nwhere H\u2019 and J\u2019 are the corresponding H and J of the other key.\n\nB_2 is the only unknown value in this equation, thus it can be computed using\nfinite field arithmetics of GF(2^128):\n\nB_2 = [B_1 * (H^3+H\u2019^3) + B_len * (H + H\u2019) + J + J\u2019] * (H^2 + H\u2019^2)^-1.\n```\n**Figure 2: How to find a message that has the same GMAC tag under two different keys.**\n\nThe overall attack works as follows:\n* The attacker generates a random DEK, derives a per-message key K, and encrypts message M with it using AES in counter mode. This generates a ciphertext C.\n* The attacker generates another random DEK\u2019, derives a per-message key K\u2019, and performs trial decryption of C until the decrypted message M\u2019 has desirable properties. For example, if the attacker wants the first bit of M\u2019 different from that of M, this process should only take a few attempts.\n* The attacker finds a block C* such that the GMAC of C\u2019 = C || C* under K and K\u2019 are identical. Denote this tag C\u2019_tag.\n* The attacker wraps DEK and DEK\u2019 under two recipients\u2019 CMK.\n* The attacker forms a header H and adds a block H* to the encryption context such that the new H\u2019 has the same authentication tag H\u2019_tag under K and K\u2019.\n* The attacker output H\u2019, H\u2019_tag, C\u2019, C\u2019_tag.\n\nThis attack is similar to the one discovered in [Facebook Messenger](https://eprint.iacr.org/2019/016.pdf).\n\n# Acknowledgement\n\nI\u2019m grateful to Jen Barnason for carefully editing this advisory. I will never publish anything without her approval! I want to thank my friend and coworker Sophie \u201cQueen of Hashing\u201d Schmieg for wonderful discussions and for showing me how the arithmetic in GF(2^128) works. I want to thank Jonathan Bannet for asking the questions that led to this work.",
                "fixed_in": [
                    "2.0.0"
                ],
                "id": "GHSA-wqgp-vphw-hphf",
                "link": "https://osv.dev/vulnerability/GHSA-wqgp-vphw-hphf",
                "source": "osv",
                "summary": null,
                "withdrawn": null
            },
            {
                "aliases": [],
                "details": "### Impact\n\nThis advisory addresses several LOW severity issues with streaming signed messages and restricting processing of certain types of invalid messages. \n\nThis ESDK supports a streaming mode where callers may stream the plaintext of signed messages before the ECDSA signature is validated. In addition to these signatures, the ESDK uses AES-GCM encryption and all plaintext is verified before being released to a caller. There is no impact on the integrity of the ciphertext or decrypted plaintext, however some callers may rely on the the ECDSA signature for non-repudiation. Without validating the ECDSA signature, an actor with trusted KMS permissions to decrypt a message may also be able to encrypt messages. This update introduces a new API for callers who wish to stream only unsigned messages. \n\nFor customers who process ESDK messages from untrusted sources, this update also introduces a new configuration to limit the number of Encrypted Data Keys (EDKs) that the ESDK will attempt to process per message. This configuration provides customers with a way to limit the number of AWS KMS Decrypt API calls that the ESDK will make per message. This setting will reject messages with more EDKs than the configured limit.\n\nFinally, this update adds early rejection of invalid messages with certain invalid combinations of algorithm suite and header data.\n\n### Patches\n\nFixed in versions 1.9 and 2.2. We recommend that all users upgrade to address these issues.\n\nCustomers leveraging the ESDK\u2019s streaming features have several options to protect signature validation. One is to ensure that client code reads to the end of the stream before using released plaintext. With this release, using the new API for streaming and falling back to the non-streaming decrypt API for signed messages prevents using any plaintext from signed data before the signature is validated. See https://docs.aws.amazon.com/encryption-sdk/latest/developer-guide/about-versions.html#version2.2.x\n\nUsers processing ESDK messages from untrusted sources should use the new maximum encrypted data keys parameter. See https://docs.aws.amazon.com/encryption-sdk/latest/developer-guide/about-versions.html#version2.2.x\n\n### Workarounds\n\nNone\n\n### For more information\n\nhttps://docs.aws.amazon.com/encryption-sdk/latest/developer-guide/concepts.html#digital-sigs\n\nhttps://docs.aws.amazon.com/encryption-sdk/latest/developer-guide/about-versions.html#version2.2.x\n",
                "fixed_in": [
                    "1.9.0",
                    "2.2.0"
                ],
                "id": "GHSA-x5h4-9gqw-942j",
                "link": "https://osv.dev/vulnerability/GHSA-x5h4-9gqw-942j",
                "source": "osv",
                "summary": null,
                "withdrawn": null
            }
        ]
    },
    "1.4.1": {
        "info": {
            "author": "Amazon Web Services",
            "author_email": "aws-cryptools@amazon.com",
            "bugtrack_url": null,
            "classifiers": [
                "Development Status :: 5 - Production/Stable",
                "Intended Audience :: Developers",
                "License :: OSI Approved :: Apache Software License",
                "Natural Language :: English",
                "Programming Language :: Python",
                "Programming Language :: Python :: 2",
                "Programming Language :: Python :: 2.7",
                "Programming Language :: Python :: 3",
                "Programming Language :: Python :: 3.4",
                "Programming Language :: Python :: 3.5",
                "Programming Language :: Python :: 3.6",
                "Programming Language :: Python :: 3.7",
                "Programming Language :: Python :: Implementation :: CPython",
                "Topic :: Security",
                "Topic :: Security :: Cryptography"
            ],
            "description_content_type": "",
            "docs_url": null,
            "download_url": "",
            "downloads": {
                "last_day": -1,
                "last_month": -1,
                "last_week": -1
            },
            "home_page": "https://github.com/aws/aws-encryption-sdk-python",
            "keywords": "aws-encryption-sdk aws kms encryption",
            "license": "Apache License 2.0",
            "maintainer": "Amazon Web Services",
            "maintainer_email": "",
            "name": "aws-encryption-sdk",
            "package_url": "https://pypi.org/project/aws-encryption-sdk/",
            "platform": "",
            "project_url": "https://pypi.org/project/aws-encryption-sdk/",
            "project_urls": {
                "Homepage": "https://github.com/aws/aws-encryption-sdk-python"
            },
            "release_url": "https://pypi.org/project/aws-encryption-sdk/1.4.1/",
            "requires_dist": [
                "boto3 (>=1.4.4)",
                "cryptography (>=1.8.1)",
                "attrs (>=17.4.0)",
                "wrapt (>=1.10.11)"
            ],
            "requires_python": "",
            "summary": "AWS Encryption SDK implementation for Python",
            "version": "1.4.1",
            "yanked": false,
            "yanked_reason": null
        },
        "last_serial": 14939260,
        "urls": [
            {
                "comment_text": "",
                "digests": {
                    "md5": "3d3fdf6d033c5a73d871af3e43a98723",
                    "sha256": "cd5943adbab9193907401a57542fbf8b412670a2cd115b48cdd5825592f6c223"
                },
                "downloads": -1,
                "filename": "aws_encryption_sdk-1.4.1-py2.py3-none-any.whl",
                "has_sig": false,
                "md5_digest": "3d3fdf6d033c5a73d871af3e43a98723",
                "packagetype": "bdist_wheel",
                "python_version": "py2.py3",
                "requires_python": null,
                "size": 82416,
                "upload_time": "2019-09-20T22:12:50",
                "upload_time_iso_8601": "2019-09-20T22:12:50.406725Z",
                "url": "https://files.pythonhosted.org/packages/97/5b/ff363a3bb5d4b273a1680ca258181b5f08554701a14234b09678a26d66ca/aws_encryption_sdk-1.4.1-py2.py3-none-any.whl",
                "yanked": false,
                "yanked_reason": null
            },
            {
                "comment_text": "",
                "digests": {
                    "md5": "92af82fba5f53279f2f24364fc06bfc0",
                    "sha256": "4f8ea7073e943d1ac82adf9bccfccdd9f817d23e3d49c782862b1814efd1155e"
                },
                "downloads": -1,
                "filename": "aws-encryption-sdk-1.4.1.tar.gz",
                "has_sig": false,
                "md5_digest": "92af82fba5f53279f2f24364fc06bfc0",
                "packagetype": "sdist",
                "python_version": "source",
                "requires_python": null,
                "size": 8058771,
                "upload_time": "2019-09-20T22:12:53",
                "upload_time_iso_8601": "2019-09-20T22:12:53.592525Z",
                "url": "https://files.pythonhosted.org/packages/ed/73/22797798aea426dc9f1fa110cb4f9ebdf17b89a619fda121811651f7fe13/aws-encryption-sdk-1.4.1.tar.gz",
                "yanked": false,
                "yanked_reason": null
            }
        ],
        "vulnerabilities": [
            {
                "aliases": [
                    "CVE-2020-8897"
                ],
                "details": "A weak robustness vulnerability exists in the AWS Encryption SDKs for Java, Python, C and Javalcript prior to versions 2.0.0. Due to the non-committing property of AES-GCM (and other AEAD ciphers such as AES-GCM-SIV or (X)ChaCha20Poly1305) used by the SDKs to encrypt messages, an attacker can craft a unique cyphertext which will decrypt to multiple different results, and becomes especially relevant in a multi-recipient setting. We recommend users update their SDK to 2.0.0 or later.",
                "fixed_in": [
                    "2.0.0"
                ],
                "id": "PYSEC-2020-261",
                "link": "https://osv.dev/vulnerability/PYSEC-2020-261",
                "source": "osv",
                "summary": null,
                "withdrawn": null
            },
            {
                "aliases": [
                    "CVE-2020-8897"
                ],
                "details": "Authors: Thai \"[thaidn](https://twitter.com/xorninja)\" Duong\n\n# Summary\n\nThe following security vulnerabilities was discovered and reported to Amazon, affecting AWS KMS and all versions of [AWS Encryption SDKs](https://docs.aws.amazon.com/encryption-sdk/latest/developer-guide/introduction.html) prior to version 2.0.0:\n\n* **Information leakage**: an attacker can create ciphertexts that would leak the user\u2019s AWS account ID, encryption context, user agent, and IP address upon decryption\n* **Ciphertext forgery**: an attacker can create ciphertexts that are accepted by other users\n* **Robustness**: an attacker can create ciphertexts that decrypt to different plaintexts for different users\n\nThe first two bugs are somewhat surprising because they show that the ciphertext format can lead to vulnerabilities. These bugs (and the infamous [alg: \"None\"](https://auth0.com/blog/critical-vulnerabilities-in-json-web-token-libraries/) bugs in JWT) belong to a class of vulnerabilities called **in-band protocol negotiation**. This is the second time we\u2019ve found in-band protocol negotiation vulnerabilities in AWS cryptography libraries; see this [bug](https://github.com/google/security-research/security/advisories/GHSA-7f33-f4f5-xwgw) in S3 Crypto SDK discovered by my colleague Sophie Schmieg.\n\nIn JWT and S3 SDK the culprit is the algorithm field\u2014here it is the key ID. Because the key ID is used to determine which decryption key to use, it can\u2019t be meaningfully authenticated despite being under the attacker\u2019s control. If the key ID is a URL indicating where to fetch the key, the attacker can replace it with their own URL, and learn side-channel information such as the timing and machines on which the decryption happens (this can also lead to [SSRF](https://portswigger.net/web-security/ssrf) issues, but that\u2019s another topic for another day).\n\nIn AWS, the key ID is a unique [Amazon Resource Name](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html). If an attacker were to capture a ciphertext from a user and replace its key ID with their own, the victim\u2019s AWS account ID, encryption context, user agent, and IP address would be logged to the attacker\u2019s AWS account whenever the victim attempted to decrypt the modified ciphertext.\n\nThe last bug shows that the non-committing property of AES-GCM (and other AEAD ciphers such as [AES-GCM-SIV](https://keymaterial.net/2020/09/07/invisible-salamanders-in-aes-gcm-siv/) or (X)ChaCha20Poly1305) is especially problematic in multi-recipient settings. These ciphers have a property that can cause nonidentical plaintexts when decrypting a single ciphertext with two different keys! For example, you can send a single encrypted email to Alice and Bob which, upon decryption, reads \u201cattack\u201d to Alice and \u201cretreat\u201d to Bob. The AWS Encryption SDKs are vulnerable to this attack because they allow a single ciphertext to be generated for multiple recipients, with each decrypting using a different key. I believe this kind of problem is prevalent. I briefly looked at [JWE](https://tools.ietf.org/html/rfc7516) and I think it is vulnerable.\n\n# Mitigations\n\nAmazon has fixed these bugs in release 2.0.0 of the SDKs. A new major version was required because, unfortunately, the fix for the last bug requires a breaking change from earlier versions. All users are recommended to upgrade. More details about Amazon\u2019s mitigations can be found in [their announcement](https://aws.amazon.com/blogs/security/improved-client-side-encryption-explicit-keyids-and-key-commitment/).\n\nWe\u2019re collaborating with Shay Gueron on a paper regarding fast committing AEADs.\n\n# Vulnerabilities\n\n## Information Leakage\n\nThe [Encrypt](https://docs.aws.amazon.com/kms/latest/APIReference/API_Encrypt.html) API in AWS KMS encrypts plaintext into ciphertext by using a customer master key (CMK). The ciphertext format is undocumented, but it contains metadata that specifies the CMK and the encryption algorithm. I reverse-engineered the format and found the location of the CMK. Externally the CMK is identified by its key ARN, but within a ciphertext it is represented by an internal ID, which remained stable during my testing.\n\nWhen I replaced the internal ID of a CMK in a ciphertext with the internal ID of another CMK, I found that AWS KMS attempted to decrypt the ciphertext with the new CMK. The encryption failed and the failure event\u2014including the AWS Account ID, the user agent and the IP address of the caller\u2014was logged to Cloud Trail in the account that owned the replacement CMK.\n\nThis enables the following attack:\n* The attacker creates a CMK that has a key policy that allows access from everyone. This requires no prior knowledge about the victim.\n* The attacker intercepts a ciphertext from the victim, and replaces its CMK with their CMK.\n* Whenever the victim attempts to decrypt the modified ciphertext, the attacker learns the timing of such actions, the victim\u2019s AWS Account ID, user agent, encryption context, and IP address.\n\nThis attack requires the victim to have an IAM policy that allows them to access the attacker\u2019s CMK. I found that this practice was allowed by the AWS Visual Policy Editor, but I don\u2019t know whether it is common.\n\nThe AWS Encryption SDKs also succumb to this attack. The SDKs implement envelope encryption: encrypting data with a data encryption key (DEK) and then wrapping the DEK with a CMK using the Encrypt API in AWS KMS. The wrapped DEK is stored as part of the final ciphertext (format is defined [here](https://docs.aws.amazon.com/encryption-sdk/latest/developer-guide/message-format.html)). The attacker can mount this attack by replacing the CMK in the wrapped DEK with their own.\n\n```\n{\n    \"eventVersion\": \"1.05\",\n    \"userIdentity\": {\n        \"type\": \"AWSAccount\",\n        \"principalId\": \"<redacted this is the principal ID of the victim>\",\n        \"accountId\": \"<redacted - this is the AWS account ID of the victim>\"\n    },\n    \"eventTime\": \"2020-06-21T21:05:04Z\",\n    \"eventSource\": \"kms.amazonaws.com\",\n    \"eventName\": \"Decrypt\",\n    \"awsRegion\": \"us-west-2\",\n    \"sourceIPAddress\": \"<redacted - this is the IP address of the victim>\",\n    \"userAgent\": \"<redacted - this is the user agent of the victim>\",\n    \"errorCode\": \"InvalidCiphertextException\",\n    \"requestParameters\": {\n        // The encryption context might include other data from the victim\n        \"encryptionContext\": {\n            \"aws-crypto-public-key\": \"AzfNOGOnNYFmpHspKrAm1L6XtRybONkmkhmB/IriKSA7b2NsV4MEPMph9yX2KTPKWw==\"\n        },\n        \"encryptionAlgorithm\": \"SYMMETRIC_DEFAULT\"\n    },\n    \"responseElements\": null,\n    \"requestID\": \"aeced8e8-75a2-42c3-96ac-d1fa2a1c5ee6\",\n    \"eventID\": \"780a0a6e-4ad8-43d4-a426-75d05022f870\",\n    \"readOnly\": true,\n    \"resources\": [\n        {\n            \"accountId\": \"<redacted - this is the account ID of the attacker>\",\n            \"type\": \"AWS::KMS::Key\",\n            \"ARN\": <redacted - this is the key ARN of the attacker>\n        }\n    ],\n    \"eventType\": \"AwsApiCall\",\n    \"recipientAccountId\": \"<redacted - this is the account ID of the attacker>\",\n    \"sharedEventID\": \"033e147c-8a36-42f5-9d6c-9e071eb752b7\"\n}\n```\n**Figure 1: A failure event logged to the attacker\u2019s Cloud Trail when the victim attempted to decrypt a modified ciphertext containing the attacker\u2019s CMK.**\n\n## Ciphertext Forgery\n\nThe [Decrypt](https://docs.aws.amazon.com/kms/latest/APIReference/API_Decrypt.html) API in AWS KMS doesn\u2019t require the caller to specify the CMK. This parameter is required only when the ciphertext was encrypted under an asymmetric CMK. Otherwise, AWS KMS uses the metadata that it adds to the ciphertext blob to determine which CMK was used to encrypt the ciphertext.\n\nThis leads to the following attack:\n* The attacker creates a CMK that has a key policy that allows access from everyone. This requires no prior knowledge about the victim.\n* The attacker generates a ciphertext by calling the Encrypt API with their key.\n* The attacker intercepts a ciphertext from the victim, and replaces it entirely with their ciphertext.\n* The victim successfully decrypts the ciphertext, as if it was encrypted under their own key. The attacker also learns when this happened, the victim\u2019s AWS Account ID, user agent, encryption context, and IP address.\n\nSimilar to the information leakage attack, this attack also requires the victim to have an IAM policy that allows them to access the attacker\u2019s CMK.\n\nThe AWS Encryption SDKs also succumb to this attack. They don\u2019t specify the CMK when they call the Decrypt API to unwrap the DEK.\n\n## Robustness\n\nThe AWS Encryption SDKs allow a single ciphertext to be generated for multiple recipients, with each decrypting using a different key. To that end, it wraps the DEK multiple times, each under a different CMK. The wrapped DEKs can be combined to form a single ciphertext which can be sent to multiple recipients who can use their own credentials to decrypt it. It\u2019s reasonable to expect that all recipients should decrypt the ciphertext to an identical plaintext. However, because of the use of AES-GMAC and AES-GCM, it\u2019s possible to create a ciphertext that decrypts to two valid yet different plaintexts for two different users. In other words, the AWS Encryption SDKs are [not](https://eprint.iacr.org/2008/440.pdf) [robust](https://eprint.iacr.org/2019/016.pdf).\n\nThe encryption of a message under two CMKs can be summarized as follows:\n* A DEK is randomly generated, and two wrapped DEKs are produced by calling the Encrypt API using the two CMKs\n* A per-message AES-GCM key (K) is derived using HKDF from the DEK, a randomly generated message ID, and a fixed algorithm ID.\n* A header is formed from the wrapped DEKs, the encryption context, and other metadata. A header authentication tag is computed on the header using AES-GMAC with K and a zero IV.\n* The message is encrypted using AES-GCM with K, a non-zero IV, and fixed associated additional data. This produces a message authentication tag.\n* The ciphertext consists of the header, the header authentication tag, the encrypted message, and the message authentication tag.\n\n(There\u2019s also a self-signed digital signature that is irrelevant to this discussion).\n\nIn order to decrypt a ciphertext, the AWS Encryption SDKs loops over the list of wrapped DEKs and returns the first one that it can successfully unwrap. The attacker therefore can wrap a unique DEK for each recipient. Next, the attacker exploits the non-committing property of GMAC to produce two messages that have the same GMAC tag under two different keys. The attacker has to do this twice, one for the header authentication tag and one for the message authentication tag.\n\n```\nGiven a data blob B of one 128-bit block B_1, a GMAC tag is computed as follows:\n\nB_1 * H^2 + B_len * H + J\n\nwhere H and J depends on the key and B_len depends on the length of B.\n\nTo find a message that can produce the same tag under two different keys, one\ncan add append to B a new block B_2 whose value can be deduced by solving\nan algebraic equation. That is, we want to find B_2 such that:\n\nB_1 * H^3 + B_2 * H^2 + B_len * H + J = B_1 * H\u2019^3 + B_2 * H\u2019^2 + B_len * H\u2019 + J\u2019\n\nwhere H\u2019 and J\u2019 are the corresponding H and J of the other key.\n\nB_2 is the only unknown value in this equation, thus it can be computed using\nfinite field arithmetics of GF(2^128):\n\nB_2 = [B_1 * (H^3+H\u2019^3) + B_len * (H + H\u2019) + J + J\u2019] * (H^2 + H\u2019^2)^-1.\n```\n**Figure 2: How to find a message that has the same GMAC tag under two different keys.**\n\nThe overall attack works as follows:\n* The attacker generates a random DEK, derives a per-message key K, and encrypts message M with it using AES in counter mode. This generates a ciphertext C.\n* The attacker generates another random DEK\u2019, derives a per-message key K\u2019, and performs trial decryption of C until the decrypted message M\u2019 has desirable properties. For example, if the attacker wants the first bit of M\u2019 different from that of M, this process should only take a few attempts.\n* The attacker finds a block C* such that the GMAC of C\u2019 = C || C* under K and K\u2019 are identical. Denote this tag C\u2019_tag.\n* The attacker wraps DEK and DEK\u2019 under two recipients\u2019 CMK.\n* The attacker forms a header H and adds a block H* to the encryption context such that the new H\u2019 has the same authentication tag H\u2019_tag under K and K\u2019.\n* The attacker output H\u2019, H\u2019_tag, C\u2019, C\u2019_tag.\n\nThis attack is similar to the one discovered in [Facebook Messenger](https://eprint.iacr.org/2019/016.pdf).\n\n# Acknowledgement\n\nI\u2019m grateful to Jen Barnason for carefully editing this advisory. I will never publish anything without her approval! I want to thank my friend and coworker Sophie \u201cQueen of Hashing\u201d Schmieg for wonderful discussions and for showing me how the arithmetic in GF(2^128) works. I want to thank Jonathan Bannet for asking the questions that led to this work.",
                "fixed_in": [
                    "2.0.0"
                ],
                "id": "GHSA-wqgp-vphw-hphf",
                "link": "https://osv.dev/vulnerability/GHSA-wqgp-vphw-hphf",
                "source": "osv",
                "summary": null,
                "withdrawn": null
            },
            {
                "aliases": [],
                "details": "### Impact\n\nThis advisory addresses several LOW severity issues with streaming signed messages and restricting processing of certain types of invalid messages. \n\nThis ESDK supports a streaming mode where callers may stream the plaintext of signed messages before the ECDSA signature is validated. In addition to these signatures, the ESDK uses AES-GCM encryption and all plaintext is verified before being released to a caller. There is no impact on the integrity of the ciphertext or decrypted plaintext, however some callers may rely on the the ECDSA signature for non-repudiation. Without validating the ECDSA signature, an actor with trusted KMS permissions to decrypt a message may also be able to encrypt messages. This update introduces a new API for callers who wish to stream only unsigned messages. \n\nFor customers who process ESDK messages from untrusted sources, this update also introduces a new configuration to limit the number of Encrypted Data Keys (EDKs) that the ESDK will attempt to process per message. This configuration provides customers with a way to limit the number of AWS KMS Decrypt API calls that the ESDK will make per message. This setting will reject messages with more EDKs than the configured limit.\n\nFinally, this update adds early rejection of invalid messages with certain invalid combinations of algorithm suite and header data.\n\n### Patches\n\nFixed in versions 1.9 and 2.2. We recommend that all users upgrade to address these issues.\n\nCustomers leveraging the ESDK\u2019s streaming features have several options to protect signature validation. One is to ensure that client code reads to the end of the stream before using released plaintext. With this release, using the new API for streaming and falling back to the non-streaming decrypt API for signed messages prevents using any plaintext from signed data before the signature is validated. See https://docs.aws.amazon.com/encryption-sdk/latest/developer-guide/about-versions.html#version2.2.x\n\nUsers processing ESDK messages from untrusted sources should use the new maximum encrypted data keys parameter. See https://docs.aws.amazon.com/encryption-sdk/latest/developer-guide/about-versions.html#version2.2.x\n\n### Workarounds\n\nNone\n\n### For more information\n\nhttps://docs.aws.amazon.com/encryption-sdk/latest/developer-guide/concepts.html#digital-sigs\n\nhttps://docs.aws.amazon.com/encryption-sdk/latest/developer-guide/about-versions.html#version2.2.x\n",
                "fixed_in": [
                    "1.9.0",
                    "2.2.0"
                ],
                "id": "GHSA-x5h4-9gqw-942j",
                "link": "https://osv.dev/vulnerability/GHSA-x5h4-9gqw-942j",
                "source": "osv",
                "summary": null,
                "withdrawn": null
            }
        ]
    },
    "1.7.1": {
        "info": {
            "author": "Amazon Web Services",
            "author_email": "aws-cryptools@amazon.com",
            "bugtrack_url": null,
            "classifiers": [
                "Development Status :: 5 - Production/Stable",
                "Intended Audience :: Developers",
                "License :: OSI Approved :: Apache Software License",
                "Natural Language :: English",
                "Programming Language :: Python",
                "Programming Language :: Python :: 2",
                "Programming Language :: Python :: 2.7",
                "Programming Language :: Python :: 3",
                "Programming Language :: Python :: 3.4",
                "Programming Language :: Python :: 3.5",
                "Programming Language :: Python :: 3.6",
                "Programming Language :: Python :: 3.7",
                "Programming Language :: Python :: Implementation :: CPython",
                "Topic :: Security",
                "Topic :: Security :: Cryptography"
            ],
            "description_content_type": "",
            "docs_url": null,
            "download_url": "",
            "downloads": {
                "last_day": -1,
                "last_month": -1,
                "last_week": -1
            },
            "home_page": "https://github.com/aws/aws-encryption-sdk-python",
            "keywords": "aws-encryption-sdk aws kms encryption",
            "license": "Apache License 2.0",
            "maintainer": "Amazon Web Services",
            "maintainer_email": "",
            "name": "aws-encryption-sdk",
            "package_url": "https://pypi.org/project/aws-encryption-sdk/",
            "platform": "",
            "project_url": "https://pypi.org/project/aws-encryption-sdk/",
            "project_urls": {
                "Homepage": "https://github.com/aws/aws-encryption-sdk-python"
            },
            "release_url": "https://pypi.org/project/aws-encryption-sdk/1.7.1/",
            "requires_dist": [
                "boto3 (>=1.4.4)",
                "cryptography (>=1.8.1)",
                "attrs (>=17.4.0)",
                "wrapt (>=1.10.11)"
            ],
            "requires_python": "",
            "summary": "AWS Encryption SDK implementation for Python",
            "version": "1.7.1",
            "yanked": false,
            "yanked_reason": null
        },
        "last_serial": 14939260,
        "urls": [
            {
                "comment_text": "",
                "digests": {
                    "md5": "987ca5bfc2ffb48a285699069361a133",
                    "sha256": "062c8eb3c2fcb2ff35364f08e691534df8fd6b9f443d00d513f23e91072a692e"
                },
                "downloads": -1,
                "filename": "aws_encryption_sdk-1.7.1-py2.py3-none-any.whl",
                "has_sig": false,
                "md5_digest": "987ca5bfc2ffb48a285699069361a133",
                "packagetype": "bdist_wheel",
                "python_version": "py2.py3",
                "requires_python": null,
                "size": 89865,
                "upload_time": "2020-09-25T00:37:48",
                "upload_time_iso_8601": "2020-09-25T00:37:48.586781Z",
                "url": "https://files.pythonhosted.org/packages/7c/5b/5884f2b036b3fd00094d1e5a244917fd10edc64a9cb03b2eac0fd99621b3/aws_encryption_sdk-1.7.1-py2.py3-none-any.whl",
                "yanked": false,
                "yanked_reason": null
            },
            {
                "comment_text": "",
                "digests": {
                    "md5": "3b2bf1796ee401bb698a5b821cd830fc",
                    "sha256": "674c47e2c775926f11652b7bac585667bb07ffb5fc7b512fefa1c4694a665586"
                },
                "downloads": -1,
                "filename": "aws-encryption-sdk-1.7.1.tar.gz",
                "has_sig": false,
                "md5_digest": "3b2bf1796ee401bb698a5b821cd830fc",
                "packagetype": "sdist",
                "python_version": "source",
                "requires_python": null,
                "size": 154954,
                "upload_time": "2020-09-25T00:37:51",
                "upload_time_iso_8601": "2020-09-25T00:37:51.546781Z",
                "url": "https://files.pythonhosted.org/packages/52/a5/3bd3360a2c079ae4b86ff0020f22fe815d0ba2d882a173037be9d415ff9d/aws-encryption-sdk-1.7.1.tar.gz",
                "yanked": false,
                "yanked_reason": null
            }
        ],
        "vulnerabilities": [
            {
                "aliases": [
                    "CVE-2020-8897"
                ],
                "details": "A weak robustness vulnerability exists in the AWS Encryption SDKs for Java, Python, C and Javalcript prior to versions 2.0.0. Due to the non-committing property of AES-GCM (and other AEAD ciphers such as AES-GCM-SIV or (X)ChaCha20Poly1305) used by the SDKs to encrypt messages, an attacker can craft a unique cyphertext which will decrypt to multiple different results, and becomes especially relevant in a multi-recipient setting. We recommend users update their SDK to 2.0.0 or later.",
                "fixed_in": [
                    "2.0.0"
                ],
                "id": "PYSEC-2020-261",
                "link": "https://osv.dev/vulnerability/PYSEC-2020-261",
                "source": "osv",
                "summary": null,
                "withdrawn": null
            },
            {
                "aliases": [
                    "CVE-2020-8897"
                ],
                "details": "Authors: Thai \"[thaidn](https://twitter.com/xorninja)\" Duong\n\n# Summary\n\nThe following security vulnerabilities was discovered and reported to Amazon, affecting AWS KMS and all versions of [AWS Encryption SDKs](https://docs.aws.amazon.com/encryption-sdk/latest/developer-guide/introduction.html) prior to version 2.0.0:\n\n* **Information leakage**: an attacker can create ciphertexts that would leak the user\u2019s AWS account ID, encryption context, user agent, and IP address upon decryption\n* **Ciphertext forgery**: an attacker can create ciphertexts that are accepted by other users\n* **Robustness**: an attacker can create ciphertexts that decrypt to different plaintexts for different users\n\nThe first two bugs are somewhat surprising because they show that the ciphertext format can lead to vulnerabilities. These bugs (and the infamous [alg: \"None\"](https://auth0.com/blog/critical-vulnerabilities-in-json-web-token-libraries/) bugs in JWT) belong to a class of vulnerabilities called **in-band protocol negotiation**. This is the second time we\u2019ve found in-band protocol negotiation vulnerabilities in AWS cryptography libraries; see this [bug](https://github.com/google/security-research/security/advisories/GHSA-7f33-f4f5-xwgw) in S3 Crypto SDK discovered by my colleague Sophie Schmieg.\n\nIn JWT and S3 SDK the culprit is the algorithm field\u2014here it is the key ID. Because the key ID is used to determine which decryption key to use, it can\u2019t be meaningfully authenticated despite being under the attacker\u2019s control. If the key ID is a URL indicating where to fetch the key, the attacker can replace it with their own URL, and learn side-channel information such as the timing and machines on which the decryption happens (this can also lead to [SSRF](https://portswigger.net/web-security/ssrf) issues, but that\u2019s another topic for another day).\n\nIn AWS, the key ID is a unique [Amazon Resource Name](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html). If an attacker were to capture a ciphertext from a user and replace its key ID with their own, the victim\u2019s AWS account ID, encryption context, user agent, and IP address would be logged to the attacker\u2019s AWS account whenever the victim attempted to decrypt the modified ciphertext.\n\nThe last bug shows that the non-committing property of AES-GCM (and other AEAD ciphers such as [AES-GCM-SIV](https://keymaterial.net/2020/09/07/invisible-salamanders-in-aes-gcm-siv/) or (X)ChaCha20Poly1305) is especially problematic in multi-recipient settings. These ciphers have a property that can cause nonidentical plaintexts when decrypting a single ciphertext with two different keys! For example, you can send a single encrypted email to Alice and Bob which, upon decryption, reads \u201cattack\u201d to Alice and \u201cretreat\u201d to Bob. The AWS Encryption SDKs are vulnerable to this attack because they allow a single ciphertext to be generated for multiple recipients, with each decrypting using a different key. I believe this kind of problem is prevalent. I briefly looked at [JWE](https://tools.ietf.org/html/rfc7516) and I think it is vulnerable.\n\n# Mitigations\n\nAmazon has fixed these bugs in release 2.0.0 of the SDKs. A new major version was required because, unfortunately, the fix for the last bug requires a breaking change from earlier versions. All users are recommended to upgrade. More details about Amazon\u2019s mitigations can be found in [their announcement](https://aws.amazon.com/blogs/security/improved-client-side-encryption-explicit-keyids-and-key-commitment/).\n\nWe\u2019re collaborating with Shay Gueron on a paper regarding fast committing AEADs.\n\n# Vulnerabilities\n\n## Information Leakage\n\nThe [Encrypt](https://docs.aws.amazon.com/kms/latest/APIReference/API_Encrypt.html) API in AWS KMS encrypts plaintext into ciphertext by using a customer master key (CMK). The ciphertext format is undocumented, but it contains metadata that specifies the CMK and the encryption algorithm. I reverse-engineered the format and found the location of the CMK. Externally the CMK is identified by its key ARN, but within a ciphertext it is represented by an internal ID, which remained stable during my testing.\n\nWhen I replaced the internal ID of a CMK in a ciphertext with the internal ID of another CMK, I found that AWS KMS attempted to decrypt the ciphertext with the new CMK. The encryption failed and the failure event\u2014including the AWS Account ID, the user agent and the IP address of the caller\u2014was logged to Cloud Trail in the account that owned the replacement CMK.\n\nThis enables the following attack:\n* The attacker creates a CMK that has a key policy that allows access from everyone. This requires no prior knowledge about the victim.\n* The attacker intercepts a ciphertext from the victim, and replaces its CMK with their CMK.\n* Whenever the victim attempts to decrypt the modified ciphertext, the attacker learns the timing of such actions, the victim\u2019s AWS Account ID, user agent, encryption context, and IP address.\n\nThis attack requires the victim to have an IAM policy that allows them to access the attacker\u2019s CMK. I found that this practice was allowed by the AWS Visual Policy Editor, but I don\u2019t know whether it is common.\n\nThe AWS Encryption SDKs also succumb to this attack. The SDKs implement envelope encryption: encrypting data with a data encryption key (DEK) and then wrapping the DEK with a CMK using the Encrypt API in AWS KMS. The wrapped DEK is stored as part of the final ciphertext (format is defined [here](https://docs.aws.amazon.com/encryption-sdk/latest/developer-guide/message-format.html)). The attacker can mount this attack by replacing the CMK in the wrapped DEK with their own.\n\n```\n{\n    \"eventVersion\": \"1.05\",\n    \"userIdentity\": {\n        \"type\": \"AWSAccount\",\n        \"principalId\": \"<redacted this is the principal ID of the victim>\",\n        \"accountId\": \"<redacted - this is the AWS account ID of the victim>\"\n    },\n    \"eventTime\": \"2020-06-21T21:05:04Z\",\n    \"eventSource\": \"kms.amazonaws.com\",\n    \"eventName\": \"Decrypt\",\n    \"awsRegion\": \"us-west-2\",\n    \"sourceIPAddress\": \"<redacted - this is the IP address of the victim>\",\n    \"userAgent\": \"<redacted - this is the user agent of the victim>\",\n    \"errorCode\": \"InvalidCiphertextException\",\n    \"requestParameters\": {\n        // The encryption context might include other data from the victim\n        \"encryptionContext\": {\n            \"aws-crypto-public-key\": \"AzfNOGOnNYFmpHspKrAm1L6XtRybONkmkhmB/IriKSA7b2NsV4MEPMph9yX2KTPKWw==\"\n        },\n        \"encryptionAlgorithm\": \"SYMMETRIC_DEFAULT\"\n    },\n    \"responseElements\": null,\n    \"requestID\": \"aeced8e8-75a2-42c3-96ac-d1fa2a1c5ee6\",\n    \"eventID\": \"780a0a6e-4ad8-43d4-a426-75d05022f870\",\n    \"readOnly\": true,\n    \"resources\": [\n        {\n            \"accountId\": \"<redacted - this is the account ID of the attacker>\",\n            \"type\": \"AWS::KMS::Key\",\n            \"ARN\": <redacted - this is the key ARN of the attacker>\n        }\n    ],\n    \"eventType\": \"AwsApiCall\",\n    \"recipientAccountId\": \"<redacted - this is the account ID of the attacker>\",\n    \"sharedEventID\": \"033e147c-8a36-42f5-9d6c-9e071eb752b7\"\n}\n```\n**Figure 1: A failure event logged to the attacker\u2019s Cloud Trail when the victim attempted to decrypt a modified ciphertext containing the attacker\u2019s CMK.**\n\n## Ciphertext Forgery\n\nThe [Decrypt](https://docs.aws.amazon.com/kms/latest/APIReference/API_Decrypt.html) API in AWS KMS doesn\u2019t require the caller to specify the CMK. This parameter is required only when the ciphertext was encrypted under an asymmetric CMK. Otherwise, AWS KMS uses the metadata that it adds to the ciphertext blob to determine which CMK was used to encrypt the ciphertext.\n\nThis leads to the following attack:\n* The attacker creates a CMK that has a key policy that allows access from everyone. This requires no prior knowledge about the victim.\n* The attacker generates a ciphertext by calling the Encrypt API with their key.\n* The attacker intercepts a ciphertext from the victim, and replaces it entirely with their ciphertext.\n* The victim successfully decrypts the ciphertext, as if it was encrypted under their own key. The attacker also learns when this happened, the victim\u2019s AWS Account ID, user agent, encryption context, and IP address.\n\nSimilar to the information leakage attack, this attack also requires the victim to have an IAM policy that allows them to access the attacker\u2019s CMK.\n\nThe AWS Encryption SDKs also succumb to this attack. They don\u2019t specify the CMK when they call the Decrypt API to unwrap the DEK.\n\n## Robustness\n\nThe AWS Encryption SDKs allow a single ciphertext to be generated for multiple recipients, with each decrypting using a different key. To that end, it wraps the DEK multiple times, each under a different CMK. The wrapped DEKs can be combined to form a single ciphertext which can be sent to multiple recipients who can use their own credentials to decrypt it. It\u2019s reasonable to expect that all recipients should decrypt the ciphertext to an identical plaintext. However, because of the use of AES-GMAC and AES-GCM, it\u2019s possible to create a ciphertext that decrypts to two valid yet different plaintexts for two different users. In other words, the AWS Encryption SDKs are [not](https://eprint.iacr.org/2008/440.pdf) [robust](https://eprint.iacr.org/2019/016.pdf).\n\nThe encryption of a message under two CMKs can be summarized as follows:\n* A DEK is randomly generated, and two wrapped DEKs are produced by calling the Encrypt API using the two CMKs\n* A per-message AES-GCM key (K) is derived using HKDF from the DEK, a randomly generated message ID, and a fixed algorithm ID.\n* A header is formed from the wrapped DEKs, the encryption context, and other metadata. A header authentication tag is computed on the header using AES-GMAC with K and a zero IV.\n* The message is encrypted using AES-GCM with K, a non-zero IV, and fixed associated additional data. This produces a message authentication tag.\n* The ciphertext consists of the header, the header authentication tag, the encrypted message, and the message authentication tag.\n\n(There\u2019s also a self-signed digital signature that is irrelevant to this discussion).\n\nIn order to decrypt a ciphertext, the AWS Encryption SDKs loops over the list of wrapped DEKs and returns the first one that it can successfully unwrap. The attacker therefore can wrap a unique DEK for each recipient. Next, the attacker exploits the non-committing property of GMAC to produce two messages that have the same GMAC tag under two different keys. The attacker has to do this twice, one for the header authentication tag and one for the message authentication tag.\n\n```\nGiven a data blob B of one 128-bit block B_1, a GMAC tag is computed as follows:\n\nB_1 * H^2 + B_len * H + J\n\nwhere H and J depends on the key and B_len depends on the length of B.\n\nTo find a message that can produce the same tag under two different keys, one\ncan add append to B a new block B_2 whose value can be deduced by solving\nan algebraic equation. That is, we want to find B_2 such that:\n\nB_1 * H^3 + B_2 * H^2 + B_len * H + J = B_1 * H\u2019^3 + B_2 * H\u2019^2 + B_len * H\u2019 + J\u2019\n\nwhere H\u2019 and J\u2019 are the corresponding H and J of the other key.\n\nB_2 is the only unknown value in this equation, thus it can be computed using\nfinite field arithmetics of GF(2^128):\n\nB_2 = [B_1 * (H^3+H\u2019^3) + B_len * (H + H\u2019) + J + J\u2019] * (H^2 + H\u2019^2)^-1.\n```\n**Figure 2: How to find a message that has the same GMAC tag under two different keys.**\n\nThe overall attack works as follows:\n* The attacker generates a random DEK, derives a per-message key K, and encrypts message M with it using AES in counter mode. This generates a ciphertext C.\n* The attacker generates another random DEK\u2019, derives a per-message key K\u2019, and performs trial decryption of C until the decrypted message M\u2019 has desirable properties. For example, if the attacker wants the first bit of M\u2019 different from that of M, this process should only take a few attempts.\n* The attacker finds a block C* such that the GMAC of C\u2019 = C || C* under K and K\u2019 are identical. Denote this tag C\u2019_tag.\n* The attacker wraps DEK and DEK\u2019 under two recipients\u2019 CMK.\n* The attacker forms a header H and adds a block H* to the encryption context such that the new H\u2019 has the same authentication tag H\u2019_tag under K and K\u2019.\n* The attacker output H\u2019, H\u2019_tag, C\u2019, C\u2019_tag.\n\nThis attack is similar to the one discovered in [Facebook Messenger](https://eprint.iacr.org/2019/016.pdf).\n\n# Acknowledgement\n\nI\u2019m grateful to Jen Barnason for carefully editing this advisory. I will never publish anything without her approval! I want to thank my friend and coworker Sophie \u201cQueen of Hashing\u201d Schmieg for wonderful discussions and for showing me how the arithmetic in GF(2^128) works. I want to thank Jonathan Bannet for asking the questions that led to this work.",
                "fixed_in": [
                    "2.0.0"
                ],
                "id": "GHSA-wqgp-vphw-hphf",
                "link": "https://osv.dev/vulnerability/GHSA-wqgp-vphw-hphf",
                "source": "osv",
                "summary": null,
                "withdrawn": null
            },
            {
                "aliases": [],
                "details": "### Impact\n\nThis advisory addresses several LOW severity issues with streaming signed messages and restricting processing of certain types of invalid messages. \n\nThis ESDK supports a streaming mode where callers may stream the plaintext of signed messages before the ECDSA signature is validated. In addition to these signatures, the ESDK uses AES-GCM encryption and all plaintext is verified before being released to a caller. There is no impact on the integrity of the ciphertext or decrypted plaintext, however some callers may rely on the the ECDSA signature for non-repudiation. Without validating the ECDSA signature, an actor with trusted KMS permissions to decrypt a message may also be able to encrypt messages. This update introduces a new API for callers who wish to stream only unsigned messages. \n\nFor customers who process ESDK messages from untrusted sources, this update also introduces a new configuration to limit the number of Encrypted Data Keys (EDKs) that the ESDK will attempt to process per message. This configuration provides customers with a way to limit the number of AWS KMS Decrypt API calls that the ESDK will make per message. This setting will reject messages with more EDKs than the configured limit.\n\nFinally, this update adds early rejection of invalid messages with certain invalid combinations of algorithm suite and header data.\n\n### Patches\n\nFixed in versions 1.9 and 2.2. We recommend that all users upgrade to address these issues.\n\nCustomers leveraging the ESDK\u2019s streaming features have several options to protect signature validation. One is to ensure that client code reads to the end of the stream before using released plaintext. With this release, using the new API for streaming and falling back to the non-streaming decrypt API for signed messages prevents using any plaintext from signed data before the signature is validated. See https://docs.aws.amazon.com/encryption-sdk/latest/developer-guide/about-versions.html#version2.2.x\n\nUsers processing ESDK messages from untrusted sources should use the new maximum encrypted data keys parameter. See https://docs.aws.amazon.com/encryption-sdk/latest/developer-guide/about-versions.html#version2.2.x\n\n### Workarounds\n\nNone\n\n### For more information\n\nhttps://docs.aws.amazon.com/encryption-sdk/latest/developer-guide/concepts.html#digital-sigs\n\nhttps://docs.aws.amazon.com/encryption-sdk/latest/developer-guide/about-versions.html#version2.2.x\n",
                "fixed_in": [
                    "1.9.0",
                    "2.2.0"
                ],
                "id": "GHSA-x5h4-9gqw-942j",
                "link": "https://osv.dev/vulnerability/GHSA-x5h4-9gqw-942j",
                "source": "osv",
                "summary": null,
                "withdrawn": null
            }
        ]
    },
    "1.9.0": {
        "info": {
            "author": "Amazon Web Services",
            "author_email": "aws-cryptools@amazon.com",
            "bugtrack_url": null,
            "classifiers": [
                "Development Status :: 5 - Production/Stable",
                "Intended Audience :: Developers",
                "License :: OSI Approved :: Apache Software License",
                "Natural Language :: English",
                "Programming Language :: Python",
                "Programming Language :: Python :: 2",
                "Programming Language :: Python :: 2.7",
                "Programming Language :: Python :: 3",
                "Programming Language :: Python :: 3.4",
                "Programming Language :: Python :: 3.5",
                "Programming Language :: Python :: 3.6",
                "Programming Language :: Python :: 3.7",
                "Programming Language :: Python :: 3.8",
                "Programming Language :: Python :: 3.9",
                "Programming Language :: Python :: Implementation :: CPython",
                "Topic :: Security",
                "Topic :: Security :: Cryptography"
            ],
            "description_content_type": "",
            "docs_url": null,
            "download_url": "",
            "downloads": {
                "last_day": -1,
                "last_month": -1,
                "last_week": -1
            },
            "home_page": "https://github.com/aws/aws-encryption-sdk-python",
            "keywords": "aws-encryption-sdk aws kms encryption",
            "license": "Apache License 2.0",
            "maintainer": "Amazon Web Services",
            "maintainer_email": "",
            "name": "aws-encryption-sdk",
            "package_url": "https://pypi.org/project/aws-encryption-sdk/",
            "platform": "",
            "project_url": "https://pypi.org/project/aws-encryption-sdk/",
            "project_urls": {
                "Homepage": "https://github.com/aws/aws-encryption-sdk-python"
            },
            "release_url": "https://pypi.org/project/aws-encryption-sdk/1.9.0/",
            "requires_dist": [
                "boto3 (>=1.10.0)",
                "cryptography (>=2.5.0)",
                "attrs (>=17.4.0)",
                "wrapt (>=1.10.11)"
            ],
            "requires_python": "",
            "summary": "AWS Encryption SDK implementation for Python",
            "version": "1.9.0",
            "yanked": false,
            "yanked_reason": null
        },
        "last_serial": 14939260,
        "urls": [
            {
                "comment_text": "",
                "digests": {
                    "md5": "01d57a9d75c4715269d7d711285b69c5",
                    "sha256": "418f0bed46113d74bad096d2f2ad58e9f2d116f5b3c019c70db4b241053f9f2e"
                },
                "downloads": -1,
                "filename": "aws_encryption_sdk-1.9.0-py2.py3-none-any.whl",
                "has_sig": false,
                "md5_digest": "01d57a9d75c4715269d7d711285b69c5",
                "packagetype": "bdist_wheel",
                "python_version": "py2.py3",
                "requires_python": null,
                "size": 92107,
                "upload_time": "2021-05-27T18:05:32",
                "upload_time_iso_8601": "2021-05-27T18:05:32.948957Z",
                "url": "https://files.pythonhosted.org/packages/20/15/a0bc171b54af1255581d78fa2c9cbd0e42628789fd61ef855dd302757017/aws_encryption_sdk-1.9.0-py2.py3-none-any.whl",
                "yanked": false,
                "yanked_reason": null
            },
            {
                "comment_text": "",
                "digests": {
                    "md5": "0bd07a18e31a972d18083ac7cfb0c660",
                    "sha256": "906af0955f6c4c3a45ed02e3dd1b6e010aa5854b3691da350b82827b6265e30b"
                },
                "downloads": -1,
                "filename": "aws-encryption-sdk-1.9.0.tar.gz",
                "has_sig": false,
                "md5_digest": "0bd07a18e31a972d18083ac7cfb0c660",
                "packagetype": "sdist",
                "python_version": "source",
                "requires_python": null,
                "size": 157807,
                "upload_time": "2021-05-27T18:05:35",
                "upload_time_iso_8601": "2021-05-27T18:05:35.820206Z",
                "url": "https://files.pythonhosted.org/packages/ee/0d/4601d98d4f50b4396566a41ac777dea547541ef3f9e0c96008a2f564e35e/aws-encryption-sdk-1.9.0.tar.gz",
                "yanked": false,
                "yanked_reason": null
            }
        ],
        "vulnerabilities": [
            {
                "aliases": [
                    "CVE-2020-8897"
                ],
                "details": "A weak robustness vulnerability exists in the AWS Encryption SDKs for Java, Python, C and Javalcript prior to versions 2.0.0. Due to the non-committing property of AES-GCM (and other AEAD ciphers such as AES-GCM-SIV or (X)ChaCha20Poly1305) used by the SDKs to encrypt messages, an attacker can craft a unique cyphertext which will decrypt to multiple different results, and becomes especially relevant in a multi-recipient setting. We recommend users update their SDK to 2.0.0 or later.",
                "fixed_in": [
                    "2.0.0"
                ],
                "id": "PYSEC-2020-261",
                "link": "https://osv.dev/vulnerability/PYSEC-2020-261",
                "source": "osv",
                "summary": null,
                "withdrawn": null
            },
            {
                "aliases": [
                    "CVE-2020-8897"
                ],
                "details": "Authors: Thai \"[thaidn](https://twitter.com/xorninja)\" Duong\n\n# Summary\n\nThe following security vulnerabilities was discovered and reported to Amazon, affecting AWS KMS and all versions of [AWS Encryption SDKs](https://docs.aws.amazon.com/encryption-sdk/latest/developer-guide/introduction.html) prior to version 2.0.0:\n\n* **Information leakage**: an attacker can create ciphertexts that would leak the user\u2019s AWS account ID, encryption context, user agent, and IP address upon decryption\n* **Ciphertext forgery**: an attacker can create ciphertexts that are accepted by other users\n* **Robustness**: an attacker can create ciphertexts that decrypt to different plaintexts for different users\n\nThe first two bugs are somewhat surprising because they show that the ciphertext format can lead to vulnerabilities. These bugs (and the infamous [alg: \"None\"](https://auth0.com/blog/critical-vulnerabilities-in-json-web-token-libraries/) bugs in JWT) belong to a class of vulnerabilities called **in-band protocol negotiation**. This is the second time we\u2019ve found in-band protocol negotiation vulnerabilities in AWS cryptography libraries; see this [bug](https://github.com/google/security-research/security/advisories/GHSA-7f33-f4f5-xwgw) in S3 Crypto SDK discovered by my colleague Sophie Schmieg.\n\nIn JWT and S3 SDK the culprit is the algorithm field\u2014here it is the key ID. Because the key ID is used to determine which decryption key to use, it can\u2019t be meaningfully authenticated despite being under the attacker\u2019s control. If the key ID is a URL indicating where to fetch the key, the attacker can replace it with their own URL, and learn side-channel information such as the timing and machines on which the decryption happens (this can also lead to [SSRF](https://portswigger.net/web-security/ssrf) issues, but that\u2019s another topic for another day).\n\nIn AWS, the key ID is a unique [Amazon Resource Name](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html). If an attacker were to capture a ciphertext from a user and replace its key ID with their own, the victim\u2019s AWS account ID, encryption context, user agent, and IP address would be logged to the attacker\u2019s AWS account whenever the victim attempted to decrypt the modified ciphertext.\n\nThe last bug shows that the non-committing property of AES-GCM (and other AEAD ciphers such as [AES-GCM-SIV](https://keymaterial.net/2020/09/07/invisible-salamanders-in-aes-gcm-siv/) or (X)ChaCha20Poly1305) is especially problematic in multi-recipient settings. These ciphers have a property that can cause nonidentical plaintexts when decrypting a single ciphertext with two different keys! For example, you can send a single encrypted email to Alice and Bob which, upon decryption, reads \u201cattack\u201d to Alice and \u201cretreat\u201d to Bob. The AWS Encryption SDKs are vulnerable to this attack because they allow a single ciphertext to be generated for multiple recipients, with each decrypting using a different key. I believe this kind of problem is prevalent. I briefly looked at [JWE](https://tools.ietf.org/html/rfc7516) and I think it is vulnerable.\n\n# Mitigations\n\nAmazon has fixed these bugs in release 2.0.0 of the SDKs. A new major version was required because, unfortunately, the fix for the last bug requires a breaking change from earlier versions. All users are recommended to upgrade. More details about Amazon\u2019s mitigations can be found in [their announcement](https://aws.amazon.com/blogs/security/improved-client-side-encryption-explicit-keyids-and-key-commitment/).\n\nWe\u2019re collaborating with Shay Gueron on a paper regarding fast committing AEADs.\n\n# Vulnerabilities\n\n## Information Leakage\n\nThe [Encrypt](https://docs.aws.amazon.com/kms/latest/APIReference/API_Encrypt.html) API in AWS KMS encrypts plaintext into ciphertext by using a customer master key (CMK). The ciphertext format is undocumented, but it contains metadata that specifies the CMK and the encryption algorithm. I reverse-engineered the format and found the location of the CMK. Externally the CMK is identified by its key ARN, but within a ciphertext it is represented by an internal ID, which remained stable during my testing.\n\nWhen I replaced the internal ID of a CMK in a ciphertext with the internal ID of another CMK, I found that AWS KMS attempted to decrypt the ciphertext with the new CMK. The encryption failed and the failure event\u2014including the AWS Account ID, the user agent and the IP address of the caller\u2014was logged to Cloud Trail in the account that owned the replacement CMK.\n\nThis enables the following attack:\n* The attacker creates a CMK that has a key policy that allows access from everyone. This requires no prior knowledge about the victim.\n* The attacker intercepts a ciphertext from the victim, and replaces its CMK with their CMK.\n* Whenever the victim attempts to decrypt the modified ciphertext, the attacker learns the timing of such actions, the victim\u2019s AWS Account ID, user agent, encryption context, and IP address.\n\nThis attack requires the victim to have an IAM policy that allows them to access the attacker\u2019s CMK. I found that this practice was allowed by the AWS Visual Policy Editor, but I don\u2019t know whether it is common.\n\nThe AWS Encryption SDKs also succumb to this attack. The SDKs implement envelope encryption: encrypting data with a data encryption key (DEK) and then wrapping the DEK with a CMK using the Encrypt API in AWS KMS. The wrapped DEK is stored as part of the final ciphertext (format is defined [here](https://docs.aws.amazon.com/encryption-sdk/latest/developer-guide/message-format.html)). The attacker can mount this attack by replacing the CMK in the wrapped DEK with their own.\n\n```\n{\n    \"eventVersion\": \"1.05\",\n    \"userIdentity\": {\n        \"type\": \"AWSAccount\",\n        \"principalId\": \"<redacted this is the principal ID of the victim>\",\n        \"accountId\": \"<redacted - this is the AWS account ID of the victim>\"\n    },\n    \"eventTime\": \"2020-06-21T21:05:04Z\",\n    \"eventSource\": \"kms.amazonaws.com\",\n    \"eventName\": \"Decrypt\",\n    \"awsRegion\": \"us-west-2\",\n    \"sourceIPAddress\": \"<redacted - this is the IP address of the victim>\",\n    \"userAgent\": \"<redacted - this is the user agent of the victim>\",\n    \"errorCode\": \"InvalidCiphertextException\",\n    \"requestParameters\": {\n        // The encryption context might include other data from the victim\n        \"encryptionContext\": {\n            \"aws-crypto-public-key\": \"AzfNOGOnNYFmpHspKrAm1L6XtRybONkmkhmB/IriKSA7b2NsV4MEPMph9yX2KTPKWw==\"\n        },\n        \"encryptionAlgorithm\": \"SYMMETRIC_DEFAULT\"\n    },\n    \"responseElements\": null,\n    \"requestID\": \"aeced8e8-75a2-42c3-96ac-d1fa2a1c5ee6\",\n    \"eventID\": \"780a0a6e-4ad8-43d4-a426-75d05022f870\",\n    \"readOnly\": true,\n    \"resources\": [\n        {\n            \"accountId\": \"<redacted - this is the account ID of the attacker>\",\n            \"type\": \"AWS::KMS::Key\",\n            \"ARN\": <redacted - this is the key ARN of the attacker>\n        }\n    ],\n    \"eventType\": \"AwsApiCall\",\n    \"recipientAccountId\": \"<redacted - this is the account ID of the attacker>\",\n    \"sharedEventID\": \"033e147c-8a36-42f5-9d6c-9e071eb752b7\"\n}\n```\n**Figure 1: A failure event logged to the attacker\u2019s Cloud Trail when the victim attempted to decrypt a modified ciphertext containing the attacker\u2019s CMK.**\n\n## Ciphertext Forgery\n\nThe [Decrypt](https://docs.aws.amazon.com/kms/latest/APIReference/API_Decrypt.html) API in AWS KMS doesn\u2019t require the caller to specify the CMK. This parameter is required only when the ciphertext was encrypted under an asymmetric CMK. Otherwise, AWS KMS uses the metadata that it adds to the ciphertext blob to determine which CMK was used to encrypt the ciphertext.\n\nThis leads to the following attack:\n* The attacker creates a CMK that has a key policy that allows access from everyone. This requires no prior knowledge about the victim.\n* The attacker generates a ciphertext by calling the Encrypt API with their key.\n* The attacker intercepts a ciphertext from the victim, and replaces it entirely with their ciphertext.\n* The victim successfully decrypts the ciphertext, as if it was encrypted under their own key. The attacker also learns when this happened, the victim\u2019s AWS Account ID, user agent, encryption context, and IP address.\n\nSimilar to the information leakage attack, this attack also requires the victim to have an IAM policy that allows them to access the attacker\u2019s CMK.\n\nThe AWS Encryption SDKs also succumb to this attack. They don\u2019t specify the CMK when they call the Decrypt API to unwrap the DEK.\n\n## Robustness\n\nThe AWS Encryption SDKs allow a single ciphertext to be generated for multiple recipients, with each decrypting using a different key. To that end, it wraps the DEK multiple times, each under a different CMK. The wrapped DEKs can be combined to form a single ciphertext which can be sent to multiple recipients who can use their own credentials to decrypt it. It\u2019s reasonable to expect that all recipients should decrypt the ciphertext to an identical plaintext. However, because of the use of AES-GMAC and AES-GCM, it\u2019s possible to create a ciphertext that decrypts to two valid yet different plaintexts for two different users. In other words, the AWS Encryption SDKs are [not](https://eprint.iacr.org/2008/440.pdf) [robust](https://eprint.iacr.org/2019/016.pdf).\n\nThe encryption of a message under two CMKs can be summarized as follows:\n* A DEK is randomly generated, and two wrapped DEKs are produced by calling the Encrypt API using the two CMKs\n* A per-message AES-GCM key (K) is derived using HKDF from the DEK, a randomly generated message ID, and a fixed algorithm ID.\n* A header is formed from the wrapped DEKs, the encryption context, and other metadata. A header authentication tag is computed on the header using AES-GMAC with K and a zero IV.\n* The message is encrypted using AES-GCM with K, a non-zero IV, and fixed associated additional data. This produces a message authentication tag.\n* The ciphertext consists of the header, the header authentication tag, the encrypted message, and the message authentication tag.\n\n(There\u2019s also a self-signed digital signature that is irrelevant to this discussion).\n\nIn order to decrypt a ciphertext, the AWS Encryption SDKs loops over the list of wrapped DEKs and returns the first one that it can successfully unwrap. The attacker therefore can wrap a unique DEK for each recipient. Next, the attacker exploits the non-committing property of GMAC to produce two messages that have the same GMAC tag under two different keys. The attacker has to do this twice, one for the header authentication tag and one for the message authentication tag.\n\n```\nGiven a data blob B of one 128-bit block B_1, a GMAC tag is computed as follows:\n\nB_1 * H^2 + B_len * H + J\n\nwhere H and J depends on the key and B_len depends on the length of B.\n\nTo find a message that can produce the same tag under two different keys, one\ncan add append to B a new block B_2 whose value can be deduced by solving\nan algebraic equation. That is, we want to find B_2 such that:\n\nB_1 * H^3 + B_2 * H^2 + B_len * H + J = B_1 * H\u2019^3 + B_2 * H\u2019^2 + B_len * H\u2019 + J\u2019\n\nwhere H\u2019 and J\u2019 are the corresponding H and J of the other key.\n\nB_2 is the only unknown value in this equation, thus it can be computed using\nfinite field arithmetics of GF(2^128):\n\nB_2 = [B_1 * (H^3+H\u2019^3) + B_len * (H + H\u2019) + J + J\u2019] * (H^2 + H\u2019^2)^-1.\n```\n**Figure 2: How to find a message that has the same GMAC tag under two different keys.**\n\nThe overall attack works as follows:\n* The attacker generates a random DEK, derives a per-message key K, and encrypts message M with it using AES in counter mode. This generates a ciphertext C.\n* The attacker generates another random DEK\u2019, derives a per-message key K\u2019, and performs trial decryption of C until the decrypted message M\u2019 has desirable properties. For example, if the attacker wants the first bit of M\u2019 different from that of M, this process should only take a few attempts.\n* The attacker finds a block C* such that the GMAC of C\u2019 = C || C* under K and K\u2019 are identical. Denote this tag C\u2019_tag.\n* The attacker wraps DEK and DEK\u2019 under two recipients\u2019 CMK.\n* The attacker forms a header H and adds a block H* to the encryption context such that the new H\u2019 has the same authentication tag H\u2019_tag under K and K\u2019.\n* The attacker output H\u2019, H\u2019_tag, C\u2019, C\u2019_tag.\n\nThis attack is similar to the one discovered in [Facebook Messenger](https://eprint.iacr.org/2019/016.pdf).\n\n# Acknowledgement\n\nI\u2019m grateful to Jen Barnason for carefully editing this advisory. I will never publish anything without her approval! I want to thank my friend and coworker Sophie \u201cQueen of Hashing\u201d Schmieg for wonderful discussions and for showing me how the arithmetic in GF(2^128) works. I want to thank Jonathan Bannet for asking the questions that led to this work.",
                "fixed_in": [
                    "2.0.0"
                ],
                "id": "GHSA-wqgp-vphw-hphf",
                "link": "https://osv.dev/vulnerability/GHSA-wqgp-vphw-hphf",
                "source": "osv",
                "summary": null,
                "withdrawn": null
            }
        ]
    },
    "2.0.0": {
        "info": {
            "author": "Amazon Web Services",
            "author_email": "aws-cryptools@amazon.com",
            "bugtrack_url": null,
            "classifiers": [
                "Development Status :: 5 - Production/Stable",
                "Intended Audience :: Developers",
                "License :: OSI Approved :: Apache Software License",
                "Natural Language :: English",
                "Programming Language :: Python",
                "Programming Language :: Python :: 2",
                "Programming Language :: Python :: 2.7",
                "Programming Language :: Python :: 3",
                "Programming Language :: Python :: 3.4",
                "Programming Language :: Python :: 3.5",
                "Programming Language :: Python :: 3.6",
                "Programming Language :: Python :: 3.7",
                "Programming Language :: Python :: Implementation :: CPython",
                "Topic :: Security",
                "Topic :: Security :: Cryptography"
            ],
            "description_content_type": "",
            "docs_url": null,
            "download_url": "",
            "downloads": {
                "last_day": -1,
                "last_month": -1,
                "last_week": -1
            },
            "home_page": "https://github.com/aws/aws-encryption-sdk-python",
            "keywords": "aws-encryption-sdk aws kms encryption",
            "license": "Apache License 2.0",
            "maintainer": "Amazon Web Services",
            "maintainer_email": "",
            "name": "aws-encryption-sdk",
            "package_url": "https://pypi.org/project/aws-encryption-sdk/",
            "platform": "",
            "project_url": "https://pypi.org/project/aws-encryption-sdk/",
            "project_urls": {
                "Homepage": "https://github.com/aws/aws-encryption-sdk-python"
            },
            "release_url": "https://pypi.org/project/aws-encryption-sdk/2.0.0/",
            "requires_dist": [
                "boto3 (>=1.4.4)",
                "cryptography (>=1.8.1)",
                "attrs (>=17.4.0)",
                "wrapt (>=1.10.11)"
            ],
            "requires_python": "",
            "summary": "AWS Encryption SDK implementation for Python",
            "version": "2.0.0",
            "yanked": false,
            "yanked_reason": null
        },
        "last_serial": 14939260,
        "urls": [
            {
                "comment_text": "",
                "digests": {
                    "md5": "8d9ab221f70f5f401b6cd5429c88510a",
                    "sha256": "e0b1da3f9791c18d9daf349f9c346254f8520e77dc411cf19c9b6ed1c547371f"
                },
                "downloads": -1,
                "filename": "aws_encryption_sdk-2.0.0-py2.py3-none-any.whl",
                "has_sig": false,
                "md5_digest": "8d9ab221f70f5f401b6cd5429c88510a",
                "packagetype": "bdist_wheel",
                "python_version": "py2.py3",
                "requires_python": null,
                "size": 89505,
                "upload_time": "2020-09-25T01:45:36",
                "upload_time_iso_8601": "2020-09-25T01:45:36.105929Z",
                "url": "https://files.pythonhosted.org/packages/a3/a4/9b21e831c310ce82517997ce8fbe59ad7bd92f6cbed83e1266027c21d5b4/aws_encryption_sdk-2.0.0-py2.py3-none-any.whl",
                "yanked": false,
                "yanked_reason": null
            },
            {
                "comment_text": "",
                "digests": {
                    "md5": "25b930895267bc010df29c134687f993",
                    "sha256": "7094dfdb05ff01c6f355136fce02e42350c62a80b64d078cf068785db8f80f92"
                },
                "downloads": -1,
                "filename": "aws-encryption-sdk-2.0.0.tar.gz",
                "has_sig": false,
                "md5_digest": "25b930895267bc010df29c134687f993",
                "packagetype": "sdist",
                "python_version": "source",
                "requires_python": null,
                "size": 155811,
                "upload_time": "2020-09-25T01:45:37",
                "upload_time_iso_8601": "2020-09-25T01:45:37.984145Z",
                "url": "https://files.pythonhosted.org/packages/13/40/6cb2ab95a008ed4fe5794439734f9d1955205ede8b79d22da82465add80a/aws-encryption-sdk-2.0.0.tar.gz",
                "yanked": false,
                "yanked_reason": null
            }
        ],
        "vulnerabilities": [
            {
                "aliases": [],
                "details": "### Impact\n\nThis advisory addresses several LOW severity issues with streaming signed messages and restricting processing of certain types of invalid messages. \n\nThis ESDK supports a streaming mode where callers may stream the plaintext of signed messages before the ECDSA signature is validated. In addition to these signatures, the ESDK uses AES-GCM encryption and all plaintext is verified before being released to a caller. There is no impact on the integrity of the ciphertext or decrypted plaintext, however some callers may rely on the the ECDSA signature for non-repudiation. Without validating the ECDSA signature, an actor with trusted KMS permissions to decrypt a message may also be able to encrypt messages. This update introduces a new API for callers who wish to stream only unsigned messages. \n\nFor customers who process ESDK messages from untrusted sources, this update also introduces a new configuration to limit the number of Encrypted Data Keys (EDKs) that the ESDK will attempt to process per message. This configuration provides customers with a way to limit the number of AWS KMS Decrypt API calls that the ESDK will make per message. This setting will reject messages with more EDKs than the configured limit.\n\nFinally, this update adds early rejection of invalid messages with certain invalid combinations of algorithm suite and header data.\n\n### Patches\n\nFixed in versions 1.9 and 2.2. We recommend that all users upgrade to address these issues.\n\nCustomers leveraging the ESDK\u2019s streaming features have several options to protect signature validation. One is to ensure that client code reads to the end of the stream before using released plaintext. With this release, using the new API for streaming and falling back to the non-streaming decrypt API for signed messages prevents using any plaintext from signed data before the signature is validated. See https://docs.aws.amazon.com/encryption-sdk/latest/developer-guide/about-versions.html#version2.2.x\n\nUsers processing ESDK messages from untrusted sources should use the new maximum encrypted data keys parameter. See https://docs.aws.amazon.com/encryption-sdk/latest/developer-guide/about-versions.html#version2.2.x\n\n### Workarounds\n\nNone\n\n### For more information\n\nhttps://docs.aws.amazon.com/encryption-sdk/latest/developer-guide/concepts.html#digital-sigs\n\nhttps://docs.aws.amazon.com/encryption-sdk/latest/developer-guide/about-versions.html#version2.2.x\n",
                "fixed_in": [
                    "1.9.0",
                    "2.2.0"
                ],
                "id": "GHSA-x5h4-9gqw-942j",
                "link": "https://osv.dev/vulnerability/GHSA-x5h4-9gqw-942j",
                "source": "osv",
                "summary": null,
                "withdrawn": null
            }
        ]
    },
    "2.1.0": {
        "info": {
            "author": "Amazon Web Services",
            "author_email": "aws-cryptools@amazon.com",
            "bugtrack_url": null,
            "classifiers": [
                "Development Status :: 5 - Production/Stable",
                "Intended Audience :: Developers",
                "License :: OSI Approved :: Apache Software License",
                "Natural Language :: English",
                "Programming Language :: Python",
                "Programming Language :: Python :: 2",
                "Programming Language :: Python :: 2.7",
                "Programming Language :: Python :: 3",
                "Programming Language :: Python :: 3.4",
                "Programming Language :: Python :: 3.5",
                "Programming Language :: Python :: 3.6",
                "Programming Language :: Python :: 3.7",
                "Programming Language :: Python :: 3.8",
                "Programming Language :: Python :: 3.9",
                "Programming Language :: Python :: Implementation :: CPython",
                "Topic :: Security",
                "Topic :: Security :: Cryptography"
            ],
            "description_content_type": "",
            "docs_url": null,
            "download_url": "",
            "downloads": {
                "last_day": -1,
                "last_month": -1,
                "last_week": -1
            },
            "home_page": "https://github.com/aws/aws-encryption-sdk-python",
            "keywords": "aws-encryption-sdk aws kms encryption",
            "license": "Apache License 2.0",
            "maintainer": "Amazon Web Services",
            "maintainer_email": "",
            "name": "aws-encryption-sdk",
            "package_url": "https://pypi.org/project/aws-encryption-sdk/",
            "platform": "",
            "project_url": "https://pypi.org/project/aws-encryption-sdk/",
            "project_urls": {
                "Homepage": "https://github.com/aws/aws-encryption-sdk-python"
            },
            "release_url": "https://pypi.org/project/aws-encryption-sdk/2.1.0/",
            "requires_dist": [
                "boto3 (>=1.10.0)",
                "cryptography (>=2.5.0)",
                "attrs (>=17.4.0)",
                "wrapt (>=1.10.11)"
            ],
            "requires_python": "",
            "summary": "AWS Encryption SDK implementation for Python",
            "version": "2.1.0",
            "yanked": false,
            "yanked_reason": null
        },
        "last_serial": 14939260,
        "urls": [
            {
                "comment_text": "",
                "digests": {
                    "md5": "8945a6e4bc34485dcbe8a38401db89c7",
                    "sha256": "3872984c1cc8712b33b9afc904a427a0c6ddb82885fff607bf04bc73b71f3f56"
                },
                "downloads": -1,
                "filename": "aws_encryption_sdk-2.1.0-py2.py3-none-any.whl",
                "has_sig": false,
                "md5_digest": "8945a6e4bc34485dcbe8a38401db89c7",
                "packagetype": "bdist_wheel",
                "python_version": "py2.py3",
                "requires_python": null,
                "size": 89651,
                "upload_time": "2021-04-20T15:53:38",
                "upload_time_iso_8601": "2021-04-20T15:53:38.427482Z",
                "url": "https://files.pythonhosted.org/packages/fd/dd/960fa6724fbb8be13a30d6845dd4fd80a0c8eee1954c757d3eb2ab1b94d6/aws_encryption_sdk-2.1.0-py2.py3-none-any.whl",
                "yanked": false,
                "yanked_reason": null
            },
            {
                "comment_text": "",
                "digests": {
                    "md5": "f094f4a69dad8e9914b3b8b1c570dc3d",
                    "sha256": "28dad9759ad76fb03535329cad342491c33c15ef9c4d35efa20a443b90dbe4e5"
                },
                "downloads": -1,
                "filename": "aws-encryption-sdk-2.1.0.tar.gz",
                "has_sig": false,
                "md5_digest": "f094f4a69dad8e9914b3b8b1c570dc3d",
                "packagetype": "sdist",
                "python_version": "source",
                "requires_python": null,
                "size": 155853,
                "upload_time": "2021-04-20T15:53:40",
                "upload_time_iso_8601": "2021-04-20T15:53:40.471081Z",
                "url": "https://files.pythonhosted.org/packages/4b/85/0bf2566f5cfa4a259d33bd222c52f442ae91440e29a4c0e935ae1819d100/aws-encryption-sdk-2.1.0.tar.gz",
                "yanked": false,
                "yanked_reason": null
            }
        ],
        "vulnerabilities": [
            {
                "aliases": [],
                "details": "### Impact\n\nThis advisory addresses several LOW severity issues with streaming signed messages and restricting processing of certain types of invalid messages. \n\nThis ESDK supports a streaming mode where callers may stream the plaintext of signed messages before the ECDSA signature is validated. In addition to these signatures, the ESDK uses AES-GCM encryption and all plaintext is verified before being released to a caller. There is no impact on the integrity of the ciphertext or decrypted plaintext, however some callers may rely on the the ECDSA signature for non-repudiation. Without validating the ECDSA signature, an actor with trusted KMS permissions to decrypt a message may also be able to encrypt messages. This update introduces a new API for callers who wish to stream only unsigned messages. \n\nFor customers who process ESDK messages from untrusted sources, this update also introduces a new configuration to limit the number of Encrypted Data Keys (EDKs) that the ESDK will attempt to process per message. This configuration provides customers with a way to limit the number of AWS KMS Decrypt API calls that the ESDK will make per message. This setting will reject messages with more EDKs than the configured limit.\n\nFinally, this update adds early rejection of invalid messages with certain invalid combinations of algorithm suite and header data.\n\n### Patches\n\nFixed in versions 1.9 and 2.2. We recommend that all users upgrade to address these issues.\n\nCustomers leveraging the ESDK\u2019s streaming features have several options to protect signature validation. One is to ensure that client code reads to the end of the stream before using released plaintext. With this release, using the new API for streaming and falling back to the non-streaming decrypt API for signed messages prevents using any plaintext from signed data before the signature is validated. See https://docs.aws.amazon.com/encryption-sdk/latest/developer-guide/about-versions.html#version2.2.x\n\nUsers processing ESDK messages from untrusted sources should use the new maximum encrypted data keys parameter. See https://docs.aws.amazon.com/encryption-sdk/latest/developer-guide/about-versions.html#version2.2.x\n\n### Workarounds\n\nNone\n\n### For more information\n\nhttps://docs.aws.amazon.com/encryption-sdk/latest/developer-guide/concepts.html#digital-sigs\n\nhttps://docs.aws.amazon.com/encryption-sdk/latest/developer-guide/about-versions.html#version2.2.x\n",
                "fixed_in": [
                    "1.9.0",
                    "2.2.0"
                ],
                "id": "GHSA-x5h4-9gqw-942j",
                "link": "https://osv.dev/vulnerability/GHSA-x5h4-9gqw-942j",
                "source": "osv",
                "summary": null,
                "withdrawn": null
            }
        ]
    },
    "2.2.0": {
        "info": {
            "author": "Amazon Web Services",
            "author_email": "aws-cryptools@amazon.com",
            "bugtrack_url": null,
            "classifiers": [
                "Development Status :: 5 - Production/Stable",
                "Intended Audience :: Developers",
                "License :: OSI Approved :: Apache Software License",
                "Natural Language :: English",
                "Programming Language :: Python",
                "Programming Language :: Python :: 2",
                "Programming Language :: Python :: 2.7",
                "Programming Language :: Python :: 3",
                "Programming Language :: Python :: 3.4",
                "Programming Language :: Python :: 3.5",
                "Programming Language :: Python :: 3.6",
                "Programming Language :: Python :: 3.7",
                "Programming Language :: Python :: 3.8",
                "Programming Language :: Python :: 3.9",
                "Programming Language :: Python :: Implementation :: CPython",
                "Topic :: Security",
                "Topic :: Security :: Cryptography"
            ],
            "description_content_type": "",
            "docs_url": null,
            "download_url": "",
            "downloads": {
                "last_day": -1,
                "last_month": -1,
                "last_week": -1
            },
            "home_page": "https://github.com/aws/aws-encryption-sdk-python",
            "keywords": "aws-encryption-sdk aws kms encryption",
            "license": "Apache License 2.0",
            "maintainer": "Amazon Web Services",
            "maintainer_email": "",
            "name": "aws-encryption-sdk",
            "package_url": "https://pypi.org/project/aws-encryption-sdk/",
            "platform": "",
            "project_url": "https://pypi.org/project/aws-encryption-sdk/",
            "project_urls": {
                "Homepage": "https://github.com/aws/aws-encryption-sdk-python"
            },
            "release_url": "https://pypi.org/project/aws-encryption-sdk/2.2.0/",
            "requires_dist": [
                "boto3 (>=1.10.0)",
                "cryptography (>=2.5.0)",
                "attrs (>=17.4.0)",
                "wrapt (>=1.10.11)"
            ],
            "requires_python": "",
            "summary": "AWS Encryption SDK implementation for Python",
            "version": "2.2.0",
            "yanked": false,
            "yanked_reason": null
        },
        "last_serial": 14939260,
        "urls": [
            {
                "comment_text": "",
                "digests": {
                    "md5": "cedfba2842a56db4c5ed6a44ea4dd815",
                    "sha256": "4228dfef8f15f44c12deab804b371934503210ae44b0777d1ac30ea60c9e363f"
                },
                "downloads": -1,
                "filename": "aws_encryption_sdk-2.2.0-py2.py3-none-any.whl",
                "has_sig": false,
                "md5_digest": "cedfba2842a56db4c5ed6a44ea4dd815",
                "packagetype": "bdist_wheel",
                "python_version": "py2.py3",
                "requires_python": null,
                "size": 91717,
                "upload_time": "2021-05-27T20:37:37",
                "upload_time_iso_8601": "2021-05-27T20:37:37.598771Z",
                "url": "https://files.pythonhosted.org/packages/43/38/0983b20d17585a2773d63bb9bf78e3060ff71da9f22563eec391cebd5dfe/aws_encryption_sdk-2.2.0-py2.py3-none-any.whl",
                "yanked": false,
                "yanked_reason": null
            },
            {
                "comment_text": "",
                "digests": {
                    "md5": "0bd5f3964e8dac6c49560ebcaeeb8a25",
                    "sha256": "50f0b2f116db756699aa4eda74adedbdefaadf899547ba4016a2db3b3cf3234a"
                },
                "downloads": -1,
                "filename": "aws-encryption-sdk-2.2.0.tar.gz",
                "has_sig": false,
                "md5_digest": "0bd5f3964e8dac6c49560ebcaeeb8a25",
                "packagetype": "sdist",
                "python_version": "source",
                "requires_python": null,
                "size": 158941,
                "upload_time": "2021-05-27T20:37:39",
                "upload_time_iso_8601": "2021-05-27T20:37:39.192043Z",
                "url": "https://files.pythonhosted.org/packages/15/38/f7860631da599e4bb4f0b6f1476d8c71e5adbc7b0848039bcf61b13ea4ad/aws-encryption-sdk-2.2.0.tar.gz",
                "yanked": false,
                "yanked_reason": null
            }
        ],
        "vulnerabilities": []
    },
    "2.3.0": {
        "info": {
            "author": "Amazon Web Services",
            "author_email": "aws-cryptools@amazon.com",
            "bugtrack_url": null,
            "classifiers": [
                "Development Status :: 5 - Production/Stable",
                "Intended Audience :: Developers",
                "License :: OSI Approved :: Apache Software License",
                "Natural Language :: English",
                "Programming Language :: Python",
                "Programming Language :: Python :: 2",
                "Programming Language :: Python :: 2.7",
                "Programming Language :: Python :: 3",
                "Programming Language :: Python :: 3.4",
                "Programming Language :: Python :: 3.5",
                "Programming Language :: Python :: 3.6",
                "Programming Language :: Python :: 3.7",
                "Programming Language :: Python :: 3.8",
                "Programming Language :: Python :: 3.9",
                "Programming Language :: Python :: Implementation :: CPython",
                "Topic :: Security",
                "Topic :: Security :: Cryptography"
            ],
            "description_content_type": "",
            "docs_url": null,
            "download_url": "",
            "downloads": {
                "last_day": -1,
                "last_month": -1,
                "last_week": -1
            },
            "home_page": "https://github.com/aws/aws-encryption-sdk-python",
            "keywords": "aws-encryption-sdk aws kms encryption",
            "license": "Apache License 2.0",
            "maintainer": "Amazon Web Services",
            "maintainer_email": "",
            "name": "aws-encryption-sdk",
            "package_url": "https://pypi.org/project/aws-encryption-sdk/",
            "platform": "",
            "project_url": "https://pypi.org/project/aws-encryption-sdk/",
            "project_urls": {
                "Homepage": "https://github.com/aws/aws-encryption-sdk-python"
            },
            "release_url": "https://pypi.org/project/aws-encryption-sdk/2.3.0/",
            "requires_dist": [
                "boto3 (>=1.10.0)",
                "cryptography (>=2.5.0)",
                "attrs (>=17.4.0)",
                "wrapt (>=1.10.11)"
            ],
            "requires_python": "",
            "summary": "AWS Encryption SDK implementation for Python",
            "version": "2.3.0",
            "yanked": false,
            "yanked_reason": null
        },
        "last_serial": 14939260,
        "urls": [
            {
                "comment_text": "",
                "digests": {
                    "md5": "5496a4be82254bca786d11925e0567d2",
                    "sha256": "7558765381b44c870c55eb69d1b4e04538659e792f47d11671ae314162a17e49"
                },
                "downloads": -1,
                "filename": "aws_encryption_sdk-2.3.0-py2.py3-none-any.whl",
                "has_sig": false,
                "md5_digest": "5496a4be82254bca786d11925e0567d2",
                "packagetype": "bdist_wheel",
                "python_version": "py2.py3",
                "requires_python": null,
                "size": 98113,
                "upload_time": "2021-06-16T16:49:20",
                "upload_time_iso_8601": "2021-06-16T16:49:20.310389Z",
                "url": "https://files.pythonhosted.org/packages/64/e9/737341f5aef8caf55c093a07b1c0fe1d0b8ed8f50016f6a02d7dbe9ac6f5/aws_encryption_sdk-2.3.0-py2.py3-none-any.whl",
                "yanked": false,
                "yanked_reason": null
            },
            {
                "comment_text": "",
                "digests": {
                    "md5": "981fa597fa2e11bc6c8ec3e417c568fc",
                    "sha256": "192f11428630f0cfd4fdc736bc57a65a979d8bb2169f03402e29b0f3be79c28d"
                },
                "downloads": -1,
                "filename": "aws-encryption-sdk-2.3.0.tar.gz",
                "has_sig": false,
                "md5_digest": "981fa597fa2e11bc6c8ec3e417c568fc",
                "packagetype": "sdist",
                "python_version": "source",
                "requires_python": null,
                "size": 175922,
                "upload_time": "2021-06-16T16:49:22",
                "upload_time_iso_8601": "2021-06-16T16:49:22.084842Z",
                "url": "https://files.pythonhosted.org/packages/9b/5c/7039aba17791ec26153c905137c708517acf5e8f0a9b242c3c348e14c256/aws-encryption-sdk-2.3.0.tar.gz",
                "yanked": false,
                "yanked_reason": null
            }
        ],
        "vulnerabilities": []
    },
    "2.4.0": {
        "info": {
            "author": "Amazon Web Services",
            "author_email": "aws-cryptools@amazon.com",
            "bugtrack_url": null,
            "classifiers": [
                "Development Status :: 5 - Production/Stable",
                "Intended Audience :: Developers",
                "License :: OSI Approved :: Apache Software License",
                "Natural Language :: English",
                "Programming Language :: Python",
                "Programming Language :: Python :: 2",
                "Programming Language :: Python :: 2.7",
                "Programming Language :: Python :: 3",
                "Programming Language :: Python :: 3.4",
                "Programming Language :: Python :: 3.5",
                "Programming Language :: Python :: 3.6",
                "Programming Language :: Python :: 3.7",
                "Programming Language :: Python :: 3.8",
                "Programming Language :: Python :: 3.9",
                "Programming Language :: Python :: Implementation :: CPython",
                "Topic :: Security",
                "Topic :: Security :: Cryptography"
            ],
            "description_content_type": "",
            "docs_url": null,
            "download_url": "",
            "downloads": {
                "last_day": -1,
                "last_month": -1,
                "last_week": -1
            },
            "home_page": "https://github.com/aws/aws-encryption-sdk-python",
            "keywords": "aws-encryption-sdk aws kms encryption",
            "license": "Apache License 2.0",
            "maintainer": "Amazon Web Services",
            "maintainer_email": "",
            "name": "aws-encryption-sdk",
            "package_url": "https://pypi.org/project/aws-encryption-sdk/",
            "platform": "",
            "project_url": "https://pypi.org/project/aws-encryption-sdk/",
            "project_urls": {
                "Homepage": "https://github.com/aws/aws-encryption-sdk-python"
            },
            "release_url": "https://pypi.org/project/aws-encryption-sdk/2.4.0/",
            "requires_dist": [
                "boto3 (>=1.10.0)",
                "cryptography (>=2.5.0)",
                "attrs (>=17.4.0)",
                "wrapt (>=1.10.11)"
            ],
            "requires_python": "",
            "summary": "AWS Encryption SDK implementation for Python",
            "version": "2.4.0",
            "yanked": false,
            "yanked_reason": null
        },
        "last_serial": 14939260,
        "urls": [
            {
                "comment_text": "",
                "digests": {
                    "md5": "5c3faddd11c67674ad9e0c30f0dcfaed",
                    "sha256": "be2bc367392efeae510d28b2abd86cd11968310ffecb21e282045c2443a434d1"
                },
                "downloads": -1,
                "filename": "aws_encryption_sdk-2.4.0-py2.py3-none-any.whl",
                "has_sig": false,
                "md5_digest": "5c3faddd11c67674ad9e0c30f0dcfaed",
                "packagetype": "bdist_wheel",
                "python_version": "py2.py3",
                "requires_python": null,
                "size": 98292,
                "upload_time": "2021-07-01T18:58:39",
                "upload_time_iso_8601": "2021-07-01T18:58:39.487532Z",
                "url": "https://files.pythonhosted.org/packages/30/6b/d1ca167f9a7a8af90f7891be3aeecf029661ec6705ba3b38725a9a974d24/aws_encryption_sdk-2.4.0-py2.py3-none-any.whl",
                "yanked": false,
                "yanked_reason": null
            },
            {
                "comment_text": "",
                "digests": {
                    "md5": "4e55248e3a394da22a6074d9386cd513",
                    "sha256": "6179c6364cf5c57c8d551511ede56514302b2e6323bf5f167c104ab581e44171"
                },
                "downloads": -1,
                "filename": "aws-encryption-sdk-2.4.0.tar.gz",
                "has_sig": false,
                "md5_digest": "4e55248e3a394da22a6074d9386cd513",
                "packagetype": "sdist",
                "python_version": "source",
                "requires_python": null,
                "size": 176487,
                "upload_time": "2021-07-01T18:58:42",
                "upload_time_iso_8601": "2021-07-01T18:58:42.177985Z",
                "url": "https://files.pythonhosted.org/packages/ce/e9/61c4e89d92bf3e8281f08a5fde0e77fb04e10571f65273cf65fec03a0a09/aws-encryption-sdk-2.4.0.tar.gz",
                "yanked": false,
                "yanked_reason": null
            }
        ],
        "vulnerabilities": []
    },
    "2.5.0": {
        "info": {
            "author": "Amazon Web Services",
            "author_email": "aws-cryptools@amazon.com",
            "bugtrack_url": null,
            "classifiers": [
                "Development Status :: 5 - Production/Stable",
                "Intended Audience :: Developers",
                "License :: OSI Approved :: Apache Software License",
                "Natural Language :: English",
                "Programming Language :: Python",
                "Programming Language :: Python :: 2",
                "Programming Language :: Python :: 2.7",
                "Programming Language :: Python :: 3",
                "Programming Language :: Python :: 3.4",
                "Programming Language :: Python :: 3.5",
                "Programming Language :: Python :: 3.6",
                "Programming Language :: Python :: 3.7",
                "Programming Language :: Python :: 3.8",
                "Programming Language :: Python :: 3.9",
                "Programming Language :: Python :: Implementation :: CPython",
                "Topic :: Security",
                "Topic :: Security :: Cryptography"
            ],
            "description_content_type": "",
            "docs_url": null,
            "download_url": "",
            "downloads": {
                "last_day": -1,
                "last_month": -1,
                "last_week": -1
            },
            "home_page": "https://github.com/aws/aws-encryption-sdk-python",
            "keywords": "aws-encryption-sdk aws kms encryption",
            "license": "Apache License 2.0",
            "maintainer": "Amazon Web Services",
            "maintainer_email": "",
            "name": "aws-encryption-sdk",
            "package_url": "https://pypi.org/project/aws-encryption-sdk/",
            "platform": null,
            "project_url": "https://pypi.org/project/aws-encryption-sdk/",
            "project_urls": {
                "Homepage": "https://github.com/aws/aws-encryption-sdk-python"
            },
            "release_url": "https://pypi.org/project/aws-encryption-sdk/2.5.0/",
            "requires_dist": [
                "boto3 (>=1.10.0)",
                "cryptography (<=3.3.2,>=2.5.0)",
                "attrs (>=17.4.0)",
                "wrapt (>=1.10.11)"
            ],
            "requires_python": "",
            "summary": "AWS Encryption SDK implementation for Python",
            "version": "2.5.0",
            "yanked": false,
            "yanked_reason": null
        },
        "last_serial": 14939260,
        "urls": [
            {
                "comment_text": "",
                "digests": {
                    "md5": "d07aa9633dcd4d6bb5c938d8da1ae17d",
                    "sha256": "1e57402191dc378e91608460e098eb57bbddee8477bcc9e04882da8f5b80498e"
                },
                "downloads": -1,
                "filename": "aws_encryption_sdk-2.5.0-py2.py3-none-any.whl",
                "has_sig": false,
                "md5_digest": "d07aa9633dcd4d6bb5c938d8da1ae17d",
                "packagetype": "bdist_wheel",
                "python_version": "py2.py3",
                "requires_python": null,
                "size": 98463,
                "upload_time": "2022-06-21T20:18:20",
                "upload_time_iso_8601": "2022-06-21T20:18:20.712593Z",
                "url": "https://files.pythonhosted.org/packages/c2/72/a189d8680124dcdcfe174ab16d5908fde6c5283f5a0a65273df8376fb05f/aws_encryption_sdk-2.5.0-py2.py3-none-any.whl",
                "yanked": false,
                "yanked_reason": null
            },
            {
                "comment_text": "",
                "digests": {
                    "md5": "9da5de12a64278e11de6974fc191581d",
                    "sha256": "e372804293d26cb566086f4b14e169f968ffc346624c31ec61d908815d6703d2"
                },
                "downloads": -1,
                "filename": "aws-encryption-sdk-2.5.0.tar.gz",
                "has_sig": false,
                "md5_digest": "9da5de12a64278e11de6974fc191581d",
                "packagetype": "sdist",
                "python_version": "source",
                "requires_python": null,
                "size": 176093,
                "upload_time": "2022-06-21T20:18:24",
                "upload_time_iso_8601": "2022-06-21T20:18:24.896650Z",
                "url": "https://files.pythonhosted.org/packages/ee/22/6a0e9f1bdb5229ae7a29da3dde82d1a58c96db24ff691fffbdcc4dbc2225/aws-encryption-sdk-2.5.0.tar.gz",
                "yanked": false,
                "yanked_reason": null
            }
        ],
        "vulnerabilities": []
    },
    "2.5.1": {
        "info": {
            "author": "Amazon Web Services",
            "author_email": "aws-cryptools@amazon.com",
            "bugtrack_url": null,
            "classifiers": [
                "Development Status :: 5 - Production/Stable",
                "Intended Audience :: Developers",
                "License :: OSI Approved :: Apache Software License",
                "Natural Language :: English",
                "Programming Language :: Python",
                "Programming Language :: Python :: 2",
                "Programming Language :: Python :: 2.7",
                "Programming Language :: Python :: 3",
                "Programming Language :: Python :: 3.4",
                "Programming Language :: Python :: 3.5",
                "Programming Language :: Python :: 3.6",
                "Programming Language :: Python :: 3.7",
                "Programming Language :: Python :: 3.8",
                "Programming Language :: Python :: 3.9",
                "Programming Language :: Python :: Implementation :: CPython",
                "Topic :: Security",
                "Topic :: Security :: Cryptography"
            ],
            "description_content_type": "",
            "docs_url": null,
            "download_url": "",
            "downloads": {
                "last_day": -1,
                "last_month": -1,
                "last_week": -1
            },
            "home_page": "https://github.com/aws/aws-encryption-sdk-python",
            "keywords": "aws-encryption-sdk aws kms encryption",
            "license": "Apache License 2.0",
            "maintainer": "Amazon Web Services",
            "maintainer_email": "",
            "name": "aws-encryption-sdk",
            "package_url": "https://pypi.org/project/aws-encryption-sdk/",
            "platform": null,
            "project_url": "https://pypi.org/project/aws-encryption-sdk/",
            "project_urls": {
                "Homepage": "https://github.com/aws/aws-encryption-sdk-python"
            },
            "release_url": "https://pypi.org/project/aws-encryption-sdk/2.5.1/",
            "requires_dist": [
                "boto3 (>=1.10.0)",
                "cryptography (<37,>=2.5.0)",
                "attrs (>=17.4.0)",
                "wrapt (>=1.10.11)"
            ],
            "requires_python": "",
            "summary": "AWS Encryption SDK implementation for Python",
            "version": "2.5.1",
            "yanked": false,
            "yanked_reason": null
        },
        "last_serial": 14939260,
        "urls": [
            {
                "comment_text": "",
                "digests": {
                    "md5": "b937c09565338681024fddd41b106b82",
                    "sha256": "cc9c554705aaa3a4306734aca2627070bd5d09acf61738db731433a83ff37112"
                },
                "downloads": -1,
                "filename": "aws_encryption_sdk-2.5.1-py2.py3-none-any.whl",
                "has_sig": false,
                "md5_digest": "b937c09565338681024fddd41b106b82",
                "packagetype": "bdist_wheel",
                "python_version": "py2.py3",
                "requires_python": null,
                "size": 98588,
                "upload_time": "2022-08-30T19:40:15",
                "upload_time_iso_8601": "2022-08-30T19:40:15.550319Z",
                "url": "https://files.pythonhosted.org/packages/2b/cb/70f0324bd236116d379f79c2561c25b61347089eb2bef113bf9a20261782/aws_encryption_sdk-2.5.1-py2.py3-none-any.whl",
                "yanked": false,
                "yanked_reason": null
            },
            {
                "comment_text": "",
                "digests": {
                    "md5": "c97c295b52b8d3f71df8bbf683e7ef5d",
                    "sha256": "32fb4edf69abcd83a30f5d429223fd0b79c3d5b34e5839de29f2cff3d7633a99"
                },
                "downloads": -1,
                "filename": "aws-encryption-sdk-2.5.1.tar.gz",
                "has_sig": false,
                "md5_digest": "c97c295b52b8d3f71df8bbf683e7ef5d",
                "packagetype": "sdist",
                "python_version": "source",
                "requires_python": null,
                "size": 176338,
                "upload_time": "2022-08-30T19:40:18",
                "upload_time_iso_8601": "2022-08-30T19:40:18.280091Z",
                "url": "https://files.pythonhosted.org/packages/9f/64/dfa9f702dec7623771eeaf4c7a09281154d9265fc16ec5f185089648aadf/aws-encryption-sdk-2.5.1.tar.gz",
                "yanked": false,
                "yanked_reason": null
            }
        ],
        "vulnerabilities": []
    },
    "3.0.0": {
        "info": {
            "author": "Amazon Web Services",
            "author_email": "aws-cryptools@amazon.com",
            "bugtrack_url": null,
            "classifiers": [
                "Development Status :: 5 - Production/Stable",
                "Intended Audience :: Developers",
                "License :: OSI Approved :: Apache Software License",
                "Natural Language :: English",
                "Programming Language :: Python",
                "Programming Language :: Python :: 2",
                "Programming Language :: Python :: 2.7",
                "Programming Language :: Python :: 3",
                "Programming Language :: Python :: 3.4",
                "Programming Language :: Python :: 3.5",
                "Programming Language :: Python :: 3.6",
                "Programming Language :: Python :: 3.7",
                "Programming Language :: Python :: 3.8",
                "Programming Language :: Python :: 3.9",
                "Programming Language :: Python :: Implementation :: CPython",
                "Topic :: Security",
                "Topic :: Security :: Cryptography"
            ],
            "description_content_type": "",
            "docs_url": null,
            "download_url": "",
            "downloads": {
                "last_day": -1,
                "last_month": -1,
                "last_week": -1
            },
            "home_page": "https://github.com/aws/aws-encryption-sdk-python",
            "keywords": "aws-encryption-sdk aws kms encryption",
            "license": "Apache License 2.0",
            "maintainer": "Amazon Web Services",
            "maintainer_email": "",
            "name": "aws-encryption-sdk",
            "package_url": "https://pypi.org/project/aws-encryption-sdk/",
            "platform": "",
            "project_url": "https://pypi.org/project/aws-encryption-sdk/",
            "project_urls": {
                "Homepage": "https://github.com/aws/aws-encryption-sdk-python"
            },
            "release_url": "https://pypi.org/project/aws-encryption-sdk/3.0.0/",
            "requires_dist": [
                "boto3 (>=1.10.0)",
                "cryptography (>=2.5.0)",
                "attrs (>=17.4.0)",
                "wrapt (>=1.10.11)"
            ],
            "requires_python": "",
            "summary": "AWS Encryption SDK implementation for Python",
            "version": "3.0.0",
            "yanked": false,
            "yanked_reason": null
        },
        "last_serial": 14939260,
        "urls": [
            {
                "comment_text": "",
                "digests": {
                    "md5": "e563f5ff33034b0c94705c4f6b75e924",
                    "sha256": "53b9922334da9bc1c52ea1cc030f7a52d36e299f6c0934785d53272b0a6f6122"
                },
                "downloads": -1,
                "filename": "aws_encryption_sdk-3.0.0-py2.py3-none-any.whl",
                "has_sig": false,
                "md5_digest": "e563f5ff33034b0c94705c4f6b75e924",
                "packagetype": "bdist_wheel",
                "python_version": "py2.py3",
                "requires_python": null,
                "size": 98141,
                "upload_time": "2021-07-01T22:50:45",
                "upload_time_iso_8601": "2021-07-01T22:50:45.051704Z",
                "url": "https://files.pythonhosted.org/packages/af/d6/ef55d3b6028cc02ca6c24f5a21a48ca7ba6d354d7788d9b77940f434930c/aws_encryption_sdk-3.0.0-py2.py3-none-any.whl",
                "yanked": false,
                "yanked_reason": null
            },
            {
                "comment_text": "",
                "digests": {
                    "md5": "a0baff3662f4ee2f6418c99ce1cc2678",
                    "sha256": "587afe66b150f0cbcba442dbd880c45a43849dd361b6a508aef1907aaa5ceedb"
                },
                "downloads": -1,
                "filename": "aws-encryption-sdk-3.0.0.tar.gz",
                "has_sig": false,
                "md5_digest": "a0baff3662f4ee2f6418c99ce1cc2678",
                "packagetype": "sdist",
                "python_version": "source",
                "requires_python": null,
                "size": 176380,
                "upload_time": "2021-07-01T22:50:47",
                "upload_time_iso_8601": "2021-07-01T22:50:47.134938Z",
                "url": "https://files.pythonhosted.org/packages/af/c8/51d6214a376ad5dc2d5c1243ca6fb5ba89f9a7ad4fe5d6b1f6c3878b10b1/aws-encryption-sdk-3.0.0.tar.gz",
                "yanked": false,
                "yanked_reason": null
            }
        ],
        "vulnerabilities": []
    },
    "3.1.0": {
        "info": {
            "author": "Amazon Web Services",
            "author_email": "aws-cryptools@amazon.com",
            "bugtrack_url": null,
            "classifiers": [
                "Development Status :: 5 - Production/Stable",
                "Intended Audience :: Developers",
                "License :: OSI Approved :: Apache Software License",
                "Natural Language :: English",
                "Programming Language :: Python",
                "Programming Language :: Python :: 3",
                "Programming Language :: Python :: 3.6",
                "Programming Language :: Python :: 3.7",
                "Programming Language :: Python :: 3.8",
                "Programming Language :: Python :: 3.9",
                "Programming Language :: Python :: Implementation :: CPython",
                "Topic :: Security",
                "Topic :: Security :: Cryptography"
            ],
            "description_content_type": "",
            "docs_url": null,
            "download_url": "",
            "downloads": {
                "last_day": -1,
                "last_month": -1,
                "last_week": -1
            },
            "home_page": "https://github.com/aws/aws-encryption-sdk-python",
            "keywords": "aws-encryption-sdk aws kms encryption",
            "license": "Apache License 2.0",
            "maintainer": "Amazon Web Services",
            "maintainer_email": "",
            "name": "aws-encryption-sdk",
            "package_url": "https://pypi.org/project/aws-encryption-sdk/",
            "platform": "",
            "project_url": "https://pypi.org/project/aws-encryption-sdk/",
            "project_urls": {
                "Homepage": "https://github.com/aws/aws-encryption-sdk-python"
            },
            "release_url": "https://pypi.org/project/aws-encryption-sdk/3.1.0/",
            "requires_dist": [
                "boto3 (>=1.10.0)",
                "cryptography (>=2.5.0)",
                "attrs (>=17.4.0)",
                "wrapt (>=1.10.11)"
            ],
            "requires_python": "",
            "summary": "AWS Encryption SDK implementation for Python",
            "version": "3.1.0",
            "yanked": false,
            "yanked_reason": null
        },
        "last_serial": 14939260,
        "urls": [
            {
                "comment_text": "",
                "digests": {
                    "md5": "97a3193581b98a0303cb1c48301e074f",
                    "sha256": "d8d51bed8dad1f5115a9fed81808e49202e61d2cec4870dc15b4264a32106020"
                },
                "downloads": -1,
                "filename": "aws_encryption_sdk-3.1.0-py2.py3-none-any.whl",
                "has_sig": false,
                "md5_digest": "97a3193581b98a0303cb1c48301e074f",
                "packagetype": "bdist_wheel",
                "python_version": "py2.py3",
                "requires_python": null,
                "size": 99214,
                "upload_time": "2021-11-11T00:11:13",
                "upload_time_iso_8601": "2021-11-11T00:11:13.365073Z",
                "url": "https://files.pythonhosted.org/packages/db/e8/7cf07f08721f4f752abe1aef8a121bce35e26bccaef39bf9683301c8bc03/aws_encryption_sdk-3.1.0-py2.py3-none-any.whl",
                "yanked": false,
                "yanked_reason": null
            },
            {
                "comment_text": "",
                "digests": {
                    "md5": "ae8dceca06407fb19fb9f0b8ff8cafe5",
                    "sha256": "90d4f1f5379b75ec03113afc825b2ba4d99cd4907ccdea2e6c278331f75ae667"
                },
                "downloads": -1,
                "filename": "aws-encryption-sdk-3.1.0.tar.gz",
                "has_sig": false,
                "md5_digest": "ae8dceca06407fb19fb9f0b8ff8cafe5",
                "packagetype": "sdist",
                "python_version": "source",
                "requires_python": null,
                "size": 176366,
                "upload_time": "2021-11-11T00:11:17",
                "upload_time_iso_8601": "2021-11-11T00:11:17.117123Z",
                "url": "https://files.pythonhosted.org/packages/e7/b1/20220bdbe12bdddd463cd321334c1a1490dcbada1344cc4c720b47b313a0/aws-encryption-sdk-3.1.0.tar.gz",
                "yanked": false,
                "yanked_reason": null
            }
        ],
        "vulnerabilities": []
    },
    "3.1.1": {
        "info": {
            "author": "Amazon Web Services",
            "author_email": "aws-cryptools@amazon.com",
            "bugtrack_url": null,
            "classifiers": [
                "Development Status :: 5 - Production/Stable",
                "Intended Audience :: Developers",
                "License :: OSI Approved :: Apache Software License",
                "Natural Language :: English",
                "Programming Language :: Python",
                "Programming Language :: Python :: 3",
                "Programming Language :: Python :: 3.6",
                "Programming Language :: Python :: 3.7",
                "Programming Language :: Python :: 3.8",
                "Programming Language :: Python :: 3.9",
                "Programming Language :: Python :: Implementation :: CPython",
                "Topic :: Security",
                "Topic :: Security :: Cryptography"
            ],
            "description": "##################\naws-encryption-sdk\n##################\n\n.. image:: https://img.shields.io/pypi/v/aws-encryption-sdk.svg\n   :target: https://pypi.python.org/pypi/aws-encryption-sdk\n   :alt: Latest Version\n\n.. image:: https://img.shields.io/pypi/pyversions/aws-encryption-sdk.svg\n   :target: https://pypi.python.org/pypi/aws-encryption-sdk\n   :alt: Supported Python Versions\n\n.. image:: https://img.shields.io/badge/code_style-black-000000.svg\n   :target: https://github.com/ambv/black\n   :alt: Code style: black\n\n.. image:: https://readthedocs.org/projects/aws-encryption-sdk-python/badge/\n   :target: https://aws-encryption-sdk-python.readthedocs.io/en/stable/\n   :alt: Documentation Status\n\nThe AWS Encryption SDK for Python provides a fully compliant, native Python implementation of the `AWS Encryption SDK`_.\n\nThe latest full documentation can be found at `Read the Docs`_.\n\nFind us on `GitHub`_.\n\n`Security issue notifications`_\n\nSee `Support Policy`_ for details on the current support status of all major versions of this library.\n\n***************\nGetting Started\n***************\nRequired Prerequisites\n======================\n\n* Python 3.6+\n* cryptography >= 2.5.0\n* boto3 >= 1.10.0\n* attrs\n\nInstallation\n============\n\n.. note::\n\n   If you have not already installed `cryptography`_, you might need to install additional prerequisites as\n   detailed in the `cryptography installation guide`_ for your operating system.\n\n   .. code::\n\n       $ pip install aws-encryption-sdk\n\n\nConcepts\n========\nThere are four main concepts that you need to understand to use this library:\n\nCryptographic Materials Managers\n--------------------------------\nCryptographic materials managers (CMMs) are resources that collect cryptographic materials and prepare them for\nuse by the Encryption SDK core logic.\n\nAn example of a CMM is the default CMM, which is automatically generated anywhere a caller provides a master\nkey provider. The default CMM collects encrypted data keys from all master keys referenced by the master key\nprovider.\n\nAn example of a more advanced CMM is the caching CMM, which caches cryptographic materials provided by another CMM.\n\nMaster Key Providers\n--------------------\nMaster key providers are resources that provide master keys.\nAn example of a master key provider is `AWS KMS`_.\n\nTo encrypt data in this client, a ``MasterKeyProvider`` object must contain at least one ``MasterKey`` object.\n\n``MasterKeyProvider`` objects can also contain other ``MasterKeyProvider`` objects.\n\nMaster Keys\n-----------\nMaster keys generate, encrypt, and decrypt data keys.\nAn example of a master key is a `KMS customer master key (CMK)`_.\n\nData Keys\n---------\nData keys are the encryption keys that are used to encrypt your data. If your algorithm suite\nuses a key derivation function, the data key is used to generate the key that directly encrypts the data.\n\n*****\nUsage\n*****\n\nEncryptionSDKClient\n===================\nTo use this module, you (the caller) must first create an instance of the ``EncryptionSDKClient`` class.\nThe constructor to this class accepts an optional keyword argument, ``commitment_policy``, that controls\nwhich algorithm suites can be used for encryption and decryption. If no value\nis provided for this argument, a default value of ``REQUIRE_ENCRYPT_REQUIRE_DECRYPT`` is used. Unless\nyou have specialized performance requirements or are in the process of migrating from an older\nversion of the AWS Encryption SDK, we recommend using the default value.\n\n.. code:: python\n\n    import aws_encryption_sdk\n    from aws_encryption_sdk.identifiers import CommitmentPolicy\n\n\n    client = aws_encryption_sdk.EncryptionSDKClient(\n        commitment_policy=CommitmentPolicy.REQUIRE_ENCRYPT_REQUIRE_DECRYPT\n    )\n\n\nYou must then create an instance of either a master key provider or a CMM. The examples in this\nreadme use the ``StrictAwsKmsMasterKeyProvider`` class.\n\n\nStrictAwsKmsMasterKeyProvider\n=============================\nA ``StrictAwsKmsMasterKeyProvider`` is configured with an explicit list of AWS KMS\nCMKs with which to encrypt and decrypt data. On encryption, it encrypts the plaintext with all\nconfigured CMKs. On decryption, it only attempts to decrypt ciphertexts that have been wrapped\nwith a CMK that matches one of the configured CMK ARNs.\n\nTo create a ``StrictAwsKmsMasterKeyProvider`` you must provide one or more CMKs. For providers that will only\nbe used for encryption, you can use any valid `KMS key identifier`_. For providers that will be used for decryption, you\nmust use the key ARN; key ids, alias names, and alias ARNs are not supported.\n\nBecause the ``StrictAwsKmsMasterKeyProvider`` uses the `boto3 SDK`_ to interact with `AWS KMS`_,\nit requires AWS Credentials.\nTo provide these credentials, use the `standard means by which boto3 locates credentials`_ or provide a\npre-existing instance of a ``botocore session`` to the ``StrictAwsKmsMasterKeyProvider``.\nThis latter option can be useful if you have an alternate way to store your AWS credentials or\nyou want to reuse an existing instance of a botocore session in order to decrease startup costs.\n\nIf you configure the the ``StrictAwsKmsMasterKeyProvider`` with multiple CMKs, the `final message`_\nwill include a copy of the data key encrypted by each configured CMK.\n\n.. code:: python\n\n    import aws_encryption_sdk\n\n    kms_key_provider = aws_encryption_sdk.StrictAwsKmsMasterKeyProvider(key_ids=[\n        'arn:aws:kms:us-east-1:2222222222222:key/22222222-2222-2222-2222-222222222222',\n        'arn:aws:kms:us-east-1:3333333333333:key/33333333-3333-3333-3333-333333333333'\n    ])\n\nYou can add CMKs from multiple regions to the ``StrictAwsKmsMasterKeyProvider``.\n\n.. code:: python\n\n    import aws_encryption_sdk\n\n    kms_key_provider = aws_encryption_sdk.StrictAwsKmsMasterKeyProvider(key_ids=[\n        'arn:aws:kms:us-east-1:2222222222222:key/22222222-2222-2222-2222-222222222222',\n        'arn:aws:kms:us-west-2:3333333333333:key/33333333-3333-3333-3333-333333333333',\n        'arn:aws:kms:ap-northeast-1:4444444444444:key/44444444-4444-4444-4444-444444444444'\n    ])\n\n\nDiscoveryAwsKmsMasterKeyProvider\n================================\nWe recommend using a ``StrictAwsKmsMasterKeyProvider`` in order to ensure that you can only\nencrypt and decrypt data using the AWS KMS CMKs you expect. However, if you are unable to\nexplicitly identify the AWS KMS CMKs that should be used for decryption, you can instead\nuse a ``DiscoveryAwsKmsMasterKeyProvider`` for decryption operations. This provider\nattempts decryption of any ciphertexts as long as they match a ``DiscoveryFilter`` that\nyou configure. A ``DiscoveryFilter`` consists of a list of AWS account ids and an AWS\npartition.\n\n.. code:: python\n\n    import aws_encryption_sdk\n    from aws_encryption_sdk.key_providers.kms import DiscoveryFilter\n\n    discovery_filter = DiscoveryFilter(\n        account_ids=['222222222222', '333333333333'],\n        partition='aws'\n    )\n    kms_key_provider = aws_encryption_sdk.DiscoveryAwsKmsMasterKeyProvider(\n        discovery_filter=discovery_filter\n    )\n\nIf you do not want to filter the set of allowed accounts, you can also omit the ``discovery_filter`` argument.\n\nNote that a ``DiscoveryAwsKmsMasterKeyProvider`` cannot be used for encryption operations.\n\nEncryption and Decryption\n=========================\nAfter you create an instance of an ``EncryptionSDKClient`` and a ``MasterKeyProvider``, you can use either of\nthe client's two ``encrypt``/``decrypt`` functions to encrypt and decrypt your data.\n\n.. code:: python\n\n    import aws_encryption_sdk\n    from aws_encryption_sdk.identifiers import CommitmentPolicy\n\n    client = aws_encryption_sdk.EncryptionSDKClient(\n        commitment_policy=CommitmentPolicy.FORBID_ENCRYPT_ALLOW_DECRYPT\n    )\n\n    kms_key_provider = aws_encryption_sdk.StrictAwsKmsMasterKeyProvider(key_ids=[\n        'arn:aws:kms:us-east-1:2222222222222:key/22222222-2222-2222-2222-222222222222',\n        'arn:aws:kms:us-east-1:3333333333333:key/33333333-3333-3333-3333-333333333333'\n    ])\n    my_plaintext = b'This is some super secret data!  Yup, sure is!'\n\n    my_ciphertext, encryptor_header = client.encrypt(\n        source=my_plaintext,\n        key_provider=kms_key_provider\n    )\n\n    decrypted_plaintext, decryptor_header = client.decrypt(\n        source=my_ciphertext,\n        key_provider=kms_key_provider\n    )\n\n    assert my_plaintext == decrypted_plaintext\n    assert encryptor_header.encryption_context == decryptor_header.encryption_context\n\nYou can provide an `encryption context`_: a form of additional authenticating information.\n\n.. code:: python\n\n    import aws_encryption_sdk\n    from aws_encryption_sdk.identifiers import CommitmentPolicy\n\n    client = aws_encryption_sdk.EncryptionSDKClient(\n        commitment_policy=CommitmentPolicy.FORBID_ENCRYPT_ALLOW_DECRYPT\n    )\n\n    kms_key_provider = aws_encryption_sdk.StrictAwsKmsMasterKeyProvider(key_ids=[\n        'arn:aws:kms:us-east-1:2222222222222:key/22222222-2222-2222-2222-222222222222',\n        'arn:aws:kms:us-east-1:3333333333333:key/33333333-3333-3333-3333-333333333333'\n    ])\n    my_plaintext = b'This is some super secret data!  Yup, sure is!'\n\n    my_ciphertext, encryptor_header = client.encrypt(\n        source=my_plaintext,\n        key_provider=kms_key_provider,\n        encryption_context={\n            'not really': 'a secret',\n            'but adds': 'some authentication'\n        }\n    )\n\n    decrypted_plaintext, decryptor_header = client.decrypt(\n        source=my_ciphertext,\n        key_provider=kms_key_provider\n    )\n\n    assert my_plaintext == decrypted_plaintext\n    assert encryptor_header.encryption_context == decryptor_header.encryption_context\n\n\nStreaming\n=========\nIf you are handling large files or simply do not want to put the entire plaintext or ciphertext in\nmemory at once, you can use this library's streaming clients directly. The streaming clients are\nfile-like objects, and behave exactly as you would expect a Python file object to behave,\noffering context manager and iteration support.\n\n.. code:: python\n\n    import aws_encryption_sdk\n    from aws_encryption_sdk.identifiers import CommitmentPolicy\n    import filecmp\n\n    client = aws_encryption_sdk.EncryptionSDKClient(\n        commitment_policy=CommitmentPolicy.FORBID_ENCRYPT_ALLOW_DECRYPT\n    )\n\n    kms_key_provider = aws_encryption_sdk.StrictAwsKmsMasterKeyProvider(key_ids=[\n        'arn:aws:kms:us-east-1:2222222222222:key/22222222-2222-2222-2222-222222222222',\n        'arn:aws:kms:us-east-1:3333333333333:key/33333333-3333-3333-3333-333333333333'\n    ])\n    plaintext_filename = 'my-secret-data.dat'\n    ciphertext_filename = 'my-encrypted-data.ct'\n\n    with open(plaintext_filename, 'rb') as pt_file, open(ciphertext_filename, 'wb') as ct_file:\n        with client.stream(\n            mode='e',\n            source=pt_file,\n            key_provider=kms_key_provider\n        ) as encryptor:\n            for chunk in encryptor:\n                ct_file.write(chunk)\n\n    new_plaintext_filename = 'my-decrypted-data.dat'\n\n    with open(ciphertext_filename, 'rb') as ct_file, open(new_plaintext_filename, 'wb') as pt_file:\n        with client.stream(\n            mode='d',\n            source=ct_file,\n            key_provider=kms_key_provider\n        ) as decryptor:\n            for chunk in decryptor:\n                pt_file.write(chunk)\n\n    assert filecmp.cmp(plaintext_filename, new_plaintext_filename)\n    assert encryptor.header.encryption_context == decryptor.header.encryption_context\n\nPerformance Considerations\n==========================\nAdjusting the frame size can significantly improve the performance of encrypt/decrypt operations with this library.\n\nProcessing each frame in a framed message involves a certain amount of overhead.  If you are encrypting a large file,\nincreasing the frame size can offer potentially significant performance gains.  We recommend that you tune these values\nto your use-case in order to obtain peak performance.\n\n\n.. _AWS Encryption SDK: https://docs.aws.amazon.com/encryption-sdk/latest/developer-guide/introduction.html\n.. _cryptography: https://cryptography.io/en/latest/\n.. _cryptography installation guide: https://cryptography.io/en/latest/installation/\n.. _Read the Docs: http://aws-encryption-sdk-python.readthedocs.io/en/latest/\n.. _GitHub: https://github.com/aws/aws-encryption-sdk-python/\n.. _AWS KMS: https://docs.aws.amazon.com/kms/latest/developerguide/overview.html\n.. _KMS customer master key (CMK): https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#master_keys\n.. _KMS key identifier: https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#key-id\n.. _boto3 SDK: https://boto3.readthedocs.io/en/latest/\n.. _standard means by which boto3 locates credentials: https://boto3.readthedocs.io/en/latest/guide/configuration.html\n.. _final message: https://docs.aws.amazon.com/encryption-sdk/latest/developer-guide/message-format.html\n.. _encryption context: https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#encrypt_context\n.. _Security issue notifications: ./CONTRIBUTING.md#security-issue-notifications\n.. _Support Policy: ./SUPPORT_POLICY.rst\n\n\n",
            "description_content_type": "",
            "docs_url": null,
            "download_url": "",
            "downloads": {
                "last_day": -1,
                "last_month": -1,
                "last_week": -1
            },
            "home_page": "https://github.com/aws/aws-encryption-sdk-python",
            "keywords": "aws-encryption-sdk aws kms encryption",
            "license": "Apache License 2.0",
            "maintainer": "Amazon Web Services",
            "maintainer_email": "",
            "name": "aws-encryption-sdk",
            "package_url": "https://pypi.org/project/aws-encryption-sdk/",
            "platform": null,
            "project_url": "https://pypi.org/project/aws-encryption-sdk/",
            "project_urls": {
                "Homepage": "https://github.com/aws/aws-encryption-sdk-python"
            },
            "release_url": "https://pypi.org/project/aws-encryption-sdk/3.1.1/",
            "requires_dist": [
                "boto3 (>=1.10.0)",
                "cryptography (>=2.5.0)",
                "attrs (>=17.4.0)",
                "wrapt (>=1.10.11)"
            ],
            "requires_python": "",
            "summary": "AWS Encryption SDK implementation for Python",
            "version": "3.1.1",
            "yanked": false,
            "yanked_reason": null
        },
        "last_serial": 14939260,
        "urls": [
            {
                "comment_text": "",
                "digests": {
                    "md5": "d3d2210136cf880a3982f632aa2ed558",
                    "sha256": "a3cbbf04e0b9038b9180af8b03da896af19083e00ca011dcfcb403421458ad02"
                },
                "downloads": -1,
                "filename": "aws_encryption_sdk-3.1.1-py2.py3-none-any.whl",
                "has_sig": false,
                "md5_digest": "d3d2210136cf880a3982f632aa2ed558",
                "packagetype": "bdist_wheel",
                "python_version": "py2.py3",
                "requires_python": null,
                "size": 99149,
                "upload_time": "2022-06-21T18:58:55",
                "upload_time_iso_8601": "2022-06-21T18:58:55.386230Z",
                "url": "https://files.pythonhosted.org/packages/16/fb/db663aae8b47cee294e5dda18d0cd177f75f0af667908a3d74afe7253233/aws_encryption_sdk-3.1.1-py2.py3-none-any.whl",
                "yanked": false,
                "yanked_reason": null
            },
            {
                "comment_text": "",
                "digests": {
                    "md5": "09e9ae75e71288935e5c7707a588511c",
                    "sha256": "8d5fbf018fc68d6b1cacbe4dd037fd805296c7736a9fe457eb684d053f7f9563"
                },
                "downloads": -1,
                "filename": "aws-encryption-sdk-3.1.1.tar.gz",
                "has_sig": false,
                "md5_digest": "09e9ae75e71288935e5c7707a588511c",
                "packagetype": "sdist",
                "python_version": "source",
                "requires_python": null,
                "size": 203478,
                "upload_time": "2022-06-21T18:58:59",
                "upload_time_iso_8601": "2022-06-21T18:58:59.189649Z",
                "url": "https://files.pythonhosted.org/packages/15/1e/0e2e88747d011cedef70d3aa72867d3dfad2a2c7757d6ff9418de00b4aaf/aws-encryption-sdk-3.1.1.tar.gz",
                "yanked": false,
                "yanked_reason": null
            }
        ],
        "vulnerabilities": []
    }
}