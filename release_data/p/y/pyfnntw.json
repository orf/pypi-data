{
    "0.1.3": {
        "info": {
            "author": "Cavey Cool <caveycool@gmail.com>",
            "author_email": "Cavey Cool <caveycool@gmail.com>",
            "bugtrack_url": null,
            "classifiers": [
                "Programming Language :: Python :: Implementation :: CPython",
                "Programming Language :: Python :: Implementation :: PyPy",
                "Programming Language :: Rust"
            ],
            "description": "# FNNTW: Fastest Nearest Neighbor (in the) West\n\nFastest Neighbor Nearest Neighbor (in the) West is an in-development kD-tree library that aims to be one of the most, if not the most, performant parallel kNN libraries that exist.\n\n\n### Basic Usage\n```python\nimport pyfnntw;\nimport numpy as np;\nfrom scipy.spatial import cKDTree as Tree\nfrom time import time\n\nND = 10**5\nNQ = 10**6\nRUNS = 10\nTRIALS = 10\nWARMUP = 5\n\n# Get some data and queries\ndata = np.random.uniform(size=(ND, 3))\nquery = np.random.uniform(size=(NQ, 3))\n\n# Build and query the pynntw tree\ntree1 = pyfnntw.Tree(data, 32, 1)\n(_, ids1) = tree1.query(query)\n\n# Build and query the scipy tree\ntree2 = pyfnntw.Tree(data, 32, 1)\n(_, ids2) = tree2.query(query)\n\nif np.all(ids1 == ids2):\n    print(\"Success\")\nelse:\n    print(\"Failure\")\n```\n\nThere are several key components of the building and querying process of the kD-trees that allows for its performance.\n\n### 1. Building The Tree\n##### a. Using Quickselect\nBy using the quickselect in the form of `select_nth_unstable_by` in Rust's `core::slice` instead of an average or even some other median algorithm, we get the `left` and `right` subsets for free in the same O(N) algorithm instead of having to do yet another O(N) comparisons to obtain the `left` and `right` bins. As such, the build is still O(N log(N)), but removes a whole O(N) operation that is found in many other libraries during each splitting.\n\n##### b. Parallel build\nMany kD-Tree build implementations are not parallel. Every subtree of a kD-tree is an independent kD-tree. So, after some number of splittings one could throw the builds of the remaining subtrees on different threads. This is done here at the user-specified `par_split_level`, which is the tree depth at which the parallelism begins. See note in **Benchmark Against Other Codes** about recommended values. \n\n### 2. Querying the tree\nMost libraries return either the kNN distance or the distance and the corresponding data point's index. Here we return the distance, the index, and the neighbor. The way in which we obtain the index is new.\n##### a. `HashMap<&'[NotNan<f64>; D], u64>`\nWe attempted to do what other libraries do, which is to carry around the data's index in some struct or tuple, e.g. `&(usize, [NotNan<f64>; D])`, but found poor performance. By using the `ordered_float` crate's `NotNan<T>`, struct, floating points become hashable. Then, one can do all querying operations using just the query and candiate positions, and then do an O(1) lookup at the end to retrieve the closest neighbor's index. This `HashMap` is constructed at build time **in parallel** with the tree itself, adding only the minimal overhead of a thread spawn.\n\n### 3. Unsafe Accesses (Maybe.. Probably Minor, Not Benchmarked)\n(I debated about whether I should even mention this one...) Because we know the shape of all arrays (i.e. the dimension of the tree) at compile time, the `unsafe` methods `get_unchecked` and `get_unchecked_mut` are used liberally throughout the code. Although the impact of this has not been meausured explicitly, theoretically this means virtually no bounds checks are done. It is possible that LLVM would have optimized away lots of the bounds checks anyway. There are also `unwrap_unchecked` calls for `Option<T>` which the algorithm guarantees to be nonempty. (Going against best practices, these two use cases were pre-optimizations).\n\n\n# Present State of the Code\nAt present, the library only serves 1NN queries. In the very near future, this functionality will be expanded to kNN (k>1) queries. In addition, support for periodic boundary conditions will be added. Finally, there are plans to add generic parameters to allow for monomorphization over `f32` and `f64` (at present only `f64` is supported).\n\n\n# Benchmark Against Other Codes\nThis library is intended to be used by the author to calculate summary statistics in cosmology. As such, the parameters of the benchmark chosen are close to those that would be used in analyzing the output of a cosmological simulation. In such an application, often many subsamples or simulation boxes are used. So, the combined build + query time is important since many different trees may be constructed in an analysis. We use \n - A mock dataset of 100,000 uniform random points in the unit cube.\n - A query set of 1,000,000 uniform random points in the unit cube.\n\nOver 100 realizations of the datasets and query points, the following results are obtained for the average build (serial) and 1NN query times on an AMD EPYC 7502P using 48 threads. The results are sorted by the combined build and query time. \n\n|  Code | Build (ms)| Query (ms) | Total (ms) |\n|---|---|---|---|\n| FNNTW | 11 | 28 | 39 |\n| pykdtree (python)| 12 | 36 | 48  |\n| nabo-rs (rust)| 25 | 30  | 55 |\n| Scipy's cKDTree (python) | 31 | 47 | 78 |\n| kiddo (rust)| 26 | 84 | 110 |\n(These results are for the base Rust code. Calling the code within python adds a bit of overhead. Using the parallel build we measure about 9-10ms for the query, and about 32ms for the query).\n\nWith FNNTW's parallel build capability, the build time goes as low as 8.7 ms on the AMD EPYC 7502P (at `split_level = 1`). Since the overhead of the parallelism and atomic operations slows down the build when the number of datapoints is small, both a parallel build and non_parallel build are available via `Tree:new(..)` and `Tree::new_parallel(..)`. The latter takes the aforementioned parameter `par_split_level`, which is the split depth at which the parallelism begins. Although for our applications of O(1e5) points we see the biggest improvement for `par_split_level = 1`, we suspect that the optimal `par_split_level` will increase with the size of the dataset. \n\n\n\n",
            "description_content_type": "text/markdown; charset=UTF-8; variant=GFM",
            "docs_url": null,
            "download_url": null,
            "downloads": {
                "last_day": -1,
                "last_month": -1,
                "last_week": -1
            },
            "home_page": null,
            "keywords": null,
            "license": "MIT OR Apache-2.0",
            "maintainer": null,
            "maintainer_email": null,
            "name": "pyfnntw",
            "package_url": "https://pypi.org/project/pyfnntw/",
            "platform": null,
            "project_url": "https://pypi.org/project/pyfnntw/",
            "project_urls": {
                "Source Code": "https://github.com/cavemanloverboy/fnstw"
            },
            "release_url": "https://pypi.org/project/pyfnntw/0.1.3/",
            "requires_dist": null,
            "requires_python": ">=3.7",
            "summary": "FNNTW: Fastest Nearest Neighbor (in the) West. A fast kdtree/kNN library.",
            "version": "0.1.3",
            "yanked": false,
            "yanked_reason": null
        },
        "last_serial": 14825018,
        "urls": [
            {
                "comment_text": null,
                "digests": {
                    "md5": "c369fdc56e43349cca3f458162491c94",
                    "sha256": "ba7e37778dbd44587dab13269a60080a059b4645e361603a67e5d52dec638004"
                },
                "downloads": -1,
                "filename": "pyfnntw-0.1.3-cp39-cp39-manylinux_2_31_x86_64.whl",
                "has_sig": false,
                "md5_digest": "c369fdc56e43349cca3f458162491c94",
                "packagetype": "bdist_wheel",
                "python_version": "cp39",
                "requires_python": ">=3.7",
                "size": 308052,
                "upload_time": "2022-08-21T03:53:52",
                "upload_time_iso_8601": "2022-08-21T03:53:52.203141Z",
                "url": "https://files.pythonhosted.org/packages/f7/71/a5ce8f377699f89fba6ea224e00c5b789f016262837470852ce7e0bbd95f/pyfnntw-0.1.3-cp39-cp39-manylinux_2_31_x86_64.whl",
                "yanked": false,
                "yanked_reason": null
            },
            {
                "comment_text": null,
                "digests": {
                    "md5": "0f4b0e87460a3ba5a1f2f6bd41f69d98",
                    "sha256": "60fc3091d0a6dfa1d21d205e61508b21222f35682125d80f39fc922763459a95"
                },
                "downloads": -1,
                "filename": "pyfnntw-0.1.3.tar.gz",
                "has_sig": false,
                "md5_digest": "0f4b0e87460a3ba5a1f2f6bd41f69d98",
                "packagetype": "sdist",
                "python_version": "source",
                "requires_python": ">=3.7",
                "size": 72890264,
                "upload_time": "2022-08-21T03:53:59",
                "upload_time_iso_8601": "2022-08-21T03:53:59.888117Z",
                "url": "https://files.pythonhosted.org/packages/4f/fd/6a5eb6322f2383f7ffd823cd71c87b41b0286132d8d41114855f08968c82/pyfnntw-0.1.3.tar.gz",
                "yanked": false,
                "yanked_reason": null
            }
        ],
        "vulnerabilities": []
    }
}