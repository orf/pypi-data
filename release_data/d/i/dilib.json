{
    "0.0.1": {
        "info": {
            "author": "",
            "author_email": "",
            "bugtrack_url": null,
            "classifiers": [],
            "description_content_type": null,
            "docs_url": null,
            "download_url": "",
            "downloads": {
                "last_day": -1,
                "last_month": -1,
                "last_week": -1
            },
            "home_page": "",
            "keywords": "",
            "license": "",
            "maintainer": "",
            "maintainer_email": "",
            "name": "dilib",
            "package_url": "https://pypi.org/project/dilib/",
            "platform": "",
            "project_url": "https://pypi.org/project/dilib/",
            "project_urls": null,
            "release_url": "https://pypi.org/project/dilib/0.0.1/",
            "requires_dist": null,
            "requires_python": null,
            "summary": "",
            "version": "0.0.1",
            "yanked": false,
            "yanked_reason": null
        },
        "last_serial": 16000109,
        "urls": [],
        "vulnerabilities": []
    },
    "0.3.0": {
        "info": {
            "author": "",
            "author_email": "",
            "bugtrack_url": null,
            "classifiers": [],
            "description_content_type": "text/markdown",
            "docs_url": null,
            "download_url": "",
            "downloads": {
                "last_day": -1,
                "last_month": -1,
                "last_week": -1
            },
            "home_page": "",
            "keywords": "dependency injection, di, inversion of control, ioc, design patterns",
            "license": "Apache License 2.0",
            "maintainer": "",
            "maintainer_email": "",
            "name": "dilib",
            "package_url": "https://pypi.org/project/dilib/",
            "platform": null,
            "project_url": "https://pypi.org/project/dilib/",
            "project_urls": null,
            "release_url": "https://pypi.org/project/dilib/0.3.0/",
            "requires_dist": [
                "black (>=22.8) ; extra == 'testing'",
                "docformatter (>=1.5.0) ; extra == 'testing'",
                "flake8 (>=5.0.4) ; extra == 'testing'",
                "isort (>=5.2.2) ; extra == 'testing'",
                "mypy (>=0.800) ; extra == 'testing'",
                "pytest (>=6.2.5) ; extra == 'testing'",
                "pytest-cov (<3,>=2) ; extra == 'testing'",
                "tox (>=3.27.1) ; extra == 'testing'"
            ],
            "requires_python": ">=3.7",
            "summary": "Dependency injection library",
            "version": "0.3.0",
            "yanked": false,
            "yanked_reason": null
        },
        "last_serial": 16000109,
        "urls": [
            {
                "comment_text": "",
                "digests": {
                    "md5": "9bf16efc5b600ee09dc346873017e8ed",
                    "sha256": "846753c730f5f418e0790947573556af4d446804d9feee5b74fa49d95cfcfdd4"
                },
                "downloads": -1,
                "filename": "dilib-0.3.0-py3-none-any.whl",
                "has_sig": false,
                "md5_digest": "9bf16efc5b600ee09dc346873017e8ed",
                "packagetype": "bdist_wheel",
                "python_version": "py3",
                "requires_python": ">=3.7",
                "size": 19620,
                "upload_time": "2022-12-05T20:59:27",
                "upload_time_iso_8601": "2022-12-05T20:59:27.445623Z",
                "url": "https://files.pythonhosted.org/packages/63/dc/ed557591be73e2697299da6703a7a9c01dec12a1ffcad98ec399b32b44be/dilib-0.3.0-py3-none-any.whl",
                "yanked": false,
                "yanked_reason": null
            },
            {
                "comment_text": "",
                "digests": {
                    "md5": "ea6b01cc8ad4c11f7de085a2a61a52fe",
                    "sha256": "a4b9933a80183c1db3d8d06a2f9e8f5e1cdead550fc4633f624a2a9075c98031"
                },
                "downloads": -1,
                "filename": "dilib-0.3.0.tar.gz",
                "has_sig": false,
                "md5_digest": "ea6b01cc8ad4c11f7de085a2a61a52fe",
                "packagetype": "sdist",
                "python_version": "source",
                "requires_python": ">=3.7",
                "size": 21736,
                "upload_time": "2022-12-05T20:59:28",
                "upload_time_iso_8601": "2022-12-05T20:59:28.541045Z",
                "url": "https://files.pythonhosted.org/packages/0c/f6/559fe26887c0ffda3ec3233cad816f6296372f30056a51e7c19cfccd65c5/dilib-0.3.0.tar.gz",
                "yanked": false,
                "yanked_reason": null
            }
        ],
        "vulnerabilities": []
    },
    "0.3.1": {
        "info": {
            "author": "",
            "author_email": "",
            "bugtrack_url": null,
            "classifiers": [
                "Development Status :: 5 - Production/Stable",
                "Intended Audience :: Developers",
                "Operating System :: OS Independent",
                "Programming Language :: Python :: 3.10",
                "Programming Language :: Python :: 3.11",
                "Programming Language :: Python :: 3.7",
                "Programming Language :: Python :: 3.8",
                "Programming Language :: Python :: 3.9",
                "Programming Language :: Python :: Implementation :: CPython",
                "Programming Language :: Python :: Implementation :: PyPy",
                "Topic :: Software Development :: Libraries",
                "Topic :: Utilities"
            ],
            "description": "# dilib\n\nDependency injection (DI) library for python\n\n[![PyPI version](https://badge.fury.io/py/dilib.svg)](https://badge.fury.io/py/dilib)\n[![PyPI Supported Python Versions](https://img.shields.io/pypi/pyversions/dilib.svg)](https://pypi.python.org/pypi/dilib/)\n[![GitHub Actions (Tests)](https://github.com/ansatzcapital/dilib/workflows/Test/badge.svg)](https://github.com/ansatzcapital/dilib)\n\n## About DI\n\n[Dependency injection](https://en.wikipedia.org/wiki/Dependency_injection) can be thought of as a \n**software engineering pattern** as well as a **framework**. The goal is to develop objects in a more\ncomposable and modular way.\n\nThe **pattern** is: when creating objects, always express what you depend on, \nand let someone else give you those dependencies.\n\nThe **framework** is meant to ease the inevitable boilerplate that occurs when following this pattern, and dilib\nis one such framework.\n\nSee the [Google Clean Code Talk about Dependency Injection](https://testing.googleblog.com/2008/11/clean-code-talks-dependency-injection.html).\n\n## Quick Start\n\nThere are 3 major parts of this framework:\n- `dilib.{Prototype,Singleton}`: Recipe on how to instantiate the object when needed. `dilib.Prototype` \ncreates a new instance per call, while `dilib.Singleton` ensures only 1 instance of the object exists per config field.\n- `dilib.Config`: Nestable bag of params (types and values) that can be loaded, perturbed, and saved.\n- `dilib.Container`: The object retriever--it's in charge of _materializing_ delayed specs that \nare wired together by config into actual instances (plus caching, as necessary per the spec chosen).\n\n```python\nimport dilib\n\n\n# API\nclass Engine:\n    pass\n\n\n# An implementation of the engine API that makes network calls\nclass DBEngine(Engine):\n    def __init__(self, addr: str, user: str):\n        self.addr = addr\n        self.user = user\n\n\n# An implementation of the engine API designed for testing\nclass MockEngine(Engine):\n     pass\n\n\nclass Car:\n    # Takes an Engine instance via constructor injection\n    def __init__(self, engine: Engine):\n        self.engine = engine\n\n\nclass EngineConfig(dilib.Config):\n    db_addr = dilib.GlobalInput(str, \"some-db-addr\")\n    db_user = dilib.LocalInput(str)\n    adj_db_user = dilib.Prototype(lambda x: x + \".foo\", x=db_user)\n\n    # Objects depend on other objects via named aliases\n    engine = dilib.Singleton(DBEngine, db_addr, user=adj_db_user)\n    # Or equivalently, if DBEngine used dilib.SingletonMixin:\n    # engine = dilib.DBEngine(db_addr, user=adj_db_user)\n\n\nclass CarConfig(dilib.Config):\n    # Configs depend on other configs via types. Here, CarConfig depends on EngineConfig\n    engine_config = EngineConfig(db_user=\"user\")\n\n    car = dilib.Singleton(Car, engine_config.engine)\n\n\n# Get instance of config (with global input value set)\ncar_config = CarConfig().get(db_addr=\"some-other-db-addr\")\n\n# Perturb here as you'd like. E.g.:\ncar_config.engine_config.Engine = MockEngine()\n\n# Pass config to a container that can get and cache objs for you\ncontainer = dilib.Container(car_config)\n\nassert container.engine_config.db_addr == \"some-other-db-addr\"\nassert isinstance(container.car, Car)\nassert container.car is container.car  # Because it's a Singleton\n```\n\nNotes:\n- `Car` *takes in* an `Engine` instead of making or getting one within itself.\n- For this to work, `Car` cannot make any assumptions about *what kind* of `Engine` it received.\nDifferent engines have different constructor params \nbut have the [same API and semantics](https://en.wikipedia.org/wiki/Liskov_substitution_principle).\n\n## Compare with Other DI Frameworks\n\n### pinject\n\nA prominent DI library in python is [pinject](https://github.com/google/pinject).\n\n#### Advantages of dilib\n- Focus on simplicity. E.g.:\n  - `foo = \"a\"` rather than `bind(\"foo\", to_instance=\"a\")`.\n  - Child configs look like just another field on the config.\n- Getting is via *names* rather than *classes*.\n  - In pinject, the equivalent of `ctr.__getattr__()` takes a class (like `Car`) rather than a config address.\n- No implicit wiring: No assumptions are made about aligning arg names with config params.\n  - Granted, pinject does have an explicit mode, but the framework's default state is implicit.\n  - The explicit wiring in dilib configs obviates the need for complications like \n  [inject decorators](https://github.com/google/pinject#safety) \n  and [annotations](https://github.com/google/pinject#annotations).\n- Minimal or no pollution of objects: Objects are not aware of the DI framework. The only exception is\nif you want the IDE autocompletion to work in configs (e.g., `car = Car(engine=...)`), you have\nto inherit from, e.g., `dilib.SingletonMixin`, but this is completely optional. \nIn pinject, on the other hand, one is required to decorate with `@pinject.inject()` in some circumstances.\n\n### dependency-injector\n\nAnother prominent DI library in python is [dependency-injector](https://github.com/ets-labs/python-dependency-injector).\n\n#### Advantages of dilib\n- dilib discourages use of class-level state by not supporting it\n(that is, `dilib.Container` is equivalent to `dependency_injector.containers.DynamicContainer`).\n- Cleaner separation between \"config\" and \"container\" (dependency-injector conflates the two).\n- Easy-to-use perturbing with simple `config.x = new_value` syntax.\n- Easier to nest configs via config locator pattern.\n- Child configs are typed instead of relying on `DependenciesContainer` stub (which aids in IDE auto-complete).\n- Easier-to-use global input configuration.\n- Written in native python for more transparency.\n\n## Design\n\n### Prevent Pollution of Objects\n\nThe dependency between the DI config and the actual objects in the object graph should be one way: \nthe DI config depends on the object graph types and values. This keeps the objects clean of \nparticular decisions made by the DI framework.\n\n(dilib offers optional mixins that violate this decision for users that want to favor the typing and \nauto-completion benefits of using the object types directly.)\n\n### Child Configs are Singletons by Type\n\nIn dilib, when you set a child config on a config object, you're not actually instantiating the child config. \nRather, you're creating a spec that will be instantiated when the root config's `.get()` is called. \nThis means that the config instances are singletons by type \n(unlike the actual objects specified in the config, which are by alias). \nIt would be cleaner to create instances of common configs and pass them through to other configs \n(that's what DI is all about!). However, the decision was made to not allow this because this would make \nbuilding up configs almost as complicated as building up the actual object graph users are interested in \n(essentially, the user would be engaged in an abstract meta-DI problem). \nAs such, all references to the same config type are automatically resolved to the same instance, \nat the expense of some flexibility and directness. \nThe upside, however, is that it's much easier to create nested configs, \nwhich means users can get to designing the actual object graph quicker.\n\n### Factories for Dynamic Objects\n\nIf you need to configure objects dynamically (e.g., check db value to resolve what type to use, \nset config keys based on another value), consider a factory pattern like:\n\n```python\nimport dilib\n\n\nclass Foo:\n    @property\n    def value(self) -> int:\n        ...\n\n\nclass FooFactory:\n    def get_foo(self) -> Foo:\n        ...\n\n\nclass FooClient:\n    def __init__(self, foo_factory: FooFactory):\n        self.foo_factory = foo_factory\n        \n    def get_foo_value(self) -> int:\n        foo = self.foo_factory.get_foo()\n        return foo.value\n\n\nclass FooConfig(dilib.Config):\n    db_param = dilib.Object(\"some-db-addr\")\n    foo_factory = dilib.Singleton(FooFactory, db_param)\n    foo_client = dilib.Singleton(FooClient, foo_factory=foo_factory)\n```\n\n### Typing\n\nThe next design goal is to add typing to dilib, e.g.:\n\n```python\nimport dilib\n\n\nclass SomeConfig(dilib.Config):\n    x = dilib.Object(1)  # Should pick up x as int\n    y: Engine = dilib.Singleton(DBEngine, ...)  # Pick the base class for type\n\n\n# ...\nctr = ...  # Container type should be dilib.Container[SomeConfig]\nx = ctr.config.x  # Type systems should pick up that x is an int\n```\n",
            "description_content_type": "text/markdown",
            "docs_url": null,
            "download_url": "",
            "downloads": {
                "last_day": -1,
                "last_month": -1,
                "last_week": -1
            },
            "home_page": "https://github.com/ansatzcapital/dilib",
            "keywords": "dependency injection, di, inversion of control, ioc, design patterns",
            "license": "Apache License 2.0",
            "maintainer": "",
            "maintainer_email": "",
            "name": "dilib",
            "package_url": "https://pypi.org/project/dilib/",
            "platform": "any",
            "project_url": "https://pypi.org/project/dilib/",
            "project_urls": {
                "Homepage": "https://github.com/ansatzcapital/dilib",
                "Packaging": "https://pypi.org/project/dilib/",
                "Source": "https://github.com/ansatzcapital/dilib",
                "Tracker": "https://github.com/ansatzcapital/dilib/issues"
            },
            "release_url": "https://pypi.org/project/dilib/0.3.1/",
            "requires_dist": [
                "black (>=22.8) ; extra == 'testing'",
                "docformatter (>=1.5.0) ; extra == 'testing'",
                "flake8 (>=5.0.4) ; extra == 'testing'",
                "isort (>=5.2.2) ; extra == 'testing'",
                "mypy (>=0.800) ; extra == 'testing'",
                "pytest (>=6.2.5) ; extra == 'testing'",
                "pytest-cov (<3,>=2) ; extra == 'testing'",
                "tox (>=3.27.1) ; extra == 'testing'"
            ],
            "requires_python": ">=3.7",
            "summary": "Dependency injection library",
            "version": "0.3.1",
            "yanked": false,
            "yanked_reason": null
        },
        "last_serial": 16000109,
        "urls": [
            {
                "comment_text": "",
                "digests": {
                    "md5": "e5798794de909e30dde4fbd0254c6be6",
                    "sha256": "9eca55f8fb6f3e6ad187002c4b867e531c63c3dee39388b90e3abedd65ce8ad8"
                },
                "downloads": -1,
                "filename": "dilib-0.3.1-py3-none-any.whl",
                "has_sig": false,
                "md5_digest": "e5798794de909e30dde4fbd0254c6be6",
                "packagetype": "bdist_wheel",
                "python_version": "py3",
                "requires_python": ">=3.7",
                "size": 19851,
                "upload_time": "2022-12-05T21:12:32",
                "upload_time_iso_8601": "2022-12-05T21:12:32.654206Z",
                "url": "https://files.pythonhosted.org/packages/18/9a/8d0cfb32a23919b48a67dbb5ee6109bfcee759e68af4411992ab9ae00764/dilib-0.3.1-py3-none-any.whl",
                "yanked": false,
                "yanked_reason": null
            },
            {
                "comment_text": "",
                "digests": {
                    "md5": "87b1647903b833b54b4a144a4fdfadf5",
                    "sha256": "7c054417b3b1b327c8a3f947d24ffae06fcbdee58f242629595b2228f8b8bcc9"
                },
                "downloads": -1,
                "filename": "dilib-0.3.1.tar.gz",
                "has_sig": false,
                "md5_digest": "87b1647903b833b54b4a144a4fdfadf5",
                "packagetype": "sdist",
                "python_version": "source",
                "requires_python": ">=3.7",
                "size": 22367,
                "upload_time": "2022-12-05T21:12:34",
                "upload_time_iso_8601": "2022-12-05T21:12:34.295159Z",
                "url": "https://files.pythonhosted.org/packages/24/24/759fb68abf0b6893310bd1d83d5c9e270f13f8eb4afb6c24a5983183a0d7/dilib-0.3.1.tar.gz",
                "yanked": false,
                "yanked_reason": null
            }
        ],
        "vulnerabilities": []
    }
}