{
    "1.0.0": {
        "info": {
            "author": "Abner",
            "author_email": "abnersousanascimento@gmail.com",
            "bugtrack_url": null,
            "classifiers": [
                "License :: OSI Approved :: GNU General Public License v3 (GPLv3)",
                "Natural Language :: Portuguese (Brazilian)",
                "Operating System :: OS Independent",
                "Programming Language :: Python :: 3.0",
                "Topic :: Scientific/Engineering :: Artificial Intelligence",
                "Topic :: Scientific/Engineering :: Image Recognition"
            ],
            "description": "# Segmenta\u00e7\u00e3o Bayesiana de Cores em Imagens\n\n\n![PyPI](https://img.shields.io/pypi/v/nine.svg?style=flat-square)\n![GitHub release](https://img.shields.io/github/release/abnersn/bayesian_sgm.svg?style=flat-square)\n![PyPI - Python Version](https://img.shields.io/pypi/pyversions/Django.svg?style=flat-square)\n[![Twitter Follow](https://img.shields.io/twitter/follow/asnasc.svg?style=flat-square&label=Follow)](https://twitter.com/asnasc) \n\n\nEste trabalho prop\u00f5e o uso de um classificador Naive Bayes para a tarefa de segmenta\u00e7\u00e3o de imagens por cor, empregando duas classes de dados em seu modelo estat\u00edstico: pele e n\u00e3o-pele. Busca-se assim, obter um algoritmo de segmenta\u00e7\u00e3o por cor dotado de bons n\u00edveis de precis\u00e3o e velocidade suficiente para ser aplicado em filmagens em tempo real em um computador pessoal.\n\n## Pr\u00e9-requisitos\n* Python 3.5.5\n* OpenCV 3.1.0 ou superior\n* Numpy 1.14.3 ou superior\n\n## Instala\u00e7\u00e3o\nAp\u00f3s a instala\u00e7\u00e3o dos pr\u00e9-requisitos, \u00e9 poss\u00edvel instalar o segmentador pelo reposit\u00f3rio de pacotes do python com o comando:\n```\n$ sudo pip install bayesian_sgm\n```\n## Exemplo\nAs imagens de treino e as respectivas vers\u00f5es bin\u00e1rias devem ser organizadas com o mesmo nome de arquivo, por\u00e9m em pastas diferentes. No exemplo abaixo, as imagens coloridas est\u00e3o na pasta `n_dataset`, e a classifica\u00e7\u00e3o bin\u00e1ria em `c_dataset`.\n```\n.\n\u251c\u2500\u2500 datasets\n\u2502   \u251c\u2500\u2500 c_dataset\n\u2502   \u2502   \u251c\u2500\u2500 treino1.jpg\n\u2502   \u2502   \u251c\u2500\u2500 treino2.jpg\n\u2502   \u2502   \u251c\u2500\u2500 treino3.jpg\n\u2502   \u2502   \u251c\u2500\u2500 treino4.jpg\n\u2502   \u2502   \u2514\u2500\u2500 ...\n\u2502   \u2514\u2500\u2500 n_dataset\n\u2502       \u251c\u2500\u2500 treino1.jpg\n\u2502       \u251c\u2500\u2500 treino2.jpg\n\u2502       \u251c\u2500\u2500 treino3.jpg\n\u2502       \u251c\u2500\u2500 treino4.jpg\n\u2502       \u2514\u2500\u2500 ...\n\u2514\u2500\u2500 script.py\n```\nO arquivo `script.py` realiza o treinamento com base no dataset fornecido e aplica o segmentador no v\u00eddeo capturado pela webcam.\n```python\nimport cv2\nimport numpy as np\nimport bayesian_sgm\n\nseg = bayesian_sgm.BayesianColorSGM()\nseg.learn_from_dirs(\"datasets/c_dataset\", \"datasets/n_dataset\")\n\ncap = cv2.VideoCapture(0)\nwhile(True):\n    ret, img = cap.read()\n    bin = seg.apply(img)\n    cv2.imshow(\"frame\", img)\n    cv2.imshow(\"binary\", bin)\n    k = cv2.waitKey(30) & 0xFF\n    if k == 27:\n        break\n```\n\n## Fundamenta\u00e7\u00e3o Te\u00f3rica\n\n### Introdu\u00e7\u00e3o\n\nA separa\u00e7\u00e3o de regi\u00f5es correspondentes \u00e0 pele humana em imagens digitais possui fundamental import\u00e2ncia para a solu\u00e7\u00e3o de problemas relacionados \u00e0 vis\u00e3o computacional, como detec\u00e7\u00e3o de face, detec\u00e7\u00e3o de gestos e classifica\u00e7\u00e3o de conte\u00fado. Tais aplica\u00e7\u00f5es empregam algoritmos de segmenta\u00e7\u00e3o com o objetivo de delimitar \u00e1reas de interesse nas imagens, de modo a reduzir o escopo de informa\u00e7\u00f5es a serem processadas e obter ganhos de desempenho.\n\nDiversas s\u00e3o as t\u00e9cnicas envolvidas na tarefa de segmenta\u00e7\u00e3o de imagens, como k-means e outras formas de reconhecimento de padr\u00f5es. Por\u00e9m, devido \u00e0s suas propriedades f\u00edsicas e forma peculiar de interagir com a luz, a pele humana possui caracter\u00edsticas visuais que a diferenciam de elementos inorg\u00e2nicos, o que traz vantagem a abordagens baseadas na cor. De fato, o espectro de tonalidades da pele humana \u00e9 relativamente limitado, mesmo levando em considera\u00e7\u00e3o varia\u00e7\u00f5es \u00e9tnicas.\n\nO problema resume-se, ent\u00e3o, a determinar se um dado conjunto de pixels pertence ou n\u00e3o a uma regi\u00e3o de pele humana com base em sua cor. Nesse contexto, a escolha do espa\u00e7o de cores mais adequado aos matizes da pele humana, bem como o emprego de um modelo estat\u00edstico que permita analisar um conjunto previamente classificado de imagens pode ser uma solu\u00e7\u00e3o eficaz. Tais escolhas est\u00e3o intrinsecamente relacionadas \u00e0 sensibilidade dos algoritmos de segmenta\u00e7\u00e3o a problemas como condi\u00e7\u00f5es de ilumina\u00e7\u00e3o desfavor\u00e1veis e oclus\u00e3o.\n\n### Metodologia\n\nO teorema de Bayes, nomeado em homenagem a seu idealizador, Thomas Bayes (1701-1761), estabelece uma rela\u00e7\u00e3o matem\u00e1tica para as probabilidades de eventos condicionados a evid\u00eancias pr\u00e9vias. A probabilidade de um evento A, dado que houve a observa\u00e7\u00e3o de uma evid\u00eancia B \u00e9 descrita por:\n\n![](https://latex.codecogs.com/gif.latex?P%28A%7CB%29%3D%5Cfrac%7BP%28B%7CA%29%5Ctimes%7BP%28A%29%7D%7D%7BP%28B%29%7D).\n\nEste princ\u00edpio possui diversas aplica\u00e7\u00f5es no campo da infer\u00eancia estat\u00edstica, em problemas que demandam a dedu\u00e7\u00e3o de informa\u00e7\u00f5es a partir da an\u00e1lise de um conjunto de amostras. Filtros de spam, por exemplo, analisam o texto de diversos emails classificados pelos usu\u00e1rios como spam e n\u00e3o-spam e determinam a classe na qual se enquadra uma nova amostra com base na equa\u00e7\u00e3o acima.\n\nClassificadores Naive Bayes consideram que as caracter\u00edsticas analisadas s\u00e3o independentes entre si. Isto \u00e9, para um conjunto ![](https://latex.codecogs.com/gif.latex?A%3D%7BA_1%2CA_2%2C%5Ccdots%2CA_n%7D) de caracter\u00edsticas condicionadas a uma evid\u00eancia ![](https://latex.codecogs.com/gif.latex?B), tem-se o produt\u00f3rio:\n\n![](https://latex.codecogs.com/gif.latex?P%28A_1%2CA_2%2C%5Ccdots%2CA_n%7CB%29%3D%5Cprod_%7Bi%3D1%7D%5E%7Bn%7D%20P%28A_i%7CB%29.)\n\nTal pressuposto, embora possa comprometer a coer\u00eancia entre o modelo e a rela\u00e7\u00e3o que de fato ocorre entre os dados, \u00e9 capaz de classificar as amostras com n\u00edveis de erro pr\u00f3ximos aos de m\u00e9todos mais robustos.\n\nEsta modelagem matem\u00e1tica pode ser aplicada para a segmenta\u00e7\u00e3o de imagens como uma t\u00e9cnica de classifica\u00e7\u00e3o de pixels em duas classes: pele e n\u00e3o-pele. Para imagens representadas em espa\u00e7os de cor de 3 canais, por exemplo, considera-se que o evento A representa o fato de um pixel pertencer a uma regi\u00e3o de pele. B corresponde ao valor num\u00e9rico que um pixel assume em determinado canal. Logo, primeiramente \u00e9 necess\u00e1rio obter ![](https://latex.codecogs.com/gif.latex?P%28A%29), ![](https://latex.codecogs.com/gif.latex?P%28B%7CA%29) e ![](https://latex.codecogs.com/gif.latex?P%28B%29), conhecidos como probabilidades *a priori*. De forma intuitiva, tem-se, pois:\n\n-   ![](https://latex.codecogs.com/gif.latex?P%28B%7CA%29) = probabilidade de dada cor ser pele;\n\n-   ![](https://latex.codecogs.com/gif.latex?P%28A%29) = probabilidade de encontrar dada cor;\n\n-   ![](https://latex.codecogs.com/gif.latex?P%28B%29) = probabilidade de encontrar pele.\n\n<p align=\"center\">\n<img width=\"200\" src=\"https://s3-sa-east-1.amazonaws.com/abnersn/github/bayesian-segmentator/demo.jpg\">\n<br>\n<strong>Figura 1:</strong> Exemplo de imagem do conjunto classificado manualmente.\n</p>\n\nA partir de um conjunto de imagens como a Figura 1, \u00e9 poss\u00edvel calcular as probabilidades *a priori* necess\u00e1rias para a aplica\u00e7\u00e3o do teorema de Bayes. Ap\u00f3s a an\u00e1lise de todas as imagens em um conjunto pr\u00e9 classificado com a ajuda de um editor de imagens, os valores obtidos das probabilidades para cada canal s\u00e3o armazenados em uma tabela de refer\u00eancia.\n\nAo receber uma imagem in\u00e9dita, o algoritmo busca, para cada pixel, uma probabilidade correspondente na tabela, de acordo com os valores de seus canais, isto \u00e9, sua cor. Em seguida os valores obtidos s\u00e3o multiplicados, conforme, para obter a classifica\u00e7\u00e3o final. Dessa forma, a imagem se torna uma matriz de probabilidades inferidas, com valores entre 0 e 1. Determina-se, ent\u00e3o, um limiar ![](https://latex.codecogs.com/gif.latex?%5Clambda), de modo que:\n\n![](https://latex.codecogs.com/gif.latex?C_A%28p_%7Bi%7D%29%20%3D%20%5Cleft%5C%7B%20%5Cbegin%7Barray%7D%7Bll%7D%200%20%26%20%5Cquad%20p_i%20%5Cleq%20%5Clambda%20%5C%5C%201%20%26%20%5Cquad%20p_i%20%3E%20%5Clambda%20%5Cend%7Barray%7D%20%5Cright.).\n\nOnde ![](https://latex.codecogs.com/gif.latex?p_i) \u00e9 a probabilidade inferida e ![](https://latex.codecogs.com/gif.latex?C_A) corresponde \u00e0 classe atribu\u00edda ao pixel, isto \u00e9, 0 para n\u00e3o-pele e 1 para pele.\n\nPara avaliar a capacidade de acerto do algoritmo, as probabilidades inferidas s\u00e3o comparadas com a classifica\u00e7\u00e3o realizada manualmente. Considerando ![](https://latex.codecogs.com/gif.latex?%5Cepsilon) o erro quadr\u00e1tico m\u00e9dio do algoritmo aplicado em uma imagem composta por ![](https://latex.codecogs.com/gif.latex?n) pixels, obt\u00e9m-se:\n\n![](https://latex.codecogs.com/gif.latex?%5Cepsilon%3D%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%7B%5Cfrac%7B%28p_i%20-%20C_i%29%5E2%7D%7Bn%7D%7D),\n\nonde ![](https://latex.codecogs.com/gif.latex?C_i) representa o valor atribu\u00eddo ao ![](https://latex.codecogs.com/gif.latex?i)-\u00e9simo pixel na classifica\u00e7\u00e3o manual.\n\n### Resultados\n\nA Figura 2 mostra o resultado obtido pelo classificador Naive-Bayes para diferentes espa\u00e7os de cor, nomeadamente, HSV, YCrCb e RGB, bem como as respectivas taxas de erro quadr\u00e1tico m\u00e9dio. As imagens originais est\u00e3o dispon\u00edveis no banco de imagens Wikimedia Commons e foram classificadas manualmente com o aux\u00edlio do editor de imagens GIMP. Neste trabalho, para a obten\u00e7\u00e3o das probabilidades *a priori* foram empregadas 13 imagens, tomando a diversidade \u00e9tnica como crit\u00e9rio para sua escolha. As taxas de acerto obtidas variam, pois, de 88,4\\% para o espa\u00e7o RGB a 90,6\\% no espa\u00e7o YCrCb.\n\n<p align=\"center\">\n<img width=\"500\" src=\"https://s3-sa-east-1.amazonaws.com/abnersn/github/bayesian-segmentator/result.png\">\n<br>\n<strong>Figura 2:</strong> Comparativo de desempenho e taxas de erro em diferentes espa\u00e7os de cor.\n</p>\n\n## Refer\u00eancias\n\n* *Ion Androutsopoulos, John Koutsias, Konstantinos V Chandrinos, GeorgePaliouras, and Constantine D Spyropoulos*. **An evaluation of naive bayesiananti-spam filtering.** arXiv preprint cs/0006013, 2000.\n\n* *James C Bezdek, LO Hall, and LP Clarke*. **Review of mr image segmen-tation techniques using pattern recognition.** Medical physics, 20(4):1033\u20131048, 1992.\n\n* *Margaret M Fleck, David A Forsyth, and Chris Bregler*. **Finding naked people**. Em: European Conference on Computer Vision, pages 593\u2013602. Springer, 1996.\n\n* *Rein-Lien Hsu, M. Abdel-Mottaleb, and A. K. Jain*. **Face detection in color images**. IEEE Transactions on Pattern Analysis and Machine Intelligence, 24(5):696\u2013706, Maio de 2002.\n\n* *Son Lam Phung, Abdesselam Bouzerdoum, and Douglas Chai*. **Skin segmentation using color pixel classification: analysis and comparison**. IEEEtransactions on pattern analysis and machine intelligence, 27(1):148\u2013154, 2005.\n\n## Autor\n* Abner Nascimento - [Universidade Federal do Cear\u00e1](http://www.ec.ufc.br/).\n\n",
            "description_content_type": "text/markdown",
            "docs_url": null,
            "download_url": "",
            "downloads": {
                "last_day": -1,
                "last_month": -1,
                "last_week": -1
            },
            "home_page": "https://github.com/abnersn/bayesian_sgm",
            "keywords": "",
            "license": "",
            "maintainer": "",
            "maintainer_email": "",
            "name": "bayesian-sgm",
            "package_url": "https://pypi.org/project/bayesian-sgm/",
            "platform": "",
            "project_url": "https://pypi.org/project/bayesian-sgm/",
            "project_urls": {
                "Homepage": "https://github.com/abnersn/bayesian_sgm"
            },
            "release_url": "https://pypi.org/project/bayesian-sgm/1.0.0/",
            "requires_dist": [
                "opencv-python (>=3.1.0)",
                "numpy (>=1.14.3)"
            ],
            "requires_python": "",
            "summary": "Um segmentador de cores bayesiano para a OpenCV.",
            "version": "1.0.0",
            "yanked": false,
            "yanked_reason": null
        },
        "last_serial": 4323779,
        "urls": [
            {
                "comment_text": "",
                "digests": {
                    "md5": "31270ed46052730e55566fc4a0139dea",
                    "sha256": "732fb1811d015118e7d4052d6250c25772172be8a63fb2bf7c49e79399d54865"
                },
                "downloads": -1,
                "filename": "bayesian_sgm-1.0.0-py3-none-any.whl",
                "has_sig": false,
                "md5_digest": "31270ed46052730e55566fc4a0139dea",
                "packagetype": "bdist_wheel",
                "python_version": "py3",
                "requires_python": null,
                "size": 19776,
                "upload_time": "2018-09-29T23:54:23",
                "upload_time_iso_8601": "2018-09-29T23:54:23.087236Z",
                "url": "https://files.pythonhosted.org/packages/b2/bf/8768b850457e0ec72e425e48511987d76b159566cd58077d24793334c8fc/bayesian_sgm-1.0.0-py3-none-any.whl",
                "yanked": false,
                "yanked_reason": null
            },
            {
                "comment_text": "",
                "digests": {
                    "md5": "35064a4b45c9dbe473bd75b7788337d2",
                    "sha256": "c065d19d28cc3e9bc6c22562840f2c2d72b06bd478250077f9e9d2e910a56cbe"
                },
                "downloads": -1,
                "filename": "bayesian_sgm-1.0.0.tar.gz",
                "has_sig": false,
                "md5_digest": "35064a4b45c9dbe473bd75b7788337d2",
                "packagetype": "sdist",
                "python_version": "source",
                "requires_python": null,
                "size": 7997,
                "upload_time": "2018-09-29T23:54:24",
                "upload_time_iso_8601": "2018-09-29T23:54:24.522136Z",
                "url": "https://files.pythonhosted.org/packages/8a/a6/866511fed7851049988fda9127937df59df9760561bf510b18f7cb0e7125/bayesian_sgm-1.0.0.tar.gz",
                "yanked": false,
                "yanked_reason": null
            }
        ],
        "vulnerabilities": []
    }
}