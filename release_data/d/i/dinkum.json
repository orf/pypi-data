{
    "1.0.4": {
        "info": {
            "author": "pye, Sean",
            "author_email": "",
            "bugtrack_url": null,
            "classifiers": [],
            "description": "dinkum\n======\n\nTools for interacting with \u2018dinkum binary data\u2019 formatted files.\n\nInstallation:\n=============\n\n-  install conda/miniconda\n-  clone the repository onto your computer and cd into the directory\n\nIf you want to install dinkum environment.\n\n::\n\n   -- from inside the cloned repository directory run `conda env create -f environment.yml`, it will read environment.yml\n\nand automatically install the dependencies, and create environment\nliberdade\n\n::\n\n   -- if dinkum env already exist, use `conda env update -f=environment.yml` for update environment dependencies\n\n   -- source activate dinkum\n\nIf you want to install dinkum as library\n\n::\n\n   pip install git+https://gitlab.oceantrack.org/ocean-gliders-canada/dinkum.git\n\nUsage:\n======\n\nFirst import the library\n\n``import dinkum``\n\n| **dinkum2ascii**\n| Decode a Dinkum Binary Data file or all Dinkum Binary Data under the\n  specific directory. and convert it to ascii file into the given\n  output_dir\n  ``dinkum.dinkum2ascii(sample_file_directory_path, cache_directory_path, output_path)``\n\n| **dinkum2dicts**\n| Decode a Dinkum Binary Data file or all Dinkum Binary Data under the\n  specific directory.\n| Return a list of python dictionaries, which looks like {\u2018cache\u2019:cache,\n  \u2018data\u2019:data, \u2018header\u2019:header}\n| ``res = dinkum.dinkum2dicts(sample_file_directory_path, cache_path)``\n| res looks like [dict1, dict2, dict3] (if under input dir has three\n  Dinkum Binary files)\n| dict1 looks like\n| {\n| \\* \u2018cache\u2019: (list)[ - {\u2018index\u2019: \u20180\u2019, \u2018unit\u2019: \u2018cc\u2019, \u2018sensor_name\u2019:\n  \u2018c_ballact_bpumped\u2019, \u2018transmitted\u2019: \u2018T\u2019, number_of_bytes\u2019: \u20184\u2019,\n  \u2018sensor_number\u2019: \u201860\u2019},\n| - {\u2018index\u2019: \u20181\u2019, \u2018unit\u2019: \u2018x\u2019, \u2018sensor_name\u2019: \u2018c_ballact_bpumped\u2019,\n  \u2018transmitted\u2019: \u2018T\u2019, \u2018number_of_bytes\u2019: \u20184\u2019, \u2018sensor_number\u2019: \u2018117\u2019},\n| - \u2026\n| ],\n| \\* \u2018data\u2019: (list) [\n| - [233.0, \u2018NaN\u2019, \u2018NaN\u2019, 0.0, \u2018NaN\u2019,\u2018NaN\u2019, 2, \u2026],\n| - [\u2018NaN\u2019, \u2018NaN\u2019, \u2018NaN\u2019, 0.0, \u2018NaN\u2019,\u2018NaN\u2019, \u2018NaN\u2019, \u2026],\n| - \u2026\n| ],\n| \\* \u2018header\u2019: (dict){\n| - \u2018all_sensors\u2019: \u2018F\u2019,\n| - \u2018dbd_lable\u2019: \u2018DBD(dinkum_library_data)file\u2019,\n| - \u2018encoding_ver\u2019: \u20185\u2019,\n| - \u2026\n| }\n\n}\n\n| **dinkum2pandas**\n| Decode a Dinkum Binary Data file or all Dinkum Binary Data under the\n  specific directory.\n| Return a list of pandas dataframe, column names format\n  sensor_name(unit)\n| with_unit (bool parameter, default set to false): whether the output\n  pandas with unit\n| appending (bool parameter, default set to false): whether the merge\n  output pandas together\n| (flight files merge with flight files, and sci files merge with sci\n  files)\n| if appending set to True, then will return two pandas:\n| one for all flight flies pandas merge together, and one for all sci\n  files merge together\n| ``res = dinkum.dinkum2pandas(sample_file_directory_path, cache_path, with_unit=False, appending=False)``\n| res looks like [df1, df2, df3] (if under input dir has three Dinkum\n  Binary files)\n| each dataframe looks like:\n\n== ================== ============== ============== =\n\\  sci_m_present_time sci_water_cond sci_water_temp \u2026\n== ================== ============== ============== =\n0  timestamp          s/m            degc           \u2026\n1  1528669160.1608582 2.9354474656   7.356734       \u2026\n\u2026  \u2026                  \u2026              \u2026              \u2026\n== ================== ============== ============== =\n\n| **dbd_asc2dict** Conver DBD asc file to python dictionary, which looks\n  like {\u2018data\u2019: dstruct, \u2018meta\u2019: meta}\n| column_output=[] to specified the coloumns of data in the result\n  (include all coloumns by default)\n| ``res = dbd_asc2dict(dbd_asc_name, column_output=[])``\n| res looks like\n| { \\* \u2018data\u2019: (list)[ - [\u20182\u2019, \u2018233\u2019, \u20180\u2019, \u2018-1\u2019, \u2026], - [\u2018NaN\u2019, \u2018NaN\u2019,\n  \u2018NaN\u2019, \u2018NaN\u2019, \u2026], - \u2026 ],\n| \\* \u2018meta\u2019: (dict){ - \u2018num_segments\u2019: \u20181\u2019, - \u2018all_sensor\u2019: \u20181\u2019, -\n  \u2018dbd_label\u2019: \u2018DBD_SAC\u2019, - \u2018columns\u2019: (list)[ - [\u2018cc_bpump_mode\u2019,\n  \u2018cc_bpump_value\u2019, \u2018cc_depth_state_mode\u2019, \u2018cc_final_bpump_value\u2019, \u2026], -\n  [\u2018enum\u2019, \u2018X\u2019, \u2018enum\u2019, \u2018enum\u2019, \u2018X\u2019, \u2018enum\u2019, \u2026], - [\u20181\u2019, \u20184\u2019, \u20181\u2019, \u20181\u2019,\n  \u20184\u2019, \u20181\u2019, \u2026] ] - \u2026.\n\n::\n\n   }\n\n}\n\n| **dinkumMergeAscii**\n| Merge flight file and sci file by timestamp\n| Files that need to merge should have same file name but different\n  extension\n| ``res = dinkumMergeAscii(source_directory_or_file_list, output_directory=None)``\n| merge ascii flight file and sci file by timestamp (flight\u2019s\n  m_present_time with sci\u2019s sci_m_present_time)\n\n============== ==================\nm_present_time sci_m_present_time\n============== ==================\ndbd            ebd\nsbd            tbd\n============== ==================\n\n| eg: merge file1.dbd with file1.ebd, file2.sbd with file2.tbd\n| input could be a source_directory or a list include ascii file paths\n  (eg:[file1.dbd, file1.ebd])\n| return a list of python dictionaries\n| or convert dicts to ascii file into the given output_dir (if output\n  path was specified)\n| res looks like [dict1, dict2, dict3] (if under input dir has three\n  pair ascii flight & sci files)\n| dict looks like\n| { \\* \u2018data\u2019: (list)[ - [\u20182\u2019, \u2018233\u2019, \u20180\u2019, \u2018-1\u2019, \u2026], - [\u2018NaN\u2019, \u2018NaN\u2019,\n  \u2018NaN\u2019, \u2018NaN\u2019, \u2026], - \u2026 ],\n| \\* \u2018meta\u2019: (dict){ - \u2018num_segments\u2019: \u20181\u2019, - \u2018all_sensor\u2019: \u20181\u2019, -\n  \u2018dbd_label\u2019: \u2018DBD_SAC\u2019, - \u2018columns\u2019: (list)[ - [\u2018cc_bpump_mode\u2019,\n  \u2018cc_bpump_value\u2019, \u2018cc_depth_state_mode\u2019, \u2018cc_final_bpump_value\u2019, \u2026], -\n  [\u2018enum\u2019, \u2018X\u2019, \u2018enum\u2019, \u2018enum\u2019, \u2018X\u2019, \u2018enum\u2019, \u2026], - [\u20181\u2019, \u20184\u2019, \u20181\u2019, \u20181\u2019,\n  \u20184\u2019, \u20181\u2019, \u2026] ] - \u2026.\n\n::\n\n   }\n\n}\n\n| **dinkumMergeBinary**\n| Input could be a source_directory or a list include file paths\n| First decode the binary file(s) under (source_directory/decode_result)\n| And then return a list of python dictionaries that merge flight file\n  with science file timestamp\n| or convert dicts to ascii file into the given output_dir (if output\n  path was specified)\n| merge binary files by timestamp (flight\u2019s m_present_time with sci\u2019s\n  sci_m_present_time)\n\n============== ==================\nm_present_time sci_m_present_time\n============== ==================\ndbd            ebd\nsbd            tbd\n============== ==================\n\n| ``res = dinkumMergeBinary(source_directory, cache_directory, destination_dictory)``\n| res looks like [dict1, dict2, dict3] (if under input dir has three\n  pair binary flight & sci files) dict looks like\n| { \\* \u2018data\u2019: (list)[ - [\u20182\u2019, \u2018233\u2019, \u20180\u2019, \u2018-1\u2019, \u2026], - [\u2018NaN\u2019, \u2018NaN\u2019,\n  \u2018NaN\u2019, \u2018NaN\u2019, \u2026], - \u2026 ],\n| \\* \u2018meta\u2019: (dict){ - \u2018num_segments\u2019: \u20181\u2019, - \u2018all_sensor\u2019: \u20181\u2019, -\n  \u2018dbd_label\u2019: \u2018DBD_SAC\u2019, - \u2018columns\u2019: (list)[ - [\u2018cc_bpump_mode\u2019,\n  \u2018cc_bpump_value\u2019, \u2018cc_depth_state_mode\u2019, \u2018cc_final_bpump_value\u2019, \u2026], -\n  [\u2018enum\u2019, \u2018X\u2019, \u2018enum\u2019, \u2018enum\u2019, \u2018X\u2019, \u2018enum\u2019, \u2026], - [\u20181\u2019, \u20184\u2019, \u20181\u2019, \u20181\u2019,\n  \u20184\u2019, \u20181\u2019, \u2026] ] - \u2026.\n\n::\n\n   }\n\n}\n",
            "description_content_type": "",
            "docs_url": null,
            "download_url": "",
            "downloads": {
                "last_day": -1,
                "last_month": -1,
                "last_week": -1
            },
            "home_page": "https://ceotr.ocean.dal.ca/",
            "keywords": "",
            "license": "GNU General Public License v3 (GPLv3)",
            "maintainer": "",
            "maintainer_email": "",
            "name": "dinkum",
            "package_url": "https://pypi.org/project/dinkum/",
            "platform": null,
            "project_url": "https://pypi.org/project/dinkum/",
            "project_urls": {
                "Homepage": "https://ceotr.ocean.dal.ca/"
            },
            "release_url": "https://pypi.org/project/dinkum/1.0.4/",
            "requires_dist": null,
            "requires_python": ">=3.8",
            "summary": "Some functions for interacting with [destmn]bd files in Python. Intent is to return a usable data object.",
            "version": "1.0.4",
            "yanked": false,
            "yanked_reason": null
        },
        "last_serial": 15511493,
        "urls": [
            {
                "comment_text": "",
                "digests": {
                    "md5": "b1e140e817f6f2c752e4d0d2a0c419eb",
                    "sha256": "aceb75914b13fb98fc414d9fadacb056464b502dda8695312006982ee40e91bf"
                },
                "downloads": -1,
                "filename": "dinkum-1.0.4.tar.gz",
                "has_sig": false,
                "md5_digest": "b1e140e817f6f2c752e4d0d2a0c419eb",
                "packagetype": "sdist",
                "python_version": "source",
                "requires_python": ">=3.8",
                "size": 31768,
                "upload_time": "2022-10-24T16:51:14",
                "upload_time_iso_8601": "2022-10-24T16:51:14.179815Z",
                "url": "https://files.pythonhosted.org/packages/98/cf/aa097c95667c2a89d459f1d262d1d2d65a5cfc2d4a9427c8d7ad85200e5c/dinkum-1.0.4.tar.gz",
                "yanked": false,
                "yanked_reason": null
            }
        ],
        "vulnerabilities": []
    }
}